# -*- coding: UTF-8 -*-
from sage.all import *
#GRAPH UTILITIES

def check_independence_extension(g,S):
    """
    Returns True if the set S extends to a maximum independent set of the graph g.

        sage: check_independence_extension(graphs.CycleGraph(6), Set([0,2]))
        True
        sage: check_independence_extension(graphs.CycleGraph(6), Set([0,3]))
        False
    """
    V = g.vertices()
    alpha = g.independent_set(value_only=True)
    #print alpha

    if not S.issubset(Set(V)) or not g.is_independent_set(S):
        return False

    N = neighbors_set(g,S)
    X = [v for v in V if v not in S and v not in N]
    h = g.subgraph(X)
    alpha_h = h.independent_set(value_only=True)
    #print alpha_h, len(S)

    return (alpha == alpha_h + len(S))

def find_alpha_critical_graphs(order, save = False):
    """
    Returns a list of the graph6 string of each of the alpha critical graphs of
    the given order. A graph g is alpha critical if alpha(g-e) > alpha(g) for
    every edge e in g. This looks at every graph of the given order, so this
    will be slow for any order larger than 8.
    If save = True (default False), then list will be saved to a file
    named "alpha_critical_name_list_{order}".

    There is a unique alpha critical graph on 3 and 4 vertices::

        sage: find_alpha_critical_graphs(3)
        ['Bw']
        sage: find_alpha_critical_graphs(4)
        ['C~']

    There are two alpha critical graphs on 5 vertices::

        sage: find_alpha_critical_graphs(5)
        ['Dhc', 'D~{']

    There are two alpha critical graphs on 6 vertices::

        sage: find_alpha_critical_graphs(6)
        ['E|OW', 'E~~w']
    """
    graphgen = graphs(order)
    alpha_critical_name_list = []
    for g in graphgen:
        if g.is_connected():
            if is_alpha_critical(g):
                alpha_critical_name_list.append(g.graph6_string())
    s = "alpha_critical_name_list_{}".format(order)
    if save:
        save(alpha_critical_name_list, s)
    return alpha_critical_name_list

def is_degree_sequence(L):
    """
    Returns True if the list L is the degree sequence of some graph.

    Since a graph always contains at least two vertices of the same degree, a
    list containing no duplicates cannot be a degree sequence::

        sage: is_degree_sequence([i for i in range(8)])
        False

    A cycle has all degrees equal to two and exists for any order larger than
    3, so a list of twos of length at least 3 is a degree sequence::

        sage: is_degree_sequence([2]*10)
        True
    """
    try:
        graphs.DegreeSequence(L)
    except:
        return False
    return True

#ALPHA APPROXIMATIONS

def find_lower_bound_sets(g, i):
    """
    Returns a list of independent sets of size i unioned with their neighborhoods.
    Since this checks all subsets of size i, this is a potentially slow method!

        sage: l = find_lower_bound_sets(graphs.CycleGraph(6),2)
        sage: l
        [{0, 1, 2, 3, 5},
         {0, 1, 2, 3, 4, 5},
         {0, 1, 3, 4, 5},
         {0, 1, 2, 3, 4},
         {0, 1, 2, 4, 5},
         {1, 2, 3, 4, 5},
         {0, 2, 3, 4, 5}]
        sage: type(l[0])
        <class 'sage.sets.set.Set_object_enumerated_with_category'>
    """
    V = g.vertices()
    lowersets = []

    for S in Subsets(Set(V),i):
        if g.is_independent_set(S):
            T = Set(closed_neighborhood(g,list(S)))
            if T not in Set(lowersets):
                lowersets.append(T)
    return lowersets

def alpha_lower_approximation(g, i):
    LP = MixedIntegerLinearProgram(maximization=False)
    x = LP.new_variable(nonnegative=True)

    # We define the objective
    LP.set_objective(sum([x[v] for v in g]))

    # For any subset, we define a constraint
    for j in range(1,i+1):
        for S in find_lower_bound_sets(g, j):
            #print S, S.cardinality()

            LP.add_constraint(sum([x[k] for k in S]), min = j)

    LP.solve()

    #return LP

    x_sol = LP.get_values(x)
    print x_sol
    return sum(x_sol.values())

#input = graph g
#output = bipartite graph with twice as many nodes and edges
#new nodes are labeled n to 2n-1
#assumes nodes in g are labeled [0..n-1]
#same as cartesian product with k2, but output labeling is guarnateed to be integers
def make_bidouble_graph(g):
    n = g.order()
    gdub = Graph(2*n)
    #print "gdub order = {}".format(gdub.order())

    for (i,j) in g.edges(labels = False):
        #print (i,j)
        gdub.add_edge(i,j+n)
        gdub.add_edge(j,i+n)
    return gdub

def neighbors_set(g,S):
    N = set()
    for v in S:
        for n in g.neighbors(v):
            N.add(n)
    return list(N)

def closed_neighborhood(g, verts):
    if isinstance(verts, list):
        neighborhood = []
        for v in verts:
            neighborhood += [v] + g.neighbors(v)
        return list(set(neighborhood))
    else:
        return [verts] + g.neighbors(verts)

def is_alpha_critical(g):
    #if not g.is_connected():
        #return False
    alpha = g.independent_set(value_only=True)
    for e in g.edges():
        gc = copy(g)
        gc.delete_edge(e)
        alpha_prime = gc.independent_set(value_only=True)
        if alpha_prime <= alpha:
            return False
    return True

#HEURISTIC ALGORITHMS

#takes vertex of max degree, deletes so long as degree > 0, returns remaining ind set
def MAXINE_independence_heuristic(g):
    V = g.vertices()
    h = g.subgraph(V)
    delta = max(h.degree())

    while delta > 0:
        #print "V is {}".format(V)
        #print "h vertices = {}, h.degree = {}".format(h.vertices(),h.degree())

        max_degree_vertex = V[h.degree().index(delta)]
        #print "max_degree_vertex = {}".format(max_degree_vertex)
        #print "h.neighbors(max_degree_vertex) = {}".format(h.neighbors(max_degree_vertex))
        V.remove(max_degree_vertex)
        h = g.subgraph(V)
        delta = max(h.degree())
        print "delta = {}".format(delta)

    return len(V)

#takes vertex of min degree, adds it to max ind set until no vertices left
def MIN_independence_heuristic(g):
    V = g.vertices()
    I = []
    while V != []:
        #print "V is {}".format(V)
        h = g.subgraph(V)
        #print "h vertices = {}, h.degree = {}".format(h.vertices(),h.degree())
        delta = min(h.degree())
        #print "delta = {}".format(delta)
        min_degree_vertex = V[h.degree().index(delta)]
        #print "min_degree_vertex = {}".format(min_degree_vertex)
        I.append(min_degree_vertex)
        V = [v for v in V if v not in closed_neighborhood(h, min_degree_vertex)]
        #break
    return len(I)

"""
Returns true if the given graph exists in the given list.
It also prints out all graphs in the list that are isomorphic so that duplicates may also be found here.
"""
def does_graph_exist(g, L):
    success = False
    for gL in L:
        if g.is_isomorphic(gL):
            print gL.name()
            success = True
    return success

"""
Returns a list of all pairs of isomorphic graphs in the given list.
"""
import itertools
def find_isomorphic_pairs(l):
    pairs = []
    L = itertools.combinations(l, r = 2)
    for pair in L:
        if pair[0].is_isomorphic(pair[1]):
            pairs.append(pair)
    return pairs

def find_all_max_ind_sets(g):
    """
    Finds all the maximum independent sets and stores them in a list
    """
    final_list = []
    V = Set(g.vertices())
    alpha = independence_number(g)

    for s in V.subsets(alpha):
        if g.is_independent_set(s):
            final_list.append(s)

    return final_list

def add_to_lists(graph, *L):
    """
    Adds the specified graph to the arbitrary number of lists given as the second through last argument
    Use this function to build the lists of graphs
    """
    for list in L:
            list.append(graph)

def MIR(n):
    if n < 2:
        raise RuntimeError("MIR is defined for n >= 2")
    if n % 2 == 0:
        g = graphs.PathGraph(2)
    else:
        g = graphs.PathGraph(3)
    while g.order() < n:
        new_v = g.add_vertex()
        for v in g.vertices():
            if v != new_v:
                g.add_edge(v, new_v)
        g.add_edge(new_v, g.add_vertex())
    return g

def Ciliate(q, r):
    if q < 1:
        raise RuntimeError("q must be greater than or equal to 1")
    if r < q:
        raise RuntimeError("r must be greater than or equal to q")
    if q == 1:
        return graphs.PathGraph(2*r)
    if q == r:
        return graphs.CycleGraph(2*q)
    g = graphs.CycleGraph(2*q)
    for v in g.vertices():
        g.add_path([v]+[g.add_vertex() for _ in range(r-q)])
    return g

def Antihole(n):
    if n < 5:
        raise RuntimeError("antihole is defined for n > 5")
    return graphs.CycleGraph(n).complement()

def Caro_Roditty(n):
    """
    p.171
    Caro, Y., and Y. Roditty. "On the vertex-independence number and star decomposition of graphs." Ars Combinatoria 20 (1985): 167-180.
    """
    g = graphs.CycleGraph(4)
    iters = 1
    while iters < n:
        len_v = len(g.vertices())
        g.add_cycle(range(len_v, len_v + 4))
        last_cycle = g.vertices()[-4:]
        for v in last_cycle:
            g.add_edge(v, v-4)
        iters += 1
    return g

def find_all_triangles(g):
    E = g.edges()
    A = g.adjacency_matrix()
    pos = {v:p for (p,v) in enumerate(g.vertices())}
    triangles = []

    for e in E:
        v,w = (e[0], e[1]) if pos[e[0]] < pos[e[1]] else (e[1], e[0])
        S = [u for u in g.vertices() if g.has_edge(u,v) and g.has_edge(u,v) and pos[u] > pos[w]]
        for u in S:
            s = Set([u,v,w])
            triangles.append(s)
    return triangles

# the triangles of a graph g are the vertices of the returned auxilliary graph aux_g
# with edges in aux_g between a pair of vertices in aux_g if the corresponding triangles share a vertex of g
def form_triangles_graph(g):
    vertices = find_all_triangles(g)
    edges = []
    for i in range(len(vertices)-1):
        for j in range(i+1, len(vertices)):
            if not((vertices[i].intersection(vertices[j])).is_empty()):
                edges.append((vertices[i],vertices[j]))
    return Graph([vertices,edges])

def max_bipartite_set(g,s,c):
    #print "s is {}".format(s)
    #print "c is {}".format(c)
    if len(c) == 0:
        return s

    v = c[0]
    #print "v is {}".format(v)
    SCopy = copy(s)
    SCopy.append(v)
    Gprime = g.subgraph(SCopy)

    CCopy = copy(c)
    CCopy.remove(v) #CCopy is C with v removed
    if not(Gprime.is_bipartite()):
        #print "{} is not bipartite".format(SCopy)
        return max_bipartite_set(g, s, CCopy)


    temp1 = max_bipartite_set(g, SCopy, CCopy)
    temp2 = max_bipartite_set(g, s, CCopy)

    if len(temp1) > len(temp2):
        return temp1
    else:
        return temp2

# output = closure of input graph
# Useful: a graph is hamiltonian iff its closure is hamiltonian
def closure(graph):
    """
    Test cases:
        sage: closure(graphs.CycleGraph(4)).is_isomorphic(graphs.CompleteGraph(4))
        True
        sage: closure(graphs.CycleGraph(5)).is_isomorphic(graphs.CycleGraph(5))
        True
    """
    from itertools import combinations
    g = graph.copy()
    while(True):
        flag = False
        deg = g.degree()
        for (v,w) in combinations(g.vertices(), 2):
            if (not g.has_edge(v,w)) and deg[v] + deg[w] >= g.order():
                g.add_edge(v,w)
                flag = True
        if flag == False:
            break
    return g

def is_simplical_vertex(g, v):
    """
    Vertex v is a simplical vertex in g if the induced neighborhood of v is a clique
    """
    neighbors = g.neighbors(v)
    induced_neighborhood = g.subgraph(neighbors)
    return induced_neighborhood.is_clique()

# Defined by Sergey Norin at SIAM DM 2018
def is_homogenous_set(g, s):
    """
    Set of vertices s is homogenous if s induces a clique or s is an independent set.
    """
    induced_g = g.subgraph(s)
    return g.is_independent_set(s) or induced_g.is_clique()

def generalized_degree(g,S):
    """
    The cardinality of the union of the neighborhoods of each v in S.
    """
    neighborhood_union = set(w for v in S for w in g.neighbors(v))
    return len(neighborhood_union)

def common_neighbors_of_set(g, s):
    """
    Returns the vertices in g adjacent to every vertex in s
    """
    if not s:
        return []
    comm_neigh = set(g.neighbors(s[0]))
    for v in s[1:]:
        comm_neigh = comm_neigh.intersection(set(g.neighbors(v)))
    return list(comm_neigh)

def common_neighbors(g, v, w):
    """
    returns the Set of common neighbors of v and w in graph g
        sage: common_neighbors(p4, 0, 3)
        {}
        sage: common_neighbors(p4, 0, 2)
        {1}
    """
    Nv = Set(g.neighbors(v))
    Nw = Set(g.neighbors(w))
    return Nv.intersection(Nw)

def extremal_triangle_free_extension(g):
    """
    Returns graph with edges added until no more possible without creating triangles.
    If input is not triangle-free, raises RuntimeError.

    This function is not deterministic; the output may vary among any of possibly many extremal triangle-free extensions.
    The output is also not necessarily the maximal triangle-free extension.
    """
    if not g.is_triangle_free():
        raise RuntimeError("Graph is not triangle-free")

    g2 = g.copy()
    from itertools import combinations
    for (v,w) in combinations(sample(g2.vertices(), k = g2.order()), 2): # Sample so output not deterministic
        if not g2.has_edge(v, w) and all(u not in g2.neighbors(v) for u in g2.neighbors(w)):
            g2.add_edge(v, w)
    return g2

def pyramid_encapsulation(g):
    """
    Returns the pyramid encapsulation of graph g.

    Let a pyramid be a triangle with each edge bisected, and the midpoints
        joined to form an inner triangle on vertices 0,1,2
    For any graph g, make all its vertices adjacent to 0,1,2.

    The pyramid is a pebbling Class1 graph (pebbling number is order + 1).
    The pyramid encapuslation always yields a Class1 graph.
    """
    pyramid = graphs.CompleteGraph(3)
    pyramid.add_vertices([3, 4, 5])
    pyramid.add_edges([[3,1], [3,0], [4,1], [4,2], [5,0], [5,2]])

    pe = pyramid.disjoint_union(g)
    for v in [0, 1, 2]:
        for w in g.vertices():
            pe.add_edge((0, v), (1,w))
    return pe

def cycle_lengths(g):
    """
    Returns set of all cycle lengths in g - without repetition

    If g is acyclic, returns an empty list.
    Performs depth-first search of all possible cycles.
    """
    lengths = set()
    for init_vertex in g.vertices():
        path_stack = [[init_vertex]]
        while path_stack:
            path = path_stack.pop()
            for neighbor in g.neighbors(path[-1]):
                if neighbor not in path:
                    path_stack.append(path + [neighbor])
                elif neighbor == path[0] and len(path) > 2:
                    lengths.add(len(path))
    return lengths

def max_induced_tree(g):
    """
    Returns *a* maximum-size tree which is an induced subgraph of g

    Raises ValueError if g is not connected, since some invariant theorems assume connected.
    """
    if not g.is_connected():
        raise ValueError("Input graph is not connected")

    from itertools import combinations
    for j in xrange(g.order()):
        for subset in combinations(sample(g.vertices(), k = g.order()), j): # randomize so avg.-case time, not worst-case
            sub_g = g.copy()
            sub_g.delete_vertices(subset)
            if sub_g.is_tree():
                return sub_g

def max_induced_forest(g):
    """
    Returns *a* maximum-size induced subgraph of g which is a forest

    Accepts both connected and disconnected graphs as input.
    """
    from itertools import combinations
    for j in xrange(g.order()):
        for subset in combinations(sample(g.vertices(), k = g.order()), j): # randomize so avg.-case time, not worst-case
            sub_g = g.copy()
            sub_g.delete_vertices(subset)
            if sub_g.is_forest():
                return sub_g

def is_matching(s):
    """
    True if set of edges s is a matching, i.e. no edges share a common vertex

    Ignores edges labels; only compares indices 0 and 1 in edge tuples.
    """
    vertex_list = [v for e in s for v in e[:2]] # Ignore any labels
    if len(vertex_list) != len(set(vertex_list)):
        return False
    else:
        return True

def mobius_ladder(k):
    """
    A mobius ladder with parameter k is a cubic graph on 2k vertices which can
    be constructed by taking a cycle on 2k vertices and connecting opposite
    vertices.

    sage: ml10 = mobius_ladder(10)
    sage: ml10
    mobius_ladder_10: Graph on 20 vertices
    sage: ml10.order()
    20
    sage: ml10.degree()
    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
    sage: ml10.is_apex()
    True
    sage: ml10.is_vertex_transitive()
    True
    """
    g = graphs.CycleGraph(2*k)
    for i in range(k):
        g.add_edge(i, i+k)
    g.name(new = "mobius_ladder_{}".format(k))
    return g

def benoit_boyd_graphs(a, b, c):
    """
    Two triangles pointed at eachother, with opposite vertices connected by paths of a,b,c respective edges. Triangles weighted 0.5, paths 1.0.

    Pg. 927 of Geneviève Benoit and Sylvia Boyd, Finding the Exact Integrality Gap for Small Traveling Salesman Problems.
        Mathematics of Operations Research, 33(4): 921--931, 2008.
    """
    g = Graph(0, weighted = True)
    for i in xrange(0, a):
        g.add_edge(i, i + 1, 1)
    for i in xrange(a + 1, a + b + 1):
        g.add_edge(i, i + 1, 1)
    for i in xrange(a + b + 2, a + b + c + 2):
        g.add_edge(i, i + 1, 1)
    g.add_edges([(0, a + 1, 0.5), (a + 1, a + b + 2, 0.5), (0, a + b + 2, 0.5)])
    g.add_edges([(a, a + b + 1, 0.5), (a + b + 1, a + b + c + 2, 0.5), (a, a + b + c + 2, 0.5)])
    return g

def benoit_boyd_graphs_2(a, b, c):
    """
    Two triangles pointed at eachother, with opposite vertices connected by paths of a,b,c respective edges. Weights more complicated.

    Paths each weighted 1/a, 1/b, 1/c. The triangles are weighted with the sum of the paths they join, e.g. 1/a+1/b or 1/b+1/c.

    Pg. 928 of Geneviève Benoit and Sylvia Boyd, Finding the Exact Integrality Gap for Small Traveling Salesman Problems.
        Mathematics of Operations Research, 33(4): 921--931, 2008.
    """
    g = Graph(0, weighted = True)
    for i in xrange(0, a):
        g.add_edge(i, i + 1, 1/a)
    for i in xrange(a + 1, a + b + 1):
        g.add_edge(i, i + 1, 1/b)
    for i in xrange(a + b + 2, a + b + c + 2):
        g.add_edge(i, i + 1, 1/c)
    g.add_edges([(0, a + 1, 1/a + 1/b), (a + 1, a + b + 2, 1/b + 1/c), (0, a + b + 2, 1/a + 1/c)])
    g.add_edges([(a, a + b + 1, 1/a + 1/b), (a + b + 1, a + b + c + 2, 1/b + 1/c), (a, a + b + c + 2, 1/a + 1/c)])
    return g

def bipartite_double_cover(g):
    """
    Returns the bipatite double cover of a graph ``g``.

    From :wikipedia:`Bipartite double cover`:
    The bipartite double cover of ``g`` may also be known as the
    Kronecker double cover, canonical double cover or the bipartite double of G.
    For every vertex `v_i` of ``g``, there are two vertices `u_i` and `w_i`.
    Two vertices `u_i` and `w_j` are connected by an edge in the double cover if
    and only if `v_i` and `v_j` are connected by an edge in ``g``.

    EXAMPLES:

        sage: bipartite_double_cover(graphs.PetersenGraph()).is_isomorphic(graphs.DesarguesGraph())
        True

        sage: bipartite_double_cover(graphs.CycleGraph(4)).is_isomorphic(graphs.CycleGraph(4).disjoint_union(graphs.CycleGraph(4)))
        True
    """
    return g.tensor_product(graphs.CompleteGraph(2))

#TESTING

#check for invariant relation that separtates G from class defined by property
def find_separating_invariant_relation(g, objects, property, invariants):
    L = [x for x in objects if (property)(x)]
    for inv1 in invariants:
        for inv2 in invariants:
            if inv1(g) > inv2(g) and all(inv1(x) <= inv2(x) for x in L):
                return inv1.__name__, inv2.__name__
    print "no separating invariants"



#finds "difficult" graphs for necessary conditions, finds graphs which don't have property but which have all necessary conditions
def test_properties_upper_bound_theory(objects, property, theory):
     for g in objects:
         if not property(g) and all(f(g) for f in theory):
             print g.name()

#finds "difficult" graphs for sufficient conditions, finds graphs which dont have any sufficient but do have property
def test_properties_lower_bound_theory(objects, property, theory):
     for g in objects:
         if property(g) and not any(f(g) for f in theory):
             print g.name()

def find_coextensive_properties(objects, properties):
     for p1 in properties:
         for p2 in properties:
             if p1 != p2 and all(p1(g) == p2(g) for g in objects):
                 print p1.__name__, p2.__name__
     print "DONE!"

print("loaded utilities")

#############################################################################
# End of utilities section                                                  #
#############################################################################
#GRAPH INVARIANTS
all_invariants = []

efficient_invariants = []
intractable_invariants = []
theorem_invariants = []
broken_invariants = []

"""
    Last version of graphs packaged checked: Sage 8.2
    sage: sage.misc.banner.version_dict()['major'] < 8 or (sage.misc.banner.version_dict()['major'] == 8 and sage.misc.banner.version_dict()['minor'] <= 2)
    True
"""
sage_efficient_invariants = [Graph.number_of_loops, Graph.density, Graph.order, Graph.size, Graph.average_degree,
Graph.triangles_count, Graph.szeged_index, Graph.radius, Graph.diameter, Graph.girth, Graph.wiener_index,
Graph.average_distance, Graph.connected_components_number, Graph.maximum_average_degree, Graph.lovasz_theta,
Graph.spanning_trees_count, Graph.odd_girth, Graph.clustering_average, Graph.cluster_transitivity]

sage_intractable_invariants = [Graph.chromatic_number, Graph.chromatic_index, Graph.treewidth,
Graph.clique_number, Graph.pathwidth, Graph.fractional_chromatic_index, Graph.edge_connectivity,
Graph.vertex_connectivity, Graph.genus, Graph.crossing_number]

for i in sage_efficient_invariants:
    add_to_lists(i, efficient_invariants, all_invariants)
for i in sage_intractable_invariants:
    add_to_lists(i, intractable_invariants, all_invariants)

def distinct_degrees(g):
    """
    returns the number of distinct degrees of a graph
        sage: distinct_degrees(p4)
        2
        sage: distinct_degrees(k4)
        1
    """
    return len(set(g.degree()))
add_to_lists(distinct_degrees, efficient_invariants, all_invariants)

def max_common_neighbors(g):
    """
    Returns the maximum number of common neighbors of any pair of distinct vertices in g.

        sage: max_common_neighbors(p4)
        1
        sage: max_common_neighbors(k4)
        2
    """
    max = 0
    V = g.vertices()
    n = g.order()
    for i in range(n):
        for j in range(n):
            if i < j:
                temp = len(common_neighbors(g, V[i], V[j]))
                if temp > max:
                    max = temp
    return max
add_to_lists(max_common_neighbors, efficient_invariants, all_invariants)

def min_common_neighbors(g):
    """
    Returns the minimum number of common neighbors of any pair of distinct vertices in g,
    which is necessarily 0 for disconnected graphs.

        sage: min_common_neighbors(p4)
        0
        sage: min_common_neighbors(k4)
        2
    """
    n = g.order()
    min = n
    V = g.vertices()
    for i in range(n):
        for j in range(n):
            if i < j:
                temp = len(common_neighbors(g, V[i], V[j]))
                #if temp == 0:
                    #print "i={}, j={}".format(i,j)
                if temp < min:
                    min = temp
    return min
add_to_lists(min_common_neighbors, efficient_invariants, all_invariants)

def mean_common_neighbors(g):
    """
    Returns the average number of common neighbors of any pair of distinct vertices in g.
        sage: mean_common_neighbors(p4)
        1/3
        sage: mean_common_neighbors(k4)
        2
    """
    V = g.vertices()
    n = g.order()
    sum = 0
    for i in range(n):
        for j in range(n):
            if i < j:
                sum += len(common_neighbors(g, V[i], V[j]))
    return 2*sum/(n*(n-1))
add_to_lists(mean_common_neighbors, efficient_invariants, all_invariants)

def min_degree(g):
    """
    Returns the minimum of all degrees of the graph g.

        sage: min_degree(graphs.CompleteGraph(5))
        4
        sage: min_degree(graphs.CycleGraph(5))
        2
        sage: min_degree(graphs.StarGraph(5))
        1
        sage: min_degree(graphs.CompleteBipartiteGraph(3,5))
        3
    """
    return min(g.degree())
add_to_lists(min_degree, efficient_invariants, all_invariants)

def max_degree(g):
    """
    Returns the maximum of all degrees of the graph g.

        sage: max_degree(graphs.CompleteGraph(5))
        4
        sage: max_degree(graphs.CycleGraph(5))
        2
        sage: max_degree(graphs.StarGraph(5))
        5
        sage: max_degree(graphs.CompleteBipartiteGraph(3,5))
        5
    """
    return max(g.degree())
add_to_lists(max_degree, efficient_invariants, all_invariants)

def median_degree(g):
    """
    Return the median of the list of vertex degrees.

        sage: median_degree(p4)
        3/2
        sage: median_degree(p3)
        1
    """
    return median(g.degree())
add_to_lists(median_degree, efficient_invariants, all_invariants)

def inverse_degree(g):
    """
    Return the sum of the reciprocals of the non-zero degrees.

    Return 0 if the graph has no edges.

        sage: inverse_degree(p4)
        3
        sage: inverse_degree(graphs.CompleteGraph(1))
        0
    """
    if g.size() == 0:
        return 0
    return sum([(1.0/d) for d in g.degree() if d!= 0])
add_to_lists(inverse_degree, efficient_invariants, all_invariants)

def eulerian_faces(g):
    """
    Returns 2 - order + size, which is the number of faces if the graph is planar,
    a consequence of Euler's Formula.

        sage: eulerian_faces(graphs.CycleGraph(5))
        2
        sage: eulerian_faces(graphs.DodecahedralGraph())
        12
    """
    n = g.order()
    m = g.size()
    return 2 - n + m
add_to_lists(eulerian_faces, efficient_invariants, all_invariants)

def barrus_q(g):
    """
    If the degrees sequence is in non-increasing order, with index starting at 1,
    barrus_q = max(k:d_k >= k)

    Defined by M. Barrus in "Havel-Hakimi Residues of Unigraphs", 2012

        sage: barrus_q(graphs.CompleteGraph(5))
        4
        sage: barrus_q(graphs.StarGraph(3))
        1
    """
    Degrees = g.degree()
    Degrees.sort()
    Degrees.reverse()
    return max(k for k in range(g.order()) if Degrees[k] >= (k+1)) + 1
add_to_lists(barrus_q, efficient_invariants, all_invariants)

def barrus_bound(g):
    """
    Returns n - barrus q

    Defined in: Barrus, Michael D. "Havel–Hakimi residues of unigraphs." Information Processing Letters 112.1 (2012): 44-48.

        sage: barrus_bound(k4)
        1
        sage: barrus_bound(graphs.OctahedralGraph())
        2
    """
    return g.order() - barrus_q(g)
add_to_lists(barrus_bound, efficient_invariants, all_invariants)

def matching_number(g):
    """
    Returns the matching number of the graph g, i.e., the size of a maximum
    matching.

    A matching is a set of independent edges.

    See: https://en.wikipedia.org/wiki/Matching_(graph_theory)

        sage: matching_number(graphs.CompleteGraph(5))
        2
        sage: matching_number(graphs.CycleGraph(5))
        2
        sage: matching_number(graphs.StarGraph(5))
        1
        sage: matching_number(graphs.CompleteBipartiteGraph(3,5))
        3
    """
    return int(g.matching(value_only=True, use_edge_labels=False))
add_to_lists(matching_number, efficient_invariants, all_invariants)

def residue(g):
    """
    If the Havel-Hakimi process is iterated until a sequence of 0s is returned,
    residue is defined to be the number of zeros of this sequence.

    See: Favaron, Odile, Maryvonne Mahéo, and J‐F. Saclé. "On the residue of a graph." Journal of Graph Theory 15.1 (1991): 39-64.

        sage: residue(k4)
        1
        sage: residue(p4)
        2
    """
    seq = g.degree_sequence()

    while seq[0] > 0:
        d = seq.pop(0)
        seq[:d] = [k-1 for k in seq[:d]]
        seq.sort(reverse=True)

    return len(seq)
add_to_lists(residue, efficient_invariants, all_invariants)

def annihilation_number(g):
    """
    Given the degree sequence in non-degreasing order, with indices starting at 1, the annihilation number is the largest index k so the sum of the first k degrees is no more than the sum of the remaining degrees

    See: Larson, Craig E., and Ryan Pepper. "Graphs with equal independence and annihilation numbers." the electronic journal of combinatorics 18.1 (2011): 180.

        sage: annihilation_number(c4)
        2
        sage: annihilation_number(p5)
        3
    """
    seq = sorted(g.degree())

    a = 0
    while sum(seq[:a+1]) <= sum(seq[a+1:]):
        a += 1

    return a
add_to_lists(annihilation_number, efficient_invariants, all_invariants)

def fractional_alpha(g):
    """
    This is the optimal solution of the linear programming relaxation of the integer programming formulation of independence number (alpha).

    See: Nemhauser, George L., and Leslie Earl Trotter. "Vertex packings: structural properties and algorithms." Mathematical Programming 8.1 (1975): 232-248.

        sage: fractional_alpha(k3)
        1.5
        sage: fractional_alpha(p5)
        3.0
    """
    if len(g.vertices()) == 0:
        return 0
    p = MixedIntegerLinearProgram(maximization=True)
    x = p.new_variable(nonnegative=True)
    p.set_objective(sum(x[v] for v in g.vertices()))

    for v in g.vertices():
        p.add_constraint(x[v], max=1)

    for (u,v) in g.edge_iterator(labels=False):
        p.add_constraint(x[u] + x[v], max=1)

    return p.solve()
add_to_lists(fractional_alpha, efficient_invariants, all_invariants)

def fractional_covering(g):
    """
    This is the optimal solution of the linear programming relaxation of the integer programming formulation of covering number.

    For ILP formulation see: https://en.wikipedia.org/wiki/Vertex_cover

        sage: fractional_covering(k3)
        1.5
        sage: fractional_covering(p5)
        2.0
    """
    if len(g.vertices()) == 0:
        return 0
    p = MixedIntegerLinearProgram(maximization=False)
    x = p.new_variable(nonnegative=True)
    p.set_objective(sum(x[v] for v in g.vertices()))

    for v in g.vertices():
        p.add_constraint(x[v], max=1)

    for (u,v) in g.edge_iterator(labels=False):
        p.add_constraint(x[u] + x[v], min=1)

    return p.solve()
add_to_lists(fractional_covering, efficient_invariants, all_invariants)

def cvetkovic(g):
    """
    This in the minimum of the number of nonnegative and nonpositive eigenvalues of the adjacency matrix.

    Cvetkovic's theorem says that this number is an upper bound for the independence number of a graph.

    See: Cvetković, Dragoš M., Michael Doob, and Horst Sachs. Spectra of graphs: theory and application. Vol. 87. Academic Pr, 1980.

        sage: cvetkovic(p5)
        3
        sage: cvetkovic(graphs.PetersenGraph())
        4
    """
    eigenvalues = g.spectrum()
    positive = 0
    negative = 0
    zero = 0
    for e in eigenvalues:
        if e > 0:
            positive += 1
        elif e < 0:
            negative += 1
        else:
            zero += 1

    return zero + min([positive, negative])
add_to_lists(cvetkovic, efficient_invariants, all_invariants)

def cycle_space_dimension(g):
    """
    Returns the dimension of the cycle space (also called the circuit rank).

    See: https://en.wikipedia.org/wiki/Cycle_space
    And: https://en.wikipedia.org/wiki/Circuit_rank

        sage: cycle_space_dimension(k3)
        1
        sage: cycle_space_dimension(c4c4)
        2
        sage: cycle_space_dimension(glasses_5_5)
        2
    """
    return g.size()-g.order()+g.connected_components_number()
add_to_lists(cycle_space_dimension, efficient_invariants, all_invariants)

def card_center(g):
    return len(g.center())
add_to_lists(card_center, efficient_invariants, all_invariants)

def card_periphery(g):
    return len(g.periphery())
add_to_lists(card_periphery, efficient_invariants, all_invariants)

def max_eigenvalue(g):
    return max(g.adjacency_matrix().change_ring(RDF).eigenvalues())
add_to_lists(max_eigenvalue, efficient_invariants, all_invariants)

def min_eigenvalue(g):
    return min(g.adjacency_matrix().change_ring(RDF).eigenvalues())
add_to_lists(min_eigenvalue, efficient_invariants, all_invariants)

def resistance_distance_matrix(g):
    L = g.laplacian_matrix()
    n = g.order()
    J = ones_matrix(n,n)
    temp = L+(1.0/n)*J
    X = temp.inverse()
    R = (1.0)*ones_matrix(n,n)
    for i in range(n):
        for j in range(n):
            R[i,j] = X[i,i] + X[j,j] - 2*X[i,j]
    return R

def kirchhoff_index(g):
    R = resistance_distance_matrix(g)
    return .5*sum(sum(R))
add_to_lists(kirchhoff_index, efficient_invariants, all_invariants)

def largest_singular_value(g):
    A = matrix(RDF,g.adjacency_matrix(sparse=False))
    svd = A.SVD()
    sigma = svd[1]
    return sigma[0,0]
add_to_lists(largest_singular_value, efficient_invariants, all_invariants)

def card_max_cut(g):
    return g.max_cut(value_only=True)
add_to_lists(card_max_cut, intractable_invariants, all_invariants)

def welsh_powell(g):
    """
    for degrees d_1 >= ... >= d_n
    returns the maximum over all indices i of of the min(i,d_i + 1)

    sage: welsh_powell(k5) = 4
    """
    n= g.order()
    D = g.degree()
    D.sort(reverse=True)
    mx = 0
    for i in range(n):
        temp = min({i,D[i]})
        if temp > mx:
            mx = temp
    return mx + 1
add_to_lists(welsh_powell, efficient_invariants, all_invariants)

#outputs upper bound from Brooks Theorem: returns Delta + 1 for complete and odd cycles
def brooks(g):
    Delta = max(g.degree())
    delta = min(g.degree())
    n = g.order()
    if is_complete(g):
        return Delta + 1
    elif n%2 == 1 and g.is_connected() and Delta == 2 and delta == 2: #same as if all degrees are 2
        return Delta + 1
    else:
        return Delta
add_to_lists(brooks, efficient_invariants, all_invariants)

#wilf's upper bound for chromatic number
def wilf(g):
    return max_eigenvalue(g) + 1
add_to_lists(wilf, efficient_invariants, all_invariants)

#a measure of irregularity
def different_degrees(g):
    return len(set(g.degree()))
add_to_lists(different_degrees, efficient_invariants, all_invariants)

def szekeres_wilf(g):
    """
    Returns 1+ max of the minimum degrees for all subgraphs
    Its an upper bound for chromatic number

    sage: szekeres_wilf(graphs.CompleteGraph(5))
    5
    """
    #removes a vertex, if possible, of degree <= i
    def remove_vertex_of_degree(gc,i):
        Dc = gc.degree()
        V = gc.vertices()
        #print "Dc is %s, V is %s" %(Dc,V)
        mind = min(Dc)
        #print "mind is %s" %mind
        if mind <= i:

            ind = Dc.index(mind)
            #print "ind is %s, vertex is %s" %(ind,V[ind])
            return gc.delete_vertex(V[ind])
        else:
            return gc
    D = g.degree()
    delta = min(D)
    Delta = max(D)
    for i in range(delta,Delta+1):
        gc = copy(g)
        value = g.order() + 1
        while gc.size() > 0 and gc.order() < value:
            #gc.show()
            value = gc.order()
            remove_vertex_of_degree(gc,i)
        if gc.size() == 0:
            return i + 1
add_to_lists(szekeres_wilf, efficient_invariants, all_invariants)

def average_vertex_temperature(g):
     D = g.degree()
     n = g.order()
     return sum([D[i]/(n-D[i]+0.0) for i in range(n)])/n
add_to_lists(average_vertex_temperature, efficient_invariants, all_invariants)

def sum_temperatures(g):
     D = g.degree()
     n = g.order()
     return sum([D[i]/(n-D[i]+0.0) for i in range(n)])
add_to_lists(sum_temperatures, efficient_invariants, all_invariants)

def randic(g):
     D = g.degree()
     V = g.vertices()
     if min(D) == 0:
          return oo
     sum = 0
     for e in g.edges():
         v = e[0]
         i = V.index(v)
         w = e[1]
         j = V.index(w)
         sum += 1.0/(D[i]*D[j])**0.5
     return sum
add_to_lists(randic, efficient_invariants, all_invariants)

#a very good lower bound for alpha
def max_even_minus_even_horizontal(g):
    """
    finds def max_even_minus_even_horizontal for each component and adds them up.
    """
    mx_even=0
    Gcomps=g.connected_components_subgraphs()

    while Gcomps != []:
            H=Gcomps.pop()
            temp=max_even_minus_even_horizontal_component(H)
            mx_even+=temp
            #print "temp = {}, mx_even = {}".format(temp,mx_even)

    return mx_even
add_to_lists(max_even_minus_even_horizontal, efficient_invariants, theorem_invariants, all_invariants)

def max_even_minus_even_horizontal_component(g):
    """
    for each vertex v, find the number of vertices at even distance from v,
    and substract the number of edges induced by these vertices.
    this number is a lower bound for independence number.
    take the max. returns 0 if graph is not connected
    """
    if g.is_connected()==False:
        return 0

    distances = g.distance_all_pairs()
    mx=0
    for v in g.vertices():
        Even=[]
        for w in g.vertices():
            if distances[v][w]%2==0:
                Even.append(w)

        #print len(Even), len(g.subgraph(Even).edges())
        l=len(Even)-len(g.subgraph(Even).edges())
        if l>mx:
            mx=l
    return mx

def laplacian_energy(g):
     L = g.laplacian_matrix().change_ring(RDF).eigenvalues()
     Ls = [1/lam**2 for lam in L if lam > 0]
     return 1 + sum(Ls)
add_to_lists(laplacian_energy, efficient_invariants, all_invariants)

def laplacian_energy_like(g):
    """
    Returns the sum of the square roots of the laplacian eigenvalues

    Liu, Jianping, and Bolian Liu. "A Laplacian-energy-like invariant of a graph." MATCH-COMMUNICATIONS IN MATHEMATICAL AND IN COMPUTER CHEMISTRY 59.2 (2008): 355-372.
    """
    return sum([sqrt(x) for x in g.spectrum(laplacian = True)])
add_to_lists(laplacian_energy_like, efficient_invariants, all_invariants)

#sum of the positive eigenvalues of a graph
def gutman_energy(g):
     L = g.adjacency_matrix().change_ring(RDF).eigenvalues()
     Ls = [lam for lam in L if lam > 0]
     return sum(Ls)
add_to_lists(gutman_energy, efficient_invariants, all_invariants)

#the second smallest eigenvalue of the Laplacian matrix of a graph, also called the "algebraic connectivity" - the smallest should be 0
def fiedler(g):
     L = g.laplacian_matrix().change_ring(RDF).eigenvalues()
     L.sort()
     return L[1]
add_to_lists(fiedler, broken_invariants, all_invariants)

def degree_variance(g):
     mu = mean(g.degree())
     s = sum((x-mu)**2 for x in g.degree())
     return s/g.order()
add_to_lists(degree_variance, efficient_invariants, all_invariants)

def graph_rank(g):
    return g.adjacency_matrix().rank()
add_to_lists(graph_rank, efficient_invariants, all_invariants)

def card_positive_eigenvalues(g):
    return len([lam for lam in g.adjacency_matrix().eigenvalues() if lam > 0])
add_to_lists(card_positive_eigenvalues, efficient_invariants, all_invariants)

def card_zero_eigenvalues(g):
    return len([lam for lam in g.adjacency_matrix().eigenvalues() if lam == 0])
add_to_lists(card_zero_eigenvalues, efficient_invariants, all_invariants)

def card_negative_eigenvalues(g):
    return len([lam for lam in g.adjacency_matrix().eigenvalues() if lam < 0])
add_to_lists(card_negative_eigenvalues, efficient_invariants, all_invariants)

def card_cut_vertices(g):
    return len((g.blocks_and_cut_vertices())[1])
add_to_lists(card_cut_vertices, efficient_invariants, all_invariants)

def card_connectors(g):
    return g.order() - card_cut_vertices(g)
add_to_lists(card_connectors, efficient_invariants, all_invariants)

#return number of leafs or pendants
def card_pendants(g):
    return sum([x for x in g.degree() if x == 1])
add_to_lists(card_pendants, efficient_invariants, all_invariants)

#returns number of bridges in graph
def card_bridges(g):
    gs = g.strong_orientation()
    bridges = []
    for scc in gs.strongly_connected_components():
        bridges.extend(gs.edge_boundary(scc))
    return len(bridges)
add_to_lists(card_bridges, efficient_invariants, all_invariants)

#upper bound for the domination number
def alon_spencer(g):
    delta = min(g.degree())
    n = g.order()
    return n*((1+log(delta + 1.0)/(delta + 1)))
add_to_lists(alon_spencer, efficient_invariants, all_invariants)

#lower bound for residue and, hence, independence number
def caro_wei(g):
    return sum([1.0/(d + 1) for d in g.degree()])
add_to_lists(caro_wei, efficient_invariants, all_invariants)

#equals 2*size, the 1st theorem of graph theory
def degree_sum(g):
    return sum(g.degree())
add_to_lists(degree_sum, efficient_invariants, all_invariants)

#smallest sum of degrees of non-adjacent degrees, invariant in ore condition for hamiltonicity
#default for complete graph?
def sigma_dist2(g):
    if g.size() == g.order()*(g.order()-1)/2:
        return g.order()
    Dist = g.distance_all_pairs()
    return min(g.degree(v) + g.degree(w) for v in g for w in g if Dist[v][w] > 1)
add_to_lists(sigma_dist2, efficient_invariants, all_invariants)

#cardinality of the automorphism group of the graph
def order_automorphism_group(g):
    return g.automorphism_group(return_group=False, order=True)
add_to_lists(order_automorphism_group, efficient_invariants, all_invariants)

#in sufficient condition for graphs where vizing's independence theorem holds
def brinkmann_steffen(g):
    E = g.edges()
    if len(E) == 0:
        return 0
    Dist = g.distance_all_pairs()
    return min(g.degree(v) + g.degree(w) for v in g for w in g if Dist[v][w] == 1)
add_to_lists(brinkmann_steffen, efficient_invariants, all_invariants)

def alpha_critical_optimum(g, alpha_critical_names):

    n = g.order()
    V = g.vertices()
    #g.show()

    alpha_critical_graph_names = []

    #get alpha_critical graphs with order <= n
    for name in alpha_critical_names:
        h = Graph(name)
        if h.order() <= n:
            alpha_critical_graph_names.append(h.graph6_string())

    #print alpha_critical_graphs

    LP = MixedIntegerLinearProgram(maximization=True)
    b = LP.new_variable(nonnegative=True)

    # We define the objective
    LP.set_objective(sum([b[v] for v in g]))

    # For any edge, we define a constraint
    for (u,v) in g.edges(labels=None):
        LP.add_constraint(b[u]+b[v],max=1)
        #LP.add_constraint(b[u]+b[v],min=1)

    #search through all subsets of g with order >= 3
    #and look for *any* subgraph isomorphic to an alpha critical graph
    #for any match we define a constraint

    i = 3
    while i <= n:
        SS = Subsets(Set(V),i)
        for S in SS:
            L = [g6 for g6 in alpha_critical_graph_names if Graph(g6).order() == i]
            #print L
            for g6 in L:
                h = Graph(g6)
                if g.subgraph(S).subgraph_search(h, induced=False):

                    #print S
                    #add constraint
                    alpha = independence_number(h)
                    #print h.graph6_string(), alpha
                    LP.add_constraint(sum([b[j] for j in S]), max = alpha, name = h.graph6_string())
        i = i + 1

    #for c in LP.constraints():
        #print c

    # The .solve() functions returns the objective value
    LP.solve()

    #return LP

    b_sol = LP.get_values(b)
    return b_sol, sum(b_sol.values())


###several invariants and auxiliary functions related to the Independence Decomposition Theorem

#finds all vertices with weight 1 in some max weighted stable set with wieghts in {0,1,1/2}
#had problem that LP solver has small numerical errors, fixed with kludgy if condition
def find_stable_ones_vertices(g):
    F = []
    alpha_f = fractional_alpha(g)
    for v in g.vertices():
        gc = copy(g)
        gc.delete_vertices(closed_neighborhood(gc, v))
        alpha_f_prime = fractional_alpha(gc)
        if abs(alpha_f - alpha_f_prime - 1) < .01:
            F.append(v)
    return F

def find_max_critical_independent_set(g):
    S = find_stable_ones_vertices(g)
    H = g.subgraph(S)
    return H.independent_set()

def critical_independence_number(g):
    return len(find_max_critical_independent_set(g))
add_to_lists(critical_independence_number, efficient_invariants, all_invariants)

def card_independence_irreducible_part(g):
    return len(find_independence_irreducible_part(g))
add_to_lists(card_independence_irreducible_part, efficient_invariants, all_invariants)

def find_independence_irreducible_part(g):
    X = find_KE_part(g)
    SX = Set(X)
    Vertices = Set(g.vertices())
    return list(Vertices.difference(SX))

#returns KE part guaranteed by Independence Decomposition Theorem
def find_KE_part(g):
    return closed_neighborhood(g, find_max_critical_independent_set(g))

def card_KE_part(g):
    return len(find_KE_part(g))
add_to_lists(card_KE_part, efficient_invariants, all_invariants)

def find_independence_irreducible_subgraph(g):
    return g.subgraph(find_independence_irreducible_part(g))

def find_KE_subgraph(g):
    return g.subgraph(find_KE_part(g))


#make invariant from property
def make_invariant_from_property(property, name=None):
    """
    This function takes a property as an argument and returns an invariant
    whose value is 1 if the object has the property, else 0
    Optionally a name for the new property can be provided as a second argument.
    """
    def boolean_valued_invariant(g):
        if property(g):
            return 1
        else:
            return 0

    if name is not None:
        boolean_valued_invariant.__name__ = name
    elif hasattr(property, '__name__'):
        boolean_valued_invariant.__name__ = '{}_value'.format(property.__name__)
    else:
        raise ValueError('Please provide a name for the new function')

    return boolean_valued_invariant

# defined by R. Pepper in an unpublished paper on graph irregularity
def geometric_length_of_degree_sequence(g):
    return sqrt(sum(d**2 for d in g.degree()))
add_to_lists(geometric_length_of_degree_sequence, efficient_invariants, all_invariants)

# Two Stability Theta Bound
# For graphs with alpha <= 2,
# lovasz_theta <= 2^(2/3)*n^(1/3)
# The Sandwich Theorem by Knuth p. 47
def two_stability_theta_bound(g):
    return 2**(2/3)*g.order()**(1/3)
add_to_lists(two_stability_theta_bound, efficient_invariants, all_invariants)

# Lovasz Theta over Root N
# The Sandwich Theorem by Knuth p. 45
def lovasz_theta_over_root_n(g):
    return g.lovasz_theta()/sqrt(g.order())
add_to_lists(lovasz_theta_over_root_n, efficient_invariants, all_invariants)

# Theta * Theta-Complement
# The Sandwich Theorem by Knuth, p. 27
def theta_theta_complement(g):
    return g.lovasz_theta() * g.complement().lovasz_theta()
add_to_lists(theta_theta_complement, efficient_invariants, all_invariants)

# Depth = Order - Residue
# This is the number of steps it takes for Havel-Hakimi to terminate
def depth(g):
    return g.order()-residue(g)
add_to_lists(depth, efficient_invariants, all_invariants)

# Lovasz Theta of the complement of the given graph
def lovasz_theta_complement(g):
    return g.complement().lovasz_theta()
add_to_lists(lovasz_theta_complement, efficient_invariants, all_invariants)

# N over lovasz_theta_complement
# This is a lower bound for lovasz theta
# The Sandwich Theorem by Knuth, p. 27
def n_over_lovasz_theta_complement(g):
    return g.order()/lovasz_theta_complement(g)
add_to_lists(n_over_lovasz_theta_complement, efficient_invariants, all_invariants)

# The number of vertices at even distance from v and return the max over all vertices
def max_even(g):
    from sage.graphs.distances_all_pairs import distances_all_pairs
    D = distances_all_pairs(g)
    evens_list = []
    for u in D:
        evens = 0
        for v in D[u]:
            if D[u][v] % 2 == 0:
                evens += 1
        evens_list.append(evens)
    return max(evens_list)
add_to_lists(max_even, efficient_invariants, all_invariants)

# The number of vertices at even distance from v and return the min over all vertices
def min_even(g):
    from sage.graphs.distances_all_pairs import distances_all_pairs
    D = distances_all_pairs(g)
    evens_list = []
    for u in D:
        evens = 0
        for v in D[u]:
            if D[u][v] % 2 == 0:
                evens += 1
        evens_list.append(evens)
    return min(evens_list)
add_to_lists(min_even, efficient_invariants, all_invariants)

# The number of vertices at odd distance from v and return the max over all vertices
def max_odd(g):
    from sage.graphs.distances_all_pairs import distances_all_pairs
    D = distances_all_pairs(g)
    odds_list = []
    for u in D:
        odds = 0
        for v in D[u]:
            if D[u][v] % 2 != 0:
                odds += 1
        odds_list.append(odds)
    return max(odds_list)
add_to_lists(max_odd, efficient_invariants, all_invariants)

# The number of vertices at odd distance from v and return the min over all vertices
def min_odd(g):
    from sage.graphs.distances_all_pairs import distances_all_pairs
    D = distances_all_pairs(g)
    odds_list = []
    for u in D:
        odds = 0
        for v in D[u]:
            if D[u][v] % 2 != 0:
                odds += 1
        odds_list.append(odds)
    return min(odds_list)
add_to_lists(min_odd, efficient_invariants, all_invariants)

#returns sum of distances between *distinct* vertices, return infinity is graph is not connected
def transmission(g):
    if not g.is_connected():
        return Infinity
    if g.is_tree() and max(g.degree()) == 2:
        summation = 0
        for i in range(1,g.order()):
            summation += (i*(i+1))/2
        return summation * 2
    else:
        V = g.vertices()
        D = g.distance_all_pairs()
        return sum([D[v][w] for v in V for w in V if v != w])
add_to_lists(transmission, efficient_invariants, all_invariants)

def harmonic_index(g):
    sum = 0
    for (u,v) in g.edges(labels = false):
        sum += (2 / (g.degree(u) + g.degree(v)))
    return sum
add_to_lists(harmonic_index, efficient_invariants, all_invariants)

def bavelas_index(g):
    """
    returns sum over all edges (v,w) of (distance from v to all other vertices)/(distance from w to all other vertices)
    computes each edge twice (once with v computation in numerator, once with w computation in numerator)

        sage: bavelas_index(p6)
        5086/495
        sage: bavelas_index(k4)
        12
    """
    D = g.distance_all_pairs()

    def s_aux(v):
        """
        computes sum of distances from v to all other vertices
        """
        sum = 0
        for w in g.vertices():
            sum += D[v][w]
        return sum

    sum_final = 0

    for edge in g.edges(labels=false):
        v = edge[0]
        w = edge[1]
        sum_final += (s_aux(w) / s_aux(v)) + (s_aux(v) / s_aux(w))

    return sum_final
add_to_lists(bavelas_index, efficient_invariants, all_invariants)

#a solution of the invariant interpolation problem for upper bound of chromatic number for c8chords
#all upper bounds in theory have value at least 3 for c8chords
#returns 2 for bipartite graphs, order for non-bipartite
def bipartite_chromatic(g):
    if g.is_bipartite():
        return 2
    else:
        return g.order()
add_to_lists(bipartite_chromatic, efficient_invariants, all_invariants)

def beauchamp_index(g):
    """
    Defined on page 597 of Sabidussi, Gert. "The centrality index of a graph." Psychometrika 31.4 (1966): 581-603.

    sage: beauchamp_index(c4)
    1
    sage: beauchamp_index(p5)
    137/210
    sage: beauchamp_index(graphs.PetersenGraph())
    2/3
    """

    D = g.distance_all_pairs()

    def s_aux(v): #computes sum of distances from v to all other vertices
        sum = 0
        for w in g.vertices():
            sum += D[v][w]
        return sum

    sum_final = 0

    for v in g.vertices():
        sum_final += 1/s_aux(v)
    return sum_final

add_to_lists(beauchamp_index, efficient_invariants, all_invariants)

def subcubic_tr(g):
    """
    Returns the maximum number of vertex disjoint triangles of the graph

    Harant, Jochen, et al. "The independence number in graphs of maximum degree three." Discrete Mathematics 308.23 (2008): 5829-5833.
    """
    return len(form_triangles_graph(g).connected_components())
add_to_lists(subcubic_tr, efficient_invariants, all_invariants)

def edge_clustering_centrality(g, edge = None):
    """
    Returns edge clustering centrality for all edges in a list, or a single centrality for the given edge
    Utility to be used with min, avg, max invariants
    INPUT: g - a graph
           edge - (default: None) An edge in g. If given, will compute centrality for given edge, otherwise all edges. See Graph.has_Edge for acceptable input.
    From:
    An Application of Edge Clustering Centrality to Brain Connectivity by Joy Lind, Frank Garcea, Bradford Mahon, Roger Vargas, Darren A. Narayan

    TESTS:
        sage: edge_clustering_centrality(graphs.CompleteGraph(5))
        [5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
        sage: edge_clustering_centrality(graphs.CompleteBipartiteGraph(3,4))
        [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
        sage: edge_clustering_centrality(graphs.PetersenGraph())
        [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
        sage: edge_clustering_centrality(graphs.BullGraph())
        [3, 3, 3, 2, 2]
    """
    if edge is None:
        edge_clusering_centralities = []
        for e in g.edges(labels = False):
            edge_clusering_centralities.append(len(set(g.neighbors(e[0])) & set(g.neighbors(e[1]))) + 2) # +2 for the two vertices in e
        return edge_clusering_centralities
    else:
        return len(set(g.neighbors(edge[0])) & set(g.neighbors(edge[1]))) + 2 # +2 for the two vertices in e

def max_edge_clustering_centrality(g):
    """
        sage: max_edge_clustering_centrality(p3)
        2
        sage: max_edge_clustering_centrality(paw)
        3
    """
    return max(edge_clustering_centrality(g))
add_to_lists(max_edge_clustering_centrality, efficient_invariants, all_invariants)

def min_edge_clustering_centrality(g):
    """
        sage: min_edge_clustering_centrality(p3)
        2
        sage: min_edge_clustering_centrality(paw)
        2
    """
    return min(edge_clustering_centrality(g))
add_to_lists(min_edge_clustering_centrality, efficient_invariants, all_invariants)

def mean_edge_clustering_centrality(g):
    """
        sage: mean_edge_clustering_centrality(p3)
        2
        sage: mean_edge_clustering_centrality(paw)
        11/4
    """
    centralities = edge_clustering_centrality(g)
    return sum(centralities) / len(centralities)
add_to_lists(mean_edge_clustering_centrality, efficient_invariants, all_invariants)

def local_density(g, vertex = None):
    """
    Returns local density for all vertices as a list, or a single local density for the given vertex
    INPUT: g - a graph
           vertex - (default: None) A vertex in g. If given, it will compute local density for just that vertex, otherwise for all of them

    Pavlopoulos, Georgios A., et al. "Using graph theory to analyze biological networks." BioData mining 4.1 (2011): 10.
    """
    if vertex == None:
        densities = []
        for v in g.vertices():
            densities.append(g.subgraph(g[v] + [v]).density())
        return densities
    return g.subgraph(g[vertex] + [vertex]).density()

def min_local_density(g):
    """
        sage: min_local_density(p3)
        2/3
        sage: min_local_density(paw)
        2/3
    """
    return min(local_density(g))
add_to_lists(min_local_density, efficient_invariants, all_invariants)

def max_local_density(g):
    """
        sage: max_local_density(p3)
        1
        sage: max_local_density(paw)
        1
    """
    return max(local_density(g))
add_to_lists(max_local_density, efficient_invariants, all_invariants)

def mean_local_density(g):
    """
        sage: mean_local_density(p3)
        8/9
        sage: mean_local_density(paw)
        11/12
    """
    densities = local_density(g)
    return sum(densities) / len(densities)
add_to_lists(mean_local_density, efficient_invariants, all_invariants)

def card_simple_blocks(g):
    """
    returns the number of blocks with order 2

        sage: card_simple_blocks(k10)
        0
        sage: card_simple_blocks(paw)
        1
        sage: card_simple_blocks(kite_with_tail)
        1
    """
    blocks = g.blocks_and_cut_vertices()[0]
    count = 0
    for block in blocks:
        if len(block) == 2:
            count += 1
    return count
add_to_lists(card_simple_blocks, efficient_invariants, all_invariants)

# Block of more than 2 vertices
def card_complex_blocks(g):
    """
    returns the number of blocks with order 2

        sage: card_complex_blocks(k10)
        1
        sage: card_complex_blocks(paw)
        1
        sage: card_complex_blocks(kite_with_tail)
        1
    """
    blocks = g.blocks_and_cut_vertices()[0]
    count = 0
    for block in blocks:
        if len(block) > 2:
            count += 1
    return count
add_to_lists(card_complex_blocks, efficient_invariants, all_invariants)

# Block is a clique and more than 2 vertices
def card_complex_cliques(g):
    """
    returns the number of blocks with order 2

        sage: card_complex_cliques(k10)
        1
        sage: card_complex_cliques(paw)
        1
        sage: card_complex_cliques(kite_with_tail)
        0
    """
    blocks = g.blocks_and_cut_vertices()[0]
    count = 0
    for block in blocks:
        h = g.subgraph(block)
        if h.is_clique() and h.order() > 2:
            count += 1
    return count
add_to_lists(card_complex_cliques, efficient_invariants, all_invariants)

def max_minus_min_degrees(g):
    return max_degree(g) - min_degree(g)
add_to_lists(max_minus_min_degrees, efficient_invariants, all_invariants)

def randic_irregularity(g):
    return order(g)/2 - randic(g)
add_to_lists(randic_irregularity, efficient_invariants, all_invariants)

def degree_variance(g):
    avg_degree = g.average_degree()
    return 1/order(g) * sum([d**2 - avg_degree for d in [g.degree(v) for v in g.vertices()]])
add_to_lists(degree_variance, efficient_invariants, all_invariants)

def sum_edges_degree_difference(g):
    return sum([abs(g.degree(e[0]) - g.degree(e[1])) for e in g.edges()])
add_to_lists(sum_edges_degree_difference, efficient_invariants, all_invariants)

def one_over_size_sedd(g):
    return 1/g.size() * sum_edges_degree_difference(g)
add_to_lists(one_over_size_sedd, efficient_invariants, all_invariants)

def largest_eigenvalue_minus_avg_degree(g):
    return max_eigenvalue(g) - g.average_degree()
add_to_lists(largest_eigenvalue_minus_avg_degree, efficient_invariants, all_invariants)

def min_betweenness_centrality(g):
    centralities = g.centrality_betweenness(exact=True)
    return centralities[min(centralities)]
add_to_lists(min_betweenness_centrality, efficient_invariants, all_invariants)

def max_betweenness_centrality(g):
    centralities = g.centrality_betweenness(exact=True)
    return centralities[max(centralities)]
add_to_lists(max_betweenness_centrality, efficient_invariants, all_invariants)

def mean_betweenness_centrality(g):
    centralities = g.centrality_betweenness(exact=True)
    return sum([centralities[vertex] for vertex in g.vertices()]) / g.order()
add_to_lists(mean_betweenness_centrality, efficient_invariants, all_invariants)

def min_centrality_closeness(g):
    centralities = g.centrality_closeness()
    return centralities[min(centralities)]
add_to_lists(min_centrality_closeness, efficient_invariants, all_invariants)

def max_centrality_closeness(g):
    centralities = g.centrality_closeness()
    return centralities[max(centralities)]
add_to_lists(max_centrality_closeness, efficient_invariants, all_invariants)

def mean_centrality_closeness(g):
    centralities = g.centrality_closeness()
    return sum([centralities[vertex] for vertex in g.vertices()]) / g.order()
add_to_lists(mean_centrality_closeness, efficient_invariants, all_invariants)

def min_centrality_degree(g):
    centralities = g.centrality_degree()
    return centralities[min(centralities)]
add_to_lists(min_centrality_degree, efficient_invariants, all_invariants)

def max_centrality_degree(g):
    centralities = g.centrality_degree()
    return centralities[max(centralities)]
add_to_lists(max_centrality_degree, efficient_invariants, all_invariants)

def mean_centrality_degree(g):
    centralities = g.centrality_degree()
    return sum([centralities[vertex] for vertex in g.vertices()]) / g.order()
add_to_lists(mean_centrality_degree, efficient_invariants, all_invariants)

def homo_lumo_gap(g):
    order = g.order()
    if order % 2 != 0:
        return 0
    eigenvalues = g.spectrum()
    # Minus 1 accounts for the 0 indexing of a list
    return eigenvalues[floor((order+1)/2) - 1] - eigenvalues[ceil((order+1)/2) - 1]
add_to_lists(homo_lumo_gap, efficient_invariants, all_invariants)

def homo_lumo_index(g):
    order = g.order()
    eigenvalues = g.adjacency_matrix(sparse=False).change_ring(RDF).eigenvalues(algorithm="symmetric")
    if order%2 == 0:
        # Minus 1 accounts for the 0 indexing of a list
        return max(abs(eigenvalues[floor((order+1)/2) - 1]), abs(eigenvalues[ceil((order+1)/2) - 1]))
    else:
        return eigenvalues[floor(order/2)]
add_to_lists(homo_lumo_index, efficient_invariants, all_invariants)

def neighborhood_union_nonadjacent(g):
    # Define that for copmlete graphs (i.e. nothing to minimize over later), return n, which is trivial upper bound.
    all_dist = g.distance_all_pairs()
    nonadj = [(v,w) for v in g for w in g if all_dist[v][w] > 1]
    if not nonadj:
        return g.order()
    else:
        return min( len(union(g.neighbors(v), g.neighbors(w))) for (v,w) in nonadj)
add_to_lists(neighborhood_union_nonadjacent, efficient_invariants, all_invariants)

def neighborhood_union_dist2(g):
    # Define that for graphs with no dist 2 (i.e. nothing to minimize over later), return n, which is trivial upper bound.
    all_dist = g.distance_all_pairs()
    dist2 = [(v,w) for v in g for w in g if all_dist[v][w] == 2]
    if not dist2:
        return g.order()
    else:
        return min( len(union(g.neighbors(v), g.neighbors(w))) for (v, w) in dist2)
add_to_lists(neighborhood_union_dist2, efficient_invariants, all_invariants)

def simplical_vertices(g):
    """
    The number of simplical vertices in g.
    v is simplical if the induced nieghborhood is a clique.
    """
    return sum( is_simplical_vertex(g,v) for v in g.vertices() )
add_to_lists(simplical_vertices, efficient_invariants, all_invariants)

def first_zagreb_index(g):
    """
    The sume of squares of the degrees
    """
    return sum(g.degree(v)**2 for v in g.vertices())
add_to_lists(first_zagreb_index, efficient_invariants, all_invariants)

def degree_two_vertices(g):
    """
    The number of degree 2 vertices
    """
    return len([deg for deg in g.degree() if deg == 2])
add_to_lists(degree_two_vertices, efficient_invariants, all_invariants)

def degree_order_minus_one_vertices(g):
    """
    The number of vertices with degree = n-1
    """
    return len([deg for deg in g.degree() if deg == g.order() - 1])
add_to_lists(degree_order_minus_one_vertices, efficient_invariants, all_invariants)

def maximum_degree_vertices(g):
    """
    The number of vertices with degree equal to the maximum degree
    """
    return len([deg for deg in g.degree() if deg == max_degree(g)])
add_to_lists(maximum_degree_vertices, efficient_invariants, all_invariants)

def minimum_degree_vertices(g):
    """
    The number of vertices with degree equal to the minimum degree
    """
    return len([deg for deg in g.degree() if deg == min_degree(g)])
add_to_lists(minimum_degree_vertices, efficient_invariants, all_invariants)

def second_zagreb_index(g):
    """
    The sum over all edges (v,w) of the product of degrees(v)*degree(w)
    """
    return sum(g.degree(v)*g.degree(w) for (v,w) in g.edge_iterator(labels=False))
add_to_lists(second_zagreb_index, efficient_invariants, all_invariants)

# Damir Vukicevic, Qiuli Li, Jelena Sedlar, and Tomislav Doslic, Lanzhou Index. MATCH Commun. Math. Comput. Chem., 80: 863-876, 2018.
def lanzhou_index(g):
    """
    The sum over all vertices v of products of the co-degree of v (deg(v) in the complement of g) times the square of deg(v).

    sage: lanzhou_index(graphs.CompleteGraph(10))
    0
    sage: lanzhou_index(graphs.CompleteBipartiteGraph(5,5))
    1000
    """
    n = g.order()
    return sum( ((n-1) - g.degree(v)) * (g.degree(v) ** 2) for v in g.vertices() )
add_to_lists(lanzhou_index, efficient_invariants, all_invariants)

def friendship_number(g):
    """
    The friendship number of a graph is the number of pairs of vertices that have a unique common neighbour.

    sage: friendship_number(graphs.FriendshipGraph(3))
    21
    sage: friendship_number(graphs.CompleteGraph(7))
    0
    """
    from itertools import combinations
    return sum((1 if len(common_neighbors(g, u, v))==1 else 0) for (u,v) in combinations(g.vertices(), 2))
add_to_lists(friendship_number, efficient_invariants, all_invariants)

#####
# INTRACTABLE INVATIANTS
#####
def domination_number(g):
    """
    Returns the domination number of the graph g, i.e., the size of a maximum
    dominating set.

    A complete graph is dominated by any of its vertices::

        sage: domination_number(graphs.CompleteGraph(5))
        1

    A star graph is dominated by its central vertex::

        sage: domination_number(graphs.StarGraph(5))
        1

    The domination number of a cycle of length n is the ceil of n/3.

        sage: domination_number(graphs.CycleGraph(5))
        2
    """
    return g.dominating_set(value_only=True)
add_to_lists(domination_number, intractable_invariants, all_invariants)

def independence_number(g):
    return g.independent_set(value_only=True)
add_to_lists(independence_number, intractable_invariants, all_invariants)

def clique_covering_number(g):
    # Finding the chromatic number of the complement of a fullerene
    # is extremely slow, even when using MILP as the algorithm.
    # Therefore we check to see if the graph is triangle-free.
    # If it is, then the clique covering number is equal to the
    # number of vertices minus the size of a maximum matching.
    if g.is_triangle_free():
        return g.order() - matching_number(g)
    gc = g.complement()
    return gc.chromatic_number(algorithm="MILP")
add_to_lists(clique_covering_number, intractable_invariants, all_invariants)

def n_over_alpha(g):
    n = g.order() + 0.0
    return n/independence_number(g)
add_to_lists(n_over_alpha, intractable_invariants, all_invariants)

def independent_dominating_set_number(g):
    return g.dominating_set(value_only=True, independent=True)
add_to_lists(independent_dominating_set_number, intractable_invariants, all_invariants)

# Clearly intractable
# alpha / order
def independence_ratio(g):
    return independence_number(g)/(g.order()+0.0)
add_to_lists(independence_ratio, intractable_invariants, all_invariants)

def min_degree_of_max_ind_set(g):
    """
    Returns the minimum degree of any vertex that is a part of any maximum indepdendent set

    sage: min_degree_of_max_ind_set(c4)
    2
    sage: min_degree_of_max_ind_set(graphs.PetersenGraph())
    3
    """

    low_degree = g.order()
    list_of_vertices = []

    UnionSet = Set({})
    IndSets = find_all_max_ind_sets(g)

    for s in IndSets:
        UnionSet = UnionSet.union(Set(s))

    list_of_vertices = list(UnionSet)

    for v in list_of_vertices:
        if g.degree(v) < low_degree:
            low_degree = g.degree(v)

    return low_degree
add_to_lists(min_degree_of_max_ind_set, intractable_invariants, all_invariants)

def bipartite_number(g):
    """
    Defined as the largest number of vertices that induces a bipartite subgraph

    sage: bipartite_number(graphs.PetersenGraph())
    7
    sage: bipartite_number(c4)
    4
    sage: bipartite_number(graphs.CompleteGraph(3))
    2
    """
    if g.is_bipartite():
        return g.order()
    return len(max_bipartite_set(g, [], g.vertices()))
add_to_lists(bipartite_number, intractable_invariants, all_invariants)

# Needs Enhancement
def edge_bipartite_number(g):
    """
    Defined as the largest number of edges in an induced bipartite subgraph

        sage: edge_bipartite_number(graphs.CompleteGraph(5))
        1
        sage: edge_bipartite_number(graphs.CompleteBipartiteGraph(5, 5))
        25
        sage: edge_bipartite_number(graphs.ButterflyGraph())
        2
    """
    return g.subgraph(max_bipartite_set(g, [], g.vertices())).size()
add_to_lists(edge_bipartite_number, intractable_invariants, all_invariants)

def cheeger_constant(g):
    """
    Defined at https://en.wikipedia.org/wiki/Cheeger_constant_(graph_theory)

    sage: cheeger_constant(graphs.PathGraph(2))
    1
    sage: cheeger_constant(graphs.CompleteGraph(5))
    3
    sage: cheeger_constant(paw)
    1
    """
    n = g.order()
    upper = floor(n/2)

    v = g.vertices()
    SetV = Set(v)

    temp = g.order()
    best = n

    for i in range(1, upper+1):
        for s in SetV.subsets(i):
            count = 0
            for u in s:
                for w in SetV.difference(s):
                    for e in g.edges(labels=false):
                        if Set([u,w]) == Set(e):
                            count += 1
            temp = count/i
            if temp < best:
                best = temp
    return best
add_to_lists(cheeger_constant, intractable_invariants, all_invariants)

def tr(g):
    """
    Returns the maximum number of vertex disjoint triangles of the graph

    Harant, Jochen, et al. "The independence number in graphs of maximum degree three." Discrete Mathematics 308.23 (2008): 5829-5833.
    """
    if is_subcubic(g):
        return subcubic_tr(g)
    return independence_number(form_triangles_graph(g))
add_to_lists(tr, intractable_invariants, all_invariants)

def total_domination_number(g):
    return g.dominating_set(total=True, value_only=True)
add_to_lists(total_domination_number, intractable_invariants, all_invariants)

# A graph G is t-tough for real t if for every integer k>1, G cannot be split into k connected components by removal of fewer than tk vertices
# Returns Infinity if g is complete
# Inefficient to calculate
def toughness(g):
    """
    Tests:
        sage: toughness(graphs.PathGraph(3))
        0.5
        sage: toughness(graphs.CompleteGraph(5))
        +Infinity
        sage: toughness(graphs.PetersenGraph())
        1.3333333333333333
    """
    order = g.order()
    t = Infinity
    for x in Subsets(g.vertices()):
        if x and len(x) != order: # Proper, non-empty subset
            H = copy(g)
            H.delete_vertices(x)
            k = H.connected_components_number()
            if k > 1:
                t = min(float(len(x)) / k, t)
    return t
add_to_lists(toughness, intractable_invariants, all_invariants)

# Sigma_k = min( sum( degrees(v_i) : every k-element independent set v_1,..,v_k ) )
# Inefficient to calculate
def sigma_k(g,k):
    """
    Tests:
        sage: sigma_k(graphs.CompleteGraph(5), 1)
        4
        sage: sigma_k(graphs.PathGraph(4), 2)
        2
    """
    sigma = Infinity
    for S in Subsets(g.vertices(), k):
        if g.is_independent_set(S):
            sigma = min(sigma, sum([g.degree(x) for x in S]) )
    return sigma

def sigma_2(g):
    return sigma_k(g,2)
def sigma_3(g):
    return sigma_k(g,3)
add_to_lists(sigma_2, intractable_invariants, all_invariants)
add_to_lists(sigma_3, intractable_invariants, all_invariants)

def homogenous_number(g):
    """
    Equals the larger of the independence number or the clique number
    """
    return max(independence_number(g), g.clique_number())
add_to_lists(homogenous_number, intractable_invariants, all_invariants)

def edge_domination_number(g):
    """
    The minimum size of a set of edges S such that every edge not in S is incident to an edge in S
    """
    return domination_number(g.line_graph())
add_to_lists(edge_domination_number, intractable_invariants, all_invariants)

def circumference(g):
    """
    Returns length of longest cycle in g

    If acyclic, throws a ValueError. Some define this to be 0; we leave it up to the user.
    """
    lengths = cycle_lengths(g)
    if not lengths:
        raise ValueError("Graph is acyclic. Circumference undefined")
    else:
        return max(lengths)
add_to_lists(circumference, intractable_invariants, all_invariants)

def tree_number(g):
    """
    The order of a maximum-size induced subgraph that's a tree in g

    See Erdös, Paul, Michael Saks, and Vera T. Sós. "Maximum induced trees in graphs." Journal of Combinatorial Theory, Series B 41.1 (1986): 61-79.
    """
    return max_induced_tree(g).order()
add_to_lists(tree_number, intractable_invariants, all_invariants)

def forest_number(g):
    """
    The order of a maximum-size induced subgraph of g that's a forest
    """
    return max_induced_forest(g).order()
add_to_lists(forest_number, intractable_invariants, all_invariants)

def minimum_maximal_matching_size(g):
    """
    The minimum number of edges k s.t. there exists a matching of size k which is not extendable
    """
    if(g.size() == 0):
        return 0

    matchings_old = []
    matchings = [[e] for e in g.edges()]
    while True:
        matchings_old = matchings
        matchings = []
        for matching in matchings_old:
            extendable = False
            for e in (edge for edge in g.edges() if edge not in matching):
                possible_matching = matching + [e]
                if is_matching(possible_matching):
                    matchings.append(possible_matching)
                    extendable = True
            if not extendable:
                return len(matching)
add_to_lists(minimum_maximal_matching_size, intractable_invariants, all_invariants)

def hamiltonian_index(g):
    """
    Returns i, where L^i(g) = L(L(L(...L(g)))) is the first line graph iterate of g such that L^i(g) is Hamiltonian

    If g is Hamiltonian, then h(G) = 0.
    Raises ValueError if g is disconnected or if g is a simple path, since h(g) is undefined for either.

    Defined in: Chartrand, Gary. "On hamiltonian line-graphs." Transactions of the American Mathematical Society 134.3 (1968): 559-566.

    sage: hamiltonian_index(graphs.CycleGraph(5))
    0
    sage: hamiltonian_index(graphs.PetersenGraph())
    1
    sage: hamiltonian_index(graphs.TadpoleGraph(4, 3))
    3
    """
    if not g.is_connected():
        raise ValueError("The input graph g is not connected. The Hamiltonian index is only defined for connected graphs.")
    if g.is_isomorphic(graphs.PathGraph(g.order())):
        raise ValueError("The input graph g is a simple path. The Hamiltonian index is not defined for path graphs.")
    line_graph_i = g
    for index in xrange(0, (g.order() - 3) + 1): # [Chartrand, 68] proved index is upper bounded by n - 3.
        if line_graph_i.is_hamiltonian():
            return index
        line_graph_i = line_graph_i.line_graph()
add_to_lists(hamiltonian_index, intractable_invariants, all_invariants)


#FAST ENOUGH (tested for graphs on 140921): lovasz_theta, clique_covering_number, all efficiently_computable
#SLOW but FIXED for SpecialGraphs

print("loaded invariants")

#############################################################################
# End of invariants section                                                 #
#############################################################################
# GRAPH PROPERTIES

def has_star_center(g):
    """
    Evalutes whether graph ``g`` has a vertex adjacent to all others.

    EXAMPLES:

        sage: has_star_center(flower_with_3_petals)
        True

        sage: has_star_center(c4)
        False

    Edge cases ::

        sage: has_star_center(Graph(1))
        True

        sage: has_star_center(Graph(0))
        False
    """
    return (g.order() - 1) in g.degree()

def is_complement_of_chordal(g):
    """
    Evaluates whether graph ``g`` is a complement of a chordal graph.

    A chordal graph is one in which all cycles of four or more vertices have a
    chord, which is an edge that is not part of the cycle but connects two
    vertices of the cycle.

    EXAMPLES:

        sage: is_complement_of_chordal(p4)
        True

        sage: is_complement_of_chordal(Graph(4))
        True

        sage: is_complement_of_chordal(p5)
        False

    Any graph without a 4-or-more cycle is vacuously chordal. ::

        sage: is_complement_of_chordal(graphs.CompleteGraph(4))
        True

        sage: is_complement_of_chordal(Graph(3))
        True

        sage: is_complement_of_chordal(Graph(0))
        True
    """
    return g.complement().is_chordal()

def pairs_have_unique_common_neighbor(g):
    """
    Evalaute if each pair of vertices in ``g`` has exactly one common neighbor.

    Also known as the friendship property.
    By the Friendship Theorem, the only connected graphs with the friendship
    property are flowers.

    EXAMPLES:

        sage: pairs_have_unique_common_neighbor(flower(5))
        True

        sage: pairs_have_unique_common_neighbor(k3)
        True

        sage: pairs_have_unique_common_neighbor(k4)
        False

        sage: pairs_have_unique_common_neighbor(graphs.CompleteGraph(2))
        False

    Vacuous cases ::

        sage: pairs_have_unique_common_neighbor(Graph(1))
        True

        sage: pairs_have_unique_common_neighbor(Graph(0))
        True
    """
    from itertools import combinations
    for (u,v) in combinations(g.vertices(), 2):
        if len(common_neighbors(g, u, v)) != 1:
            return False
    return True

def is_distance_transitive(g):
    """
    Evaluates if graph ``g`` is distance transitive.

    A graph is distance transitive if all a,b,u,v satisfy that
    dist(a,b) = dist(u,v) implies there's an automorphism with a->u and b->v.

    EXAMPLES:

        sage: is_distance_transitive(graphs.CompleteGraph(4))
        True

        sage: is_distance_transitive(graphs.PetersenGraph())
        True

        sage: is_distance_transitive(Graph(3))
        True

        sage: is_distance_transitive(graphs.ShrikhandeGraph())
        False

    This method accepts disconnected graphs. ::

        sage: is_distance_transitive(graphs.CompleteGraph(3).disjoint_union(graphs.CompleteGraph(3)))
        True

        sage: is_distance_transitive(graphs.CompleteGraph(2).disjoint_union(Graph(2)))
        False

    Vacuous cases ::

        sage: is_distance_transitive(Graph(0))
        True

        sage: is_distance_transitive(Graph(1))
        True

        sage: is_distance_transitive(Graph(2))
        True

    ... WARNING ::

        This method calls, via the automorphism group, the Gap package. This
        package behaves badly with most threading or multiprocessing tools.
    """
    from itertools import combinations
    dist_dict = g.distance_all_pairs()
    auto_group = g.automorphism_group()

    for d in g.distances_distribution():
        sameDistPairs = []
        for (u,v) in combinations(g.vertices(), 2):
            # By default, no entry if disconnected. We substitute +Infinity.
            if dist_dict[u].get(v, +Infinity) == d:
                sameDistPairs.append(Set([u,v]))
        if len(sameDistPairs) >= 2:
            if len(sameDistPairs) != len(auto_group.orbit(sameDistPairs[0], action = "OnSets")):
                return False
    return True

def is_dirac(g):
    """
    Evaluates if graph ``g`` has order at least 3 and min. degree at least n/2.

    See Dirac's Theorem: If graph is_dirac, then it is hamiltonian.

    EXAMPLES:

        sage: is_dirac(graphs.CompleteGraph(6))
        True

        sage: is_dirac(graphs.CompleteGraph(3))
        True

        sage: is_dirac(graphs.CompleteGraph(2))
        False

        sage: is_dirac(graphs.CycleGraph(5))
        False
    """
    n = g.order()
    return n > 2 and min(g.degree()) >= n/2

def is_ore(g):
    """
    Evaluate if deg(v)+deg(w)>=n for all non-adjacent pairs v,w in graph ``g``.

    See Ore's Theorem: If graph is_ore, then it is hamiltonian.

    EXAMPLES:

        sage: is_ore(graphs.CompleteGraph(5))
        True

        sage: is_ore(graphs.CompleteGraph(2))
        True

        sage: is_ore(dart)
        False

        sage: is_ore(Graph(2))
        False

        sage: is_ore(graphs.CompleteGraph(2).disjoint_union(Graph(1)))
        False

    Vacous cases ::

        sage: is_ore(Graph(0))
        True

        sage: is_ore(Graph(1))
        True
    """
    A = g.adjacency_matrix()
    n = g.order()
    D = g.degree()
    for i in xrange(n):
        for j in xrange(i):
            if A[i][j]==0:
                if D[i] + D[j] < n:
                    return False
    return True

def is_haggkvist_nicoghossian(g):
    """
    Evaluates if g is 2-connected and min degree >= (n + vertex_connectivity)/3.

    INPUT:

    - ``g`` -- graph

    EXAMPLES:

        sage: is_haggkvist_nicoghossian(graphs.CompleteGraph(3))
        True

        sage: is_haggkvist_nicoghossian(graphs.CompleteGraph(5))
        True

        sage: is_haggkvist_nicoghossian(graphs.CycleGraph(5))
        False

        sage: is_haggkvist_nicoghossian(graphs.CompleteBipartiteGraph(4,3)
        False

        sage: is_haggkvist_nicoghossian(Graph(1))
        False

        sage: is_haggkvist_nicoghossian(graphs.CompleteGraph(2))
        False

    REFERENCES:

    Theorem: If a graph ``is_haggkvist_nicoghossian``, then it is Hamiltonian.

    .. [HN1981]     \R. Häggkvist and G. Nicoghossian, "A remark on Hamiltonian
                    cycles". Journal of Combinatorial Theory, Series B, 30(1):
                    118--120, 1981.
    """
    k = g.vertex_connectivity()
    return k >= 2 and min(g.degree()) >= (1.0/3) * (g.order() + k)

def is_genghua_fan(g):
    """
    Evaluates if graph ``g`` satisfies a condition for Hamiltonicity by G. Fan.

    OUTPUT:

    Returns ``True`` if ``g`` is 2-connected and satisfies that
    `dist(u,v)=2` implies `\max(deg(u), deg(v)) \geq n/2` for all
    vertices `u,v`.
    Returns ``False`` otherwise.

    EXAMPLES:

        sage: is_genghua_fan(graphs.DiamondGraph())
        True

        sage: is_genghua_fan(graphs.CycleGraph(4))
        False

        sage: is_genghua_fan(graphs.ButterflyGraph())
        False

        sage: is_genghua_fan(Graph(1))
        False

    REFERENCES:

    Theorem: If a graph ``is_genghua_fan``, then it is Hamiltonian.

    .. [Fan1984]    Geng-Hua Fan, "New sufficient conditions for cycles in
                    graphs". Journal of Combinatorial Theory, Series B, 37(3):
                    221--227, 1984.
    """
    if not is_two_connected(g):
        return False
    D = g.degree()
    Dist = g.distance_all_pairs()
    V = g.vertices()
    n = g.order()
    for i in xrange(n):
        for j in xrange(i):
            if Dist[V[i]][V[j]] == 2 and max(D[i], D[j]) < n / 2.0:
                return False
    return True

def is_planar_transitive(g):
    """
    Evaluates whether graph ``g`` is planar and is vertex-transitive.

    EXAMPLES:

        sage: is_planar_transitive(graphs.HexahedralGraph())
        True

        sage: is_planar_transitive(graphs.CompleteGraph(2))
        True

        sage: is_planar_transitive(graphs.FranklinGraph())
        False

        sage: is_planar_transitive(graphs.BullGraph())
        False

    Vacuous cases ::

        sage: is_planar_transitive(Graph(1))
        True

    Sage defines `Graph(0).is_vertex_transitive() == False``. ::

        sage: is_planar_transitive(Graph(0))
        False
    """
    return g.is_planar() and g.is_vertex_transitive()

def is_generalized_dirac(g):
    """
    Test if ``graph`` g meets condition in a generalization of Dirac's Theorem.

    OUTPUT:

    Returns ``True`` if g is 2-connected and for all non-adjacent u,v,
    the cardinality of the union of neighborhood(u) and neighborhood(v)
    is `>= (2n-1)/3`.

    EXAMPLES:

        sage: is_generalized_dirac(graphs.HouseGraph())
        True

        sage: is_generalized_dirac(graphs.PathGraph(5))
        False

        sage: is_generalized_dirac(graphs.DiamondGraph())
        False

        sage: is_generalized_dirac(Graph(1))
        False

    REFERENCES:

    Theorem: If graph g is_generalized_dirac, then it is Hamiltonian.

    .. [FGJS1989]   \R.J. Faudree, Ronald Gould, Michael Jacobson, and
                    R.H. Schelp, "Neighborhood unions and hamiltonian
                    properties in graphs". Journal of Combinatorial
                    Theory, Series B, 47(1): 1--9, 1989.
    """
    from itertools import combinations

    if not is_two_connected(g):
        return False
    for (u,v) in combinations(g.vertices(), 2):
        if not g.has_edge(u,v):
            if len(neighbors_set(u, v)) < (2.0 * g.order() - 1) / 3:
                return False
    return True

def is_van_den_heuvel(g):
    """
    Evaluates if g meets an eigenvalue condition related to Hamiltonicity.

    INPUT:

    - ``g`` -- graph

    OUTPUT:

    Let ``g`` be of order `n`.
    Let `A_H` denote the adjacency matrix of a graph `H`, and `D_H` denote
    the matrix with the degrees of the vertices of `H` on the diagonal.
    Define `Q_H = D_H + A_H` and `L_H = D_H - A_H` (i.e. the Laplacian).
    Finally, let `C` be the cycle graph on `n` vertices.

    Returns ``True`` if the `i`-th eigenvalue of `L_C` is at most the `i`-th
    eigenvalue of `L_g` and the `i`-th eigenvalue of `Q_C` is at most the
    `i`-th eigenvalue of `Q_g for all `i`.

    EXAMPLES:

        sage: is_van_den_heuvel(graphs.CycleGraph(5))
        True

        sage: is_van_den_heuvel(graphs.PetersenGraph())
        False

    REFERENCES:

    Theorem: If a graph is Hamiltonian, then it ``is_van_den_heuvel``.

    .. [Heu1995]    \J.van den Heuvel, "Hamilton cycles and eigenvalues of
                    graphs". Linear Algebra and its Applications, 226--228:
                    723--730, 1995.

    TESTS::

        sage: is_van_den_heuvel(Graph(0))
        False

        sage: is_van_den_heuvel(Graph(1))
        True
    """
    cycle_n = graphs.CycleGraph(g.order())

    cycle_laplac_eigen = sorted(cycle_n.laplacian_matrix().eigenvalues())
    g_laplac_eigen = sorted(g.laplacian_matrix().eigenvalues())
    for cycle_lambda_i, g_lambda_i in zip(cycle_laplac_eigen, g_laplac_eigen):
        if cycle_lambda_i > g_lambda_i:
            return False

    def Q(g):
        A = g.adjacency_matrix(sparse=False)
        D = matrix(g.order(), sparse=False)
        row_sums = [sum(r) for r in A.rows()]
        for i in xrange(A.nrows()):
            D[i,i] = row_sums[i]
        return D + A
    cycle_q_matrix = sorted(Q(cycle_n).eigenvalues())
    g_q_matrix = sorted(Q(g).eigenvalues())
    for cycle_q_lambda_i, g_q_lambda_i in zip(cycle_q_matrix, g_q_matrix):
        if cycle_q_lambda_i > g_q_lambda_i:
            return False

    return True

def is_two_connected(g):
    """
    Evaluates whether graph ``g`` is 2-connected.

    A 2-connected graph is a connected graph on at least 3 vertices such that
    the removal of any single vertex still gives a connected graph.
    Follows convention that complete graph `K_n` is `n-1`-connected.

    Almost equivalent to ``Graph.is_biconnected()``. We prefer our name. AND,
    while that method defines that ``graphs.CompleteGraph(2)`` is biconnected,
    we follow the convention that `K_n` is `n-1`-connected, so `K_2` is
    only 1-connected.

    EXAMPLES:

        sage: is_two_connected(graphs.CycleGraph(5))
        True

        sage: is_two_connected(graphs.CompleteGraph(3))
        True

        sage: is_two_connected(graphs.PathGraph(5))
        False

        sage: is_two_connected(graphs.CompleteGraph(2))
        False

        sage: is_two_connected(Graph(3))
        False

    Edge cases ::

        sage: is_two_connected(Graph(0))
        False

        sage: is_two_connected(Graph(1))
        False
    """
    if g.is_isomorphic(graphs.CompleteGraph(2)):
        return False
    return g.is_biconnected()

def is_three_connected(g):
    """
    Evaluates whether graph ``g`` is 3-connected.

    A 3-connected graph is a connected graph on at least 4 vertices such that
    the removal of any two vertices still gives a connected graph.
    Follows convention that complete graph `K_n` is `n-1`-connected.

    EXAMPLES:

        sage: is_three_connected(graphs.PetersenGraph())
        True

        sage: is_three_connected(graphs.CompleteGraph(4))
        True

        sage: is_three_connected(graphs.CycleGraph(5))
        False

        sage: is_three_connected(graphs.PathGraph(5))
        False

        sage: is_three_connected(graphs.CompleteGraph(3))
        False

        sage: is_three_connected(graphs.CompleteGraph(2))
        False

        sage: is_three_connected(Graph(4))
        False

    Edge cases ::

        sage: is_three_connected(Graph(0))
        False

        sage: is_three_connected(Graph(1))
        False

    .. WARNING::

        Implementation requires Sage 8.2+.
    """
    return g.vertex_connectivity(k = 3)

def is_four_connected(g):
    """
    Evaluates whether ``g`` is 4-connected.

    A 4-connected graph is a connected graph on at least 5 vertices such that
    the removal of any three vertices still gives a connected graph.
    Follows convention that complete graph `K_n` is `n-1`-connected.

    EXAMPLES:


        sage: is_four_connected(graphs.CompleteGraph(5))
        True

        sage: is_four_connected(graphs.PathGraph(5))
        False

        sage: is_four_connected(Graph(5))
        False

        sage: is_four_connected(graphs.CompleteGraph(4))
        False

    Edge cases ::

        sage: is_four_connected(Graph(0))
        False

        sage: is_four_connected(Graph(1))
        False

    .. WARNING::

        Implementation requires Sage 8.2+.
    """
    return g.vertex_connectivity(k = 4)

def is_lindquester(g):
    """
    Test if graph ``g`` meets a neighborhood union condition for Hamiltonicity.

    OUTPUT:

    Let ``g`` be of order `n`.

    Returns ``True`` if ``g`` is 2-connected and for all vertices `u,v`,
    `dist(u,v) = 2` implies that the cardinality of the union of
    neighborhood(`u`) and neighborhood(`v`) is `\geq (2n-1)/3`.
    Returns ``False`` otherwise.

    EXAMPLES:

        sage: is_lindquester(graphs.HouseGraph())
        True

        sage: is_lindquester(graphs.OctahedralGraph())
        True

        sage: is_lindquester(graphs.PathGraph(3))
        False

        sage: is_lindquester(graphs.DiamondGraph())
        False

    REFERENCES:

    Theorem: If a graph ``is_lindquester``, then it is Hamiltonian.

    .. [Lin1989]    \T.E. Lindquester, "The effects of distance and
                    neighborhood union conditions on hamiltonian properties
                    in graphs". Journal of Graph Theory, 13(3): 335-352,
                    1989.
    """
    if not is_two_connected(g):
        return False
    D = g.distance_all_pairs()
    n = g.order()
    V = g.vertices()
    for i in range(n):
        for j in range(i):
            if D[V[i]][V[j]] == 2:
                if len(neighbors_set(g,[V[i],V[j]])) < (2*n-1)/3.0:
                    return False
    return True

def is_complete(g):
    """
    Tests whether ``g`` is a complete graph.

    OUTPUT:

    Returns ``True`` if ``g`` is a complete graph; returns ``False`` otherwise.
    A complete graph is one where every vertex is connected to every others
    vertex.

    EXAMPLES:

        sage: is_complete(graphs.CompleteGraph(1))
        True

        sage: is_complete(graphs.CycleGraph(3))
        True

        sage: is_complete(graphs.CompleteGraph(6))
        True

        sage: is_complete(Graph(0))
        True

        sage: is_complete(graphs.PathGraph(5))
        False

        sage: is_complete(graphs.CycleGraph(4))
        False
    """
    n = g.order()
    e = g.size()
    if not g.has_multiple_edges():
        return e == n*(n-1)/2
    else:
        D = g.distance_all_pairs()
        for i in range(n):
            for j in range(i):
                if D[V[i]][V[j]] != 1:
                    return False
    return True

def has_c4(g):
    """
    Tests whether graph ``g`` contains Cycle_4 as an *induced* subgraph.

    EXAMPLES:

        sage: has_c4(graphs.CycleGraph(4))
        True

        sage: has_c4(graphs.HouseGraph())
        True

        sage: has_c4(graphs.CycleGraph(5))
        False

        sage: has_c4(graphs.DiamondGraph())
        False
    """
    return g.subgraph_search(c4, induced=True) is not None

def is_c4_free(g):
    """
    Tests whether graph ``g`` does not contain Cycle_4 as an *induced* subgraph.

    EXAMPLES:

        sage: is_c4_free(graphs.CycleGraph(4))
        False

        sage: is_c4_free(graphs.HouseGraph())
        False

        sage: is_c4_free(graphs.CycleGraph(5))
        True

        sage: is_c4_free(graphs.DiamondGraph())
        True
    """
    return not has_c4(g)

def has_paw(g):
    """
    Tests whether graph ``g`` contains a Paw as an *induced* subgraph.

    OUTPUT:

    Define a Paw to be a 4-vertex graph formed by a triangle and a pendant.
    Returns ``True`` if ``g`` contains a Paw as an induced subgraph.
    Returns ``False`` otherwise.

    EXAMPLES:

        sage: has_paw(paw)
        True

        sage: has_paw(graphs.BullGraph())
        True

        sage: has_paw(graphs.ClawGraph())
        False

        sage: has_paw(graphs.DiamondGraph())
        False
    """
    return g.subgraph_search(paw, induced=True) is not None

def is_paw_free(g):
    """
    Tests whether graph ``g`` does not contain a Paw as an *induced* subgraph.

    OUTPUT:

    Define a Paw to be a 4-vertex graph formed by a triangle and a pendant.
    Returns ``False`` if ``g`` contains a Paw as an induced subgraph.
    Returns ``True`` otherwise.

    EXAMPLES:

        sage: is_paw_free(paw)
        False

        sage: is_paw_free(graphs.BullGraph())
        False

        sage: is_paw_free(graphs.ClawGraph())
        True

        sage: is_paw_free(graphs.DiamondGraph())
        True
    """
    return not has_paw(g)

def has_dart(g):
    """
    Tests whether graph ``g`` contains a Dart as an *induced* subgraph.

    OUTPUT:

    Define a Dart to be a 5-vertex graph formed by ``graphs.DiamondGraph()``
    with and a pendant added to one of the degree-3 vertices.
    Returns ``True`` if ``g`` contains a Dart as an induced subgraph.
    Returns ``False`` otherwise.

    EXAMPLES:

        sage: has_dart(dart)
        True

        sage: has_dart(umbrella_4)
        True

        sage: has_dart(graphs.DiamondGraph())
        False

        sage: has_dart(bridge)
        False
    """
    return g.subgraph_search(dart, induced=True) is not None

def is_dart_free(g):
    """
    Tests whether graph ``g`` does not contain a Dart as an *induced* subgraph.

    OUTPUT:

    Define a Dart to be a 5-vertex graph formed by ``graphs.DiamondGraph()``
    with and a pendant added to one of the degree-3 vertices.
    Returns ``False`` if ``g`` contains a Dart as an induced subgraph.
    Returns ``True`` otherwise.

    EXAMPLES:

        sage: is_dart_free(dart)
        False

        sage: is_dart_free(umbrella_4)
        False

        sage: is_dart_free(graphs.DiamondGraph())
        True

        sage: is_dart_free(bridge)
        True
    """
    return not has_dart(g)

def is_p4_free(g):
    """
    Equivalent to is a cograph - https://en.wikipedia.org/wiki/Cograph
    """
    return not has_p4(g)

def has_p4(g):
    """
    Tests whether graph ``g`` contains a Path_4 as an *induced* subgraph.

    Might also be known as "is not a cograph".

    EXAMPLES:

        sage: has_p4(graphs.PathGraph(4))
        True

        sage: has_p4(graphs.CycleGraph(5))
        True

        sage: has_p4(graphs.CycleGraph(4))
        False

        sage: has_p4(graphs.CompleteGraph(5))
        False
    """
    return g.subgraph_search(p4, induced=True) is not None

def has_kite(g):
    """
    Tests whether graph ``g`` contains a Kite as an *induced* subgraph.

    A Kite is a 5-vertex graph formed by a ``graphs.DiamondGraph()`` with a
    pendant attached to one of the degree-2 vertices.

    EXAMPLES:

        sage: has_kite(kite_with_tail)
        True

        sage: has_kite(graphs.KrackhardtKiteGraph())
        True

        sage: has_kite(graphs.DiamondGraph())
        False

        sage: has_kite(bridge)
        False
    """
    return g.subgraph_search(kite_with_tail, induced=True) is not None

def is_kite_free(g):
    """
    Tests whether graph ``g`` does not contain a Kite as an *induced* subgraph.

    A Kite is a 5-vertex graph formed by a ``graphs.DiamondGraph()`` with a
    pendant attached to one of the degree-2 vertices.

    EXAMPLES:

        sage: is_kite_free(kite_with_tail)
        False

        sage: is_kite_free(graphs.KrackhardtKiteGraph())
        False

        sage: is_kite_free(graphs.DiamondGraph())
        True

        sage: is_kite_free(bridge)
        True
    """
    return not has_kite(g)

def has_claw(g):
    """
    Tests whether graph ``g`` contains a Claw as an *induced* subgraph.

    A Claw is a 4-vertex graph with one central vertex and 3 pendants.
    This is encoded as ``graphs.ClawGraph()``.

    EXAMPLES:

        sage: has_claw(graphs.ClawGraph())
        True

        sage: has_claw(graphs.PetersenGraph())
        True

        sage: has_claw(graphs.BullGraph())
        False

        sage: has_claw(graphs.HouseGraph())
        False
    """
    return g.subgraph_search(graphs.ClawGraph(), induced=True) is not None

def is_claw_free(g):
    """
    Tests whether graph ``g`` does not contain a Claw as an *induced* subgraph.

    A Claw is a 4-vertex graph with one central vertex and 3 pendants.
    This is encoded as ``graphs.ClawGraph()``.

    EXAMPLES:

        sage: is_claw_free(graphs.ClawGraph())
        False

        sage: is_claw_free(graphs.PetersenGraph())
        False

        sage: is_claw_free(graphs.BullGraph())
        True

        sage: is_claw_free(graphs.HouseGraph())
        True
    """
    return not has_claw(g)

def has_H(g):
    """
    Tests whether graph ``g`` contains an H graph as an *induced* subgraph.

    An H graph may also be known as a double fork. It is a 6-vertex graph
    formed by two Path_3s with their midpoints joined by a bridge.

    EXAMPLES:

        sage: has_H(double_fork)
        True

        sage: has_H(graphs.PetersenGraph())
        True

        sage: has_H(ce71) # double_fork with extra edge
        False

        sage: has_H(graphs.BullGraph())
        False
    """
    return g.subgraph_search(double_fork, induced=True) is not None

def is_H_free(g):
    """
    Tests if graph ``g`` does not contain a H graph as an *induced* subgraph.

    An H graph may also be known as a double fork. It is a 6-vertex graph
    formed by two Path_3s with their midpoints joined by a bridge.

    EXAMPLES:

        sage: is_H_free(double_fork)
        False

        sage: is_H_free(graphs.PetersenGraph())
        False

        sage: is_H_free(ce71) # double_fork with extra edge
        True

        sage: is_H_free(graphs.BullGraph())
        True
    """
    return not has_H(g)

def has_fork(g):
    """
    Tests if graph ``g`` contains a Fork graph as an *induced* subgraph.

    A Fork graph may also be known as a Star_1_1_3. It is a 6-vertex graph
    formed by a Path_4 with two pendants connected to one end.
    It is stored as `star_1_1_3`.

    EXAMPLES:

        sage: has_fork(star_1_1_3)
        True

        sage: has_fork(graphs.PetersenGraph())
        True

        sage: has_fork(graphs.LollipopGraph(3, 2))
        False

        sage: has_fork(graphs.HouseGraph())
        False

        sage: has_fork(graphs.ClawGraph())
        False
    """
    return g.subgraph_search(star_1_1_3, induced=True) is not None

def is_fork_free(g):
    """
    Tests if graph ``g`` does not contain Fork graph as an *induced* subgraph.

    A Fork graph may also be known as a Star_1_1_3. It is a 6-vertex graph
    formed by a Path_4 with two pendants connected to one end.
    It is stored as `star_1_1_3`.

    EXAMPLES:

        sage: is_fork_free(star_1_1_3)
        False

        sage: is_fork_free(graphs.PetersenGraph())
        False

        sage: is_fork_free(graphs.LollipopGraph(3, 2))
        True

        sage: is_fork_free(graphs.HouseGraph())
        True

        sage: is_fork_free(graphs.ClawGraph())
        True
    """
    return not has_fork(g)

def has_k4(g):
    """
    Tests if graph ``g`` contains a `K_4` as an *induced* subgraph.

    `K_4` is the complete graph on 4 vertices.

    EXAMPLES:

        sage: has_k4(graphs.CompleteGraph(4))
        True

        sage: has_k4(graphs.CompleteGraph(5))
        True

        sage: has_k4(graphs.CompleteGraph(3))
        False

        sage: has_k4(graphs.PetersenGraph())
        False
    """
    return g.subgraph_search(alpha_critical_easy[2], induced=True) is not None

def is_k4_free(g):
    """
    Tests if graph ``g`` does not contain a `K_4` as an *induced* subgraph.

    `K_4` is the complete graph on 4 vertices.

    EXAMPLES:

        sage: is_k4_free(graphs.CompleteGraph(4))
        False

        sage: is_k4_free(graphs.CompleteGraph(5))
        False

        sage: is_k4_free(graphs.CompleteGraph(3))
        True

        sage: is_k4_free(graphs.PetersenGraph())
        True
    """
    return not has_k4(g)

def is_double_clique(g):
    """
    Tests if graph ``g`` can be partitioned into 2 sets which induce cliques.

    EXAMPLE:

        sage: is_double_clique(p4)
        True

        sage: is_double_clique(graphs.ButterflyGraph())
        True

        sage: is_double_clique(graphs.CompleteBipartiteGraph(3,4))
        False

        sage: is_double_clique(graphs.ClawGraph())
        False

        sage: is_double_clique(Graph(3))
        False

    Edge cases ::

        sage: is_double_clique(Graph(0))
        True

        sage: is_double_clique(Graph(1))
        True

        sage: is_double_clique(Graph(2))
        True
    """
    gc = g.complement()
    return gc.is_bipartite()

def has_radius_equal_diameter(g):
    """
    Evaluates whether the radius of graph ``g`` equals its diameter.

    Recall the radius of a graph is the minimum eccentricity over all vertices,
    or the minimum over all longest distances from a vertex to any other vertex.
    Diameter is the maximum eccentricity over all vertices.
    Both radius and diamter are defined to be `+Infinity` for disconnected
    graphs.

    Both radius and diameter are undefined for the empty graph.

    EXAMPLES:

        sage: has_radius_equal_diameter(Graph(4))
        True

        sage: has_radius_equal_diameter(graphs.HouseGraph())
        True

        sage: has_radius_equal_diameter(Graph(1))
        True

        sage: has_radius_equal_diameter(graphs.ClawGraph())
        False

        sage: has_radius_equal_diameter(graphs.BullGraph())
        False
    """
    return g.radius() == g.diameter()

def has_residue_equals_alpha(g):
    """
    Evaluate whether the residue of graph ``g`` equals its independence number.

    The independence number is the cardinality of the largest independent set
    of vertices in ``g``.
    The residue of a graph ``g`` with degrees `d_1 \geq d_2 \geq ... \geq d_n`
    is found iteratively. First, remove `d_1` from consideration and subtract
    `d_1` from the following `d_1` number of elements. Sort. Repeat this
    process for `d_2,d_3, ...` until only 0s remain. The number of elements,
    i.e. the number of 0s, is the residue of ``g``.

    Residue is undefined on the empty graph.

    EXAMPLES:

        sage: has_residue_equals_alpha(graphs.HouseGraph())
        True

        sage: has_residue_equals_alpha(graphs.ClawGraph())
        True

        sage: has_residue_equals_alpha(graphs.CompleteGraph(4))
        True

        sage: has_residue_equals_alpha(Graph(1))
        True

        sage: has_residue_equals_alpha(graphs.PetersenGraph())
        False

        sage: has_residue_equals_alpha(graphs.PathGraph(5))
        False
    """
    return residue(g) == independence_number(g)

def is_not_forest(g):
    """
    Evaluates if graph ``g`` is not a forest.

    A forest is a disjoint union of trees. Equivalently, a forest is any acylic
    graph, which may or may not be connected.

    EXAMPLES:
        sage: is_not_forest(graphs.BalancedTree(2,3))
        False

        sage: is_not_forest(graphs.BalancedTree(2,3).disjoint_union(graphs.BalancedTree(3,3)))
        False

        sage: is_not_forest(graphs.CycleGraph(5))
        True

        sage: is_not_forest(graphs.HouseGraph())
        True

    Edge cases ::

        sage: is_not_forest(Graph(1))
        False

        sage: is_not_forest(Graph(0))
        False
    """
    return not g.is_forest()

def has_empty_KE_part(g):
    """
    Evaluates whether graph ``g`` has an empty Konig-Egervary subgraph.

    A Konig-Egervary graph satisfies
        independence number + matching number = order.
    By [Lar2011]_, every graph contains a unique induced subgraph which is a
    Konig-Egervary graph.

    EXAMPLES:

        sage: has_empty_KE_part(graphs.PetersenGraph())
        True

        sage: has_empty_KE_part(graphs.CycleGraph(5))
        True

        sage: has_empty_KE_part(graphs.CompleteBipartiteGraph(3,4))
        False

        sage: has_empty_KE_part(graphs.CycleGraph(6))
        False

    Edge cases ::

        sage: has_empty_KE_part(Graph(1))
        False

        sage: has_empty_KE_part(Graph(0))
        True

    ALGORITHM:

    This function is implemented using the Maximum Critical Independent
    Set (MCIS) algorithm of [DL2013]_ and applying a Theorem of [Lar2011]_.

    Define that an independent set `I` is a critical independent set if
    `|I|−|N(I)| \geq |J|−|N(J)|` for any independent set J. Define that a
    maximum critical independent set is a critical independent set of maximum
    cardinality.

    By a Theorem of [Lar2011]_, for every maximum critical independent set `J`
    of `G`, the unique Konig-Egervary inducing set `X` is `X = J \cup N(J)`,
    where `N(J)` is the neighborhood of `J`.
    Therefore, the ``g`` has an empty Konig-Egervary induced subgraph if and
    only if the MCIS `J = \emptyset`.

    Next, we describe the MCIS algorithm.
    Let `B(G) = K_2 \ times G`, i.e. `B(G)` is the bipartite double cover
    of `G`. Let `v' \in B(G)` denote the new "twin" of vertex `v \in G`.
    Let `a` be the independence number of `B(G)`.
    For each vertex `v` in `B(G)`, calculate
        `t := independence number(B(G) - \{v,v'\} - N(\{v,v'\})) + 2`.
    If `t = a`, then `v` is in the MCIS.
        Since we only care about whether the MCIS is empty, if `t = a`,
        we return ``False`` and terminate.

    Finally, use the Gallai identities to show matching

    Finally, we apply the Konig-Egervary Theorem (1931) that for all bipartite
    graphs, matching number = vertex cover number. We substitute this into
    one of the Gallai identities, that
        independence number + covering number = order,
    yielding,
        independence number = order - matching number.
    Since matching number is efficient to compute, our final algorithm is
    in fact efficient.

    REFERENCES:

    .. [DL2013]     \Ermelinda DeLaVina and Craig Larson, "A parallel ALGORITHM
                    for computing the critical independence number and related
                    sets". ARS Mathematica Contemporanea 6: 237--245, 2013.

    .. [Lar2011]    \C.E. Larson, "Critical Independent Sets and an
                    Independence Decomposition Theorem". European Journal of
                    Combinatorics 32: 294--300, 2011.
    """
    b = bipartite_double_cover(g)
    alpha = b.order() - b.matching(value_only=True)
    for v in g.vertices():
        test = b.copy()
        test.delete_vertices(closed_neighborhood(b,[(v,0), (v,1)]))
        alpha_test = test.order() - test.matching(value_only=True) + 2
        if alpha_test == alpha:
            return False
    return True

def is_class1(g):
    """
    Evaluates whether the chomatic index of graph ``g`` equals its max degree.

    Let `D` be the maximum degree. By Vizing's Thoerem, all graphs can be
    edge-colored in either `D` or `D+1` colors. The case of `D` colors is
    called "class 1".

    Max degree is undefined for the empty graph.

    EXAMPLES:

        sage: is_class1(graphs.CompleteGraph(4))
        True

        sage: is_class1(graphs.WindmillGraph(4,3))
        True

        sage: is_class1(Graph(1))
        True

        sage: is_class1(graphs.CompleteGraph(3))
        False

        sage: is_class1(graphs.PetersenGraph())
        False
    """
    return g.chromatic_index() == max(g.degree())

def is_class2(g):
    """
    Evaluates whether the chomatic index of graph ``g`` equals max degree + 1.

    Let `D` be the maximum degree. By Vizing's Thoerem, all graphs can be
    edge-colored in either `D` or `D+1` colors. The case of `D+1` colors is
    called "class 2".

    Max degree is undefined for the empty graph.

    EXAMPLES:

        sage: is_class2(graphs.CompleteGraph(4))
        False

        sage: is_class2(graphs.WindmillGraph(4,3))
        False

        sage: is_class2(Graph(1))
        False

        sage: is_class2(graphs.CompleteGraph(3))
        True

        sage: is_class2(graphs.PetersenGraph())
        True
    """
    return not(g.chromatic_index() == max(g.degree()))

def is_cubic(g):
    """
    Evalutes whether graph ``g`` is cubic, i.e. is 3-regular.

    EXAMPLES:

        sage: is_cubic(graphs.CompleteGraph(4))
        True

        sage: is_cubic(graphs.PetersenGraph())
        True

        sage: is_cubic(graphs.CompleteGraph(3))
        False

        sage: is_cubic(graphs.HouseGraph())
        False
    """
    D = g.degree()
    return min(D) == 3 and max(D) == 3

def is_anti_tutte(g):
    """
    Evalutes if graph ``g`` is connected and indep. number <= diameter + girth.

    This property is satisfied by many Hamiltonian graphs, but notably not by
    the Tutte graph ``graphs.TutteGraph()``.

    Diameter is undefined for the empty graph.

    EXAMPLES:

        sage: is_anti_tutte(graphs.CompleteBipartiteGraph(4, 5))
        True

        sage: is_anti_tutte(graphs.PetersenGraph())
        True

        sage: is_anti_tutte(Graph(1))

        sage: is_anti_tutte(graphs.TutteGraph())
        False

        sage: is_anti_tutte(graphs.TutteCoxeterGraph())
        False
    """
    if not g.is_connected():
        return False
    return independence_number(g) <= g.diameter() + g.girth()

def is_anti_tutte2(g):
    """
    Tests if graph ``g`` has indep. number <= domination number + radius - 1.

    ``g`` must also be connected.
    This property is satisfied by many Hamiltonian graphs, but notably not by
    the Tutte graph ``graphs.TutteGraph()``.

    Radius is undefined for the empty graph.

    EXAMPLES:

        sage: is_anti_tutte2(graphs.CompleteGraph(5))
        True

        sage: is_anti_tutte2(graphs.PetersenGraph())
        True

        sage: is_anti_tutte2(graphs.TutteGraph())
        False

        sage: is_anti_tutte2(graphs.TutteCoxeterGraph())
        False

        sage: is_anti_tutte2(Graph(1))
        False
    """
    if not g.is_connected():
        return False
    return independence_number(g) <=  domination_number(g) + g.radius()- 1

def diameter_equals_twice_radius(g):
    """
    Evaluates whether the diameter of graph ``g`` is equal to twice its radius.

    Diameter and radius are undefined for the empty graph.

    EXAMPLES:

        sage: has_radius_equal_diameter(graphs.ClawGraph())
        True

        sage: has_radius_equal_diameter(graphs.KrackhardtKiteGraph())
        True

        sage: diameter_equals_twice_radius(graphs.HouseGraph())
        False

        sage: has_radius_equal_diameter(graphs.BullGraph())
        False

    The radius and diameter of ``Graph(1)`` are both 1. ::

        sage: diameter_equals_twice_radius(Graph(1))
        True

    Disconnected graphs have both diameter and radius equal infinity.

        sage: diameter_equals_twice_radius(Graph(4))
        True
    """
    return g.diameter() == 2*g.radius()

def diameter_equals_two(g):
    """
    Evaluates whether the diameter of graph ``g`` equals 2.

    Diameter is undefined for the empty graph.

    EXAMPLES:

        sage: diameter_equals_two(graphs.ClawGraph())
        True

        sage: diameter_equals_two(graphs.HouseGraph())
        True

        sage: diameter_equals_two(graphs.KrackhardtKiteGraph())
        False

        sage: diameter_equals_two(graphs.BullGraph())
        False

    Disconnected graphs have diameter equals infinity.

        sage: diameter_equals_two(Graph(4))
        False
    """
    return g.diameter() == 2

def has_lovasz_theta_equals_alpha(g):
    """
    Tests if the Lovasz number of graph ``g`` equals its independence number.

    Examples:

        sage: has_lovasz_theta_equals_alpha(graphs.CompleteGraph(12))
        True

        sage: has_lovasz_theta_equals_alpha(double_fork)
        True

        sage: has_lovasz_theta_equals_alpha(graphs.PetersenGraph())
        True

        sage: has_lovasz_theta_equals_alpha(graphs.ClebschGraph())
        False

        sage: has_lovasz_theta_equals_alpha(graphs.CycleGraph(24))
        False

    True for all graphs with no edges ::

        sage: has_lovasz_theta_equals_alpha(Graph(12))
        True

    Edge cases ::

        sage: has_lovasz_theta_equals_alpha(Graph(0))
        True

        # Broken. Issue #584
        sage: has_lovasz_theta_equals_alpha(Graph(1)) # doctest: +SKIP
        True
    """
    return g.lovasz_theta() == independence_number(g)

def has_lovasz_theta_equals_cc(g):
    """
    Test if the Lovasz number of graph ``g`` equals its clique covering number.

    Examples:

        sage: has_lovasz_theta_equals_cc(graphs.CompleteGraph(12))
        True

        sage: has_lovasz_theta_equals_cc(double_fork)
        True

        sage: has_lovasz_theta_equals_cc(graphs.PetersenGraph())
        True

        sage: has_lovasz_theta_equals_cc(Graph(12))
        True

        sage: has_lovasz_theta_equals_cc(graphs.ClebschGraph())
        False

        has_lovasz_theta_equals_alpha(graphs.BuckyBall())
        False

    Edge cases ::

        sage: has_lovasz_theta_equals_cc(Graph(0))
        True

        # Broken. Issue #584
        sage: has_lovasz_theta_equals_cc(Graph(1)) # doctest: +SKIP
        True
    """
    return g.lovasz_theta() == clique_covering_number(g)

def is_chvatal_erdos(g):
    """
    Evaluates whether graph ``g`` meets a Hamiltonicity condition of [CV1972]_.

    OUTPUT:

    Returns ``True`` if the independence number of ``g`` is less than or equal
    to the vertex connectivity of ``g``.
    Returns ``False`` otherwise.

    EXAMPLES:

        sage: is_chvatal_erdos(graphs.CompleteGraph(5))
        True

        sage: is_chvatal_erdos(graphs.CycleGraph(5))
        True

        sage: is_chvatal_erdos(graphs.CompleteGraph(2))
        True

        sage: is_chvatal_erdos(graphs.PetersenGraph())
        False

        sage: is_chvatal_erdos(graphs.ClawGraph())
        False

        sage: is_chvatal_erdos(graphs.DodecahedralGraph())
        False

    Edge cases ::

        sage: is_chvatal_erdos(Graph(1))
        False

        sage: is_chvatal_erdos(Graph(0))
        True

    REFERENCES:

    Theorem: If a graph ``is_chvatal_erdos``, then it is Hamiltonian.

    .. [CV1972]     \V. Chvatal and P. Erdos, "A note on hamiltonian cycles".
                    Discrete Mathematics, 2(2): 111--113, 1972.
    """
    return independence_number(g) <= g.vertex_connectivity()

def matching_covered(g):
    """
    Skipping because broken. See Issue #585.
    """
    g = g.copy()
    nu = matching_number(g)
    E = g.edges()
    for e in E:
        g.delete_edge(e)
        nu2 = matching_number(g)
        if nu != nu2:
            return False
        g.add_edge(e)
    return True

def radius_greater_than_center(g):
    """
    Test if connected graph ``g`` has radius greater than num. of center verts.

    If ``g`` is not connected, returns ``False``.
    Radius is undefined for the empty graph.

    EXAMPLES:

        sage: radius_greater_than_center(graphs.TutteGraph())
        True

        sage: radius_greater_than_center(graphs.KrackhardtKiteGraph())
        True

        sage: radius_greater_than_center(graphs.SousselierGraph())
        True

        sage: radius_greater_than_center(graphs.PetersenGraph())
        False

        sage: radius_greater_than_center(graphs.DiamondGraph())
        False

        sage: radius_greater_than_center(Graph(1))
        False
    """
    return g.is_connected() and g.radius() > card_center(g)

def avg_distance_greater_than_girth(g):
    """
    Tests if graph ``g`` is connected and avg. distance greater than the girth.

    Average distance is undefined for 1- and 0- vertex graphs.

    EXAMPLES:

        sage: avg_distance_greater_than_girth(graphs.TutteGraph())
        True

        sage: avg_distance_greater_than_girth(graphs.HarborthGraph())
        True

        sage: avg_distance_greater_than_girth(graphs.HortonGraph())
        True

        sage: avg_distance_greater_than_girth(graphs.BullGraph())
        False

        sage: avg_distance_greater_than_girth(Graph("NC`@A?_C?@_JA??___W"))
        False

        sage: avg_distance_greater_than_girth(Graph(2))
        False

    Acyclic graphs have girth equals infinity. ::

        sage: avg_distance_greater_than_girth(graphs.CompleteGraph(2))
        False
    """
    return g.is_connected() and g.average_distance() > g.girth()

def chi_equals_min_theory(g):
    """
    Evaluate if chromatic num. of graph ``g`` equals min. of some upper bounds.

    Some known upper bounds on the chromatic number Chi (`\chi`) include
    our invariants `[brooks, wilf, welsh_powell, szekeres_wilf]`.
    Returns ``True`` if the actual chromatic number of ``g`` equals the minimum
    of / "the best of" these known upper bounds.

    Some of these invariants are undefined on the empty graph.

    EXAMPLES:

        sage: chi_equals_min_theory(Graph(1))
        True

        sage: chi_equals_min_theory(graphs.PetersenGraph())
        True

        sage: chi_equals_min_theory(double_fork)
        True

        sage: chi_equals_min_theory(Graph(3))
        False

        chi_equals_min_theory(graphs.CompleteBipartiteGraph(3,5))
        False

        chi_equals_min_theory(graphs.IcosahedralGraph())
        False
    """
    chromatic_upper_theory = [brooks, wilf, welsh_powell, szekeres_wilf]
    min_theory = min([f(g) for f in chromatic_upper_theory])
    return min_theory == g.chromatic_number()

def is_heliotropic_plant(g):
    """
    Evaluates whether graph ``g`` is a heliotropic plant. BROKEN

    BROKEN: code should be nonnegative eigen, not just positive eigen.
    See Issue #586

    A graph is heliotropic iff the independence number equals the number of
    nonnegative eigenvalues.

    See [BDF1995]_ for a definition and some related conjectures, where
    [BDF1995]_ builds on the conjecturing work of Siemion Fajtlowicz.

    EXAMPLES:

    REFERENCES:

    .. [BDF1995]    Tony Brewster, Michael J.Dinneen, and Vance Faber, "A
                    computational attack on the conjectures of Graffiti: New
                    counterexamples and proofs". Discrete Mathematics,
                    147(1--3): 35--55, 1995.
    """
    return (independence_number(g) == card_positive_eigenvalues(g))

def is_geotropic_plant(g):
    """
    Evaluates whether graph ``g`` is a heliotropic plant. BROKEN

    BROKEN: code should be nonpositive eigen, not just negative eigen.
    See Issue #586

    A graph is geotropic iff the independence number equals the number of
    nonnegative eigenvalues.

    See [BDF1995]_ for a definition and some related conjectures, where
    [BDF1995]_ builds on the conjecturing work of Siemion Fajtlowicz.

    EXAMPLES:

    REFERENCES:

    .. [BDF1995]    Tony Brewster, Michael J.Dinneen, and Vance Faber, "A
                    computational attack on the conjectures of Graffiti: New
                    counterexamples and proofs". Discrete Mathematics,
                    147(1--3): 35--55, 1995.
    """
    return (independence_number(g) == card_negative_eigenvalues(g))

def is_traceable(g):
    """
    Evaluates whether graph ``g`` is traceable.

    A graph ``g`` is traceable iff there exists a Hamiltonian path, i.e. a path
    which visits all vertices in ``g`` once.
    This is different from ``is_hamiltonian``, since that checks if there
    exists a Hamiltonian *cycle*, i.e. a path which then connects backs to
    its starting point.

    EXAMPLES:

        sage: is_traceable(graphs.CompleteGraph(5))
        True

        sage: is_traceable(graphs.PathGraph(5))
        True

        sage: is_traceable(graphs.PetersenGraph())
        True

        sage: is_traceable(graphs.CompleteGraphs(2))
        True

        sage: is_traceable(Graph(3))
        False

        sage: is_traceable(graphs.ClawGraph())
        False

        sage: is_traceable(graphs.ButterflyGraph())
        False

    Edge cases ::

        sage: is_traceable(Graph(0))
        False

        sage: is_traceable(Graph(1))
        False

    ALGORITHM:

    A graph `G` is traceable iff the join `G'` of `G` with a single new vertex
    `v` is Hamiltonian, where join means to connect every vertex of `G` to the
    new vertex `v`.
    Why? Suppose there exists a Hamiltonian path between `u` and `w` in `G`.
    Then, in `G'`, make a cycle from `v` to `u` to `w` and back to `v`.
    For the reverse direction, just note that the additional vertex `v` cannot
    "help" since Hamiltonian paths can only visit any vertex once.
    """
    gadd = g.join(Graph(1),labels="integers")
    return gadd.is_hamiltonian()

def has_residue_equals_two(g):
    """
    Evaluates whether the residue of graph ``g`` equals 2.

    The residue of a graph ``g`` with degrees `d_1 \geq d_2 \geq ... \geq d_n`
    is found iteratively. First, remove `d_1` from consideration and subtract
    `d_1` from the following `d_1` number of elements. Sort. Repeat this
    process for `d_2,d_3, ...` until only 0s remain. The number of elements,
    i.e. the number of 0s, is the residue of ``g``.

    Residue is undefined on the empty graph.

    EXAMPLES:

        sage: has_residue_equals_two(graphs.ButterflyGraph())
        True

        sage: has_residue_equals_two(graphs.IcosahedralGraph())
        True

        sage: has_residue_equals_two(graphs.OctahedralGraph())
        True

        sage: has_residue_equals_two(Graph(1))
        False

        sage: has_residue_equals_two(graphs.BullGraph())
        False

        sage: has_residue_equals_two(graphs.BrinkmannGraph())
        False
    """
    return residue(g) == 2

def is_chordal_or_not_perfect(g):
    """
    Evaluates if graph ``g`` is either chordal or not perfect.

    There is a known theorem that every chordal graph is perfect.

    OUTPUT:

    Returns ``True`` iff ``g`` is chordal OR (inclusive or) ``g`` is not
    perfect.

    EXAMPLES:

        sage: is_chordal_or_not_perfect(graphs.DiamondGraph())
        True

        sage: is_chordal_or_not_perfect(graphs.CycleGraph(5))
        True

        sage: is_chordal_or_not_perfect(graphs.LollipopGraph(5,3))
        True

        sage: is_chordal_or_not_perfect(graphs.CycleGraph(4))
        False

        sage: is_chordal_or_not_perfect(graphs.HexahedralGraph())
        False

    Vacuously chordal cases ::

        sage: is_chordal_or_not_perfect(Graph(0))
        True

        sage: is_chordal_or_not_perfect(Graph(1))
        True

        sage: is_complement_of_chordal(Graph(4))
        True
    """
    if g.is_chordal():
        return true
    else:
        return not g.is_perfect()

def has_alpha_residue_equal_two(g):
    """
    Tests if both the residue and independence number of graphs ``g`` equal 2.

    The residue of a graph ``g`` with degrees `d_1 \geq d_2 \geq ... \geq d_n`
    is found iteratively. First, remove `d_1` from consideration and subtract
    `d_1` from the following `d_1` number of elements. Sort. Repeat this
    process for `d_2,d_3, ...` until only 0s remain. The number of elements,
    i.e. the number of 0s, is the residue of ``g``.

    Residue is undefined on the empty graph.

    EXAMPLES:

        sage: has_alpha_residue_equal_two(graphs.DiamondGraph())
        True

        sage: has_alpha_residue_equal_two(Graph(2))
        True

        sage: has_alpha_residue_equal_two(graphs.OctahedralGraph())
        True

        sage: has_alpha_residue_equal_two(graphs.BullGraph())
        False

        sage: has_alpha_residue_equal_two(graphs.BidiakisCube())
        False

        sage: has_alpha_residue_equal_two(Graph(3))
        False

        sage: has_alpha_residue_equal_two(Graph(1))
        False
    """
    if residue(g) != 2:
        return false
    else:
        return independence_number(g) == 2

def alpha_leq_order_over_two(g):
    """
    Tests if the independence number of graph ``g`` is at most half its order.

    EXAMPLES:

        sage: alpha_leq_order_over_two(graphs.ButterflyGraph())
        True

        sage: alpha_leq_order_over_two(graphs.DiamondGraph())
        True

        sage: alpha_leq_order_over_two(graphs.CoxeterGraph())
        True

        sage: alpha_leq_order_over_two(Graph(4))
        False

        sage: alpha_leq_order_over_two(graphs.BullGraph())
        False

    Edge cases ::

        sage: alpha_leq_order_over_two(Graph(0))
        True

        sage: alpha_leq_order_over_two(Graph(1))
        False
    """
    return (2*independence_number(g) <= g.order())

def order_leq_twice_max_degree(g):
    """
    Tests if the order of graph ``g`` is at most twice the max of its degrees.

    Undefined for the empty graph.

    EXAMPLES:

        sage: order_leq_twice_max_degree(graphs.BullGraph())
        True

        sage: order_leq_twice_max_degree(graphs.ThomsenGraph())
        True

        sage: order_leq_twice_max_degree(graphs.CycleGraph(4))
        True

        sage: order_leq_twice_max_degree(graphs.BidiakisCube())
        False

        sage: order_leq_twice_max_degree(graphs.CycleGraph(5))
        False

        sage: order_leq_twice_max_degree(Graph(1))
        False
    """
    return (g.order() <= 2*max(g.degree()))

def is_chromatic_index_critical(g):
    """
    Evaluates whether graph ``g`` is chromatic index critical.

    Let `\chi(G)` denote the chromatic index of a graph `G`.
    Then `G` is chromatic index critical if `\chi(G-e) < \chi(G)` (strictly
    less than) for all `e \in G` AND if (by definition) `G` is class 2.

    See [FW1977]_ for a more extended definition and discussion.

    We initially found it surprising that `G` is required to be class 2; for
    example, the Star Graph is a class 1 graph which satisfies the rest of
    the definition. We have found articles which equivalently define critical
    graphs as class 2 graphs which become class 1 when any edge is removed.
    Perhaps this latter definition inspired the one we state above?

    Max degree is undefined on the empty graph, so ``is_class`` is also
    undefined. Therefore this property is undefined on the empty graph.

    EXAMPLES:

        sage: is_chromatic_index_critical(Graph('Djk'))
        True

        sage: is_chromatic_index_critical(graphs.CompleteGraph(3))
        True

        sage: is_chromatic_index_critical(graphs.CycleGraph(5))
        True

        sage: is_chromatic_index_critical(graphs.CompleteGraph(5))
        False

        sage: is_chromatic_index_critical(graphs.PetersenGraph())
        False

        sage: is_chromatic_index_critical(graphs.FlowerSnark())
        False

    Non-trivially disconnected graphs ::

        sage: is_chromatic_index_critical(graphs.CycleGraph(4).disjoint_union(graphs.CompleteGraph(4)))
        False

    Class 1 graphs ::

        sage: is_chromatic_index_critical(Graph(1))
        False

        sage: is_chromatic_index_critical(graphs.CompleteGraph(4))
        False

        sage: is_chromatic_index_critical(graphs.CompleteGraph(2))
        False

        sage: is_chromatic_index_critical(graphs.StarGraph(4))
        False

    ALGORITHM:

    This function uses a series of tricks to reduce the number of cases that
    need to be considered, before finally checking in the obvious way.

    First, if a graph has more than 1 non-trivial connected component, then
    return ``False``. This is because in a graph with multiple such components,
    removing any edges from the smaller component cannot affect the chromatic
    index.

    Second, check if the graph is class 2. If not, stop and return ``False``.

    Finally, identify isomorphic edges using the line graph and its orbits.
    We then need only check the non-equivalent edges to see that they reduce
    the chromatic index when deleted.

    REFERENCES:

    .. [FW1977]     \S. Fiorini and R.J. Wilson, "Edge-colourings of graphs".
                    Pitman Publishing, London, UK, 1977.
    """
    component_sizes = g.connected_components_sizes()
    if len(component_sizes) > 1:
        if component_sizes[1] > 1:
            return False

    if chi == max_degree(g):
        return False

    lg = g.line_graph()
    equiv_lines = lg.automorphism_group(return_group=False, orbits=true)
    equiv_lines_representatives = [orb[0] for orb in equiv_lines]

    gc = g.copy()
    for e in equiv_lines_representatives:
        gc.delete_edge(e)
        chi_prime = gc.chromatic_index()
        if chi_prime == chi:
            return False
        gc.add_edge(e)
    return True

#alpha(g-e) > alpha(g) for *every* edge g
def is_alpha_critical(g):
    #if not g.is_connected():
        #return False
    alpha = independence_number(g)
    for e in g.edges():
        gc = copy(g)
        gc.delete_edge(e)
        alpha_prime = independence_number(gc)
        if alpha_prime <= alpha:
            return False
    return True

#graph is KE if matching number + independence number = n, test does *not* compute alpha
def is_KE(g):
    return g.order() == len(find_KE_part(g))

#graph is KE if matching number + independence number = n, test comoutes alpha
#def is_KE(g):
#    return (g.matching(value_only = True) + independence_number(g) == g.order())

#possibly faster version of is_KE (not currently in invariants)
#def is_KE2(g):
#    return (independence_number(g) == critical_independence_number(g))

def is_independence_irreducible(g):
    return g.order() == card_independence_irreducible_part(g)


def is_factor_critical(g):
    """
    a graph is factor-critical if order is odd and removal of any vertex gives graph with perfect matching
        is_factor_critical(graphs.PathGraph(3))
        False
        sage: is_factor_critical(graphs.CycleGraph(5))
        True
    """
    if g.order() % 2 == 0:
        return False
    for v in g.vertices():
        gc = copy(g)
        gc.delete_vertex(v)
        if not gc.has_perfect_matching:
            return False
    return True

#returns a list of (necessarily non-adjacent) vertices that have the same neighbors as v if a pair exists or None
def find_twins_of_vertex(g,v):
    L = []
    V = g.vertices()
    D = g.distance_all_pairs()
    for i in range(g.order()):
        w = V[i]
        if  D[v][w] == 2 and g.neighbors(v) == g.neighbors(w):
                L.append(w)
    return L

def has_twin(g):
    t = find_twin(g)
    if t == None:
        return False
    else:
        return True

def is_twin_free(g):
    return not has_twin(g)

#returns twin pair (v,w) if one exists, else returns None
#can't be adjacent
def find_twin(g):

    V = g.vertices()
    for v in V:
        Nv = set(g.neighbors(v))
        for w in V:
            Nw = set(g.neighbors(w))
            if v not in Nw and Nv == Nw:
                return (v,w)
    return None

def find_neighbor_twins(g):
    V = g.vertices()
    for v in V:
        Nv = g.neighbors(v)
        for w in Nv:
            if set(closed_neighborhood(g,v)) == set(closed_neighborhood(g,w)):
                return (v,w)
    return None

#given graph g and subset S, looks for any neighbor twin of any vertex in T
#if result = T, then no twins, else the result is maximal, but not necessarily unique
def find_neighbor_twin(g, T):
    gT = g.subgraph(T)
    for v in T:
        condition = False
        Nv = set(g.neighbors(v))
        #print "v = {}, Nv = {}".format(v,Nv)
        NvT = set(gT.neighbors(v))
        for w in Nv:
            NwT = set(g.neighbors(w)).intersection(set(T))
            if w not in T and NvT.issubset(NwT):
                T.append(w)
                condition = True
                #print "TWINS: v = {}, w = {}, sp3 = {}".format(v,w,sp3)
                break
        if condition == True:
            break

#if result = T, then no twins, else the result is maximal, but not necessarily unique
def iterative_neighbor_twins(g, T):
    T2 = copy(T)
    find_neighbor_twin(g, T)
    while T2 != T:
        T2 = copy(T)
        find_neighbor_twin(g, T)
    return T


#can't compute membership in this class directly. instead testing isomorhism for 400 known class0 graphs
def is_pebbling_class0(g):
    for hkey in class0graphs_dict:
        h = Graph(class0graphs_dict[hkey])
        if g.is_isomorphic(h):
            return True
    return False

def girth_greater_than_2log(g):
    return bool(g.girth() > 2*log(g.order(),2))

def szekeres_wilf_equals_chromatic_number(g):
    return szekeres_wilf(g) == g.chromatic_number()

def has_Havel_Hakimi_property(g, v):
    """
    This function returns whether the vertex v in the graph g has the Havel-Hakimi
    property as defined in [1]. A vertex has the Havel-Hakimi property if it has
    maximum degree and the minimum degree of its neighbours is at least the maximum
    degree of its non-neigbours.

    [1] Graphs with the strong Havel-Hakimi property, M. Barrus, G. Molnar, Graphs
        and Combinatorics, 2016, http://dx.doi.org/10.1007/s00373-015-1674-7

    Every vertex in a regular graph has the Havel-Hakimi property::

        sage: P = graphs.PetersenGraph()
        sage: for v in range(10):
        ....:     has_Havel_Hakimi_property(P,v)
        True
        True
        True
        True
        True
        True
        True
        True
        True
        True
        sage: has_Havel_Hakimi_property(Graph([[0,1,2,3],lambda x,y: False]),0)
        True
        sage: has_Havel_Hakimi_property(graphs.CompleteGraph(5),0)
        True
    """
    if max_degree(g) > g.degree(v): return False

    #handle the case where the graph is an independent set
    if len(g.neighbors(v)) == 0: return True

    #handle the case where v is adjacent with all vertices
    if len(g.neighbors(v)) == len(g.vertices()) - 1: return True

    return (min(g.degree(nv) for nv in g.neighbors(v)) >=
        max(g.degree(nnv) for nnv in g.vertices() if nnv != v and nnv not in g.neighbors(v)))

def has_strong_Havel_Hakimi_property(g):
    """
    This function returns whether the graph g has the strong Havel-Hakimi property
    as defined in [1]. A graph has the strong Havel-Hakimi property if in every
    induced subgraph H of G, every vertex of maximum degree has the Havel-Hakimi
    property.

    [1] Graphs with the strong Havel-Hakimi property, M. Barrus, G. Molnar, Graphs
        and Combinatorics, 2016, http://dx.doi.org/10.1007/s00373-015-1674-7

    The graph obtained by connecting two cycles of length 3 by a single edge has
    the strong Havel-Hakimi property::

        sage: has_strong_Havel_Hakimi_property(Graph('E{CW'))
        True
    """
    for S in Subsets(g.vertices()):
        if len(S)>2:
            H = g.subgraph(S)
            Delta = max_degree(H)
            if any(not has_Havel_Hakimi_property(H, v) for v in S if H.degree(v) == Delta):
                return False
    return True

# Graph is subcubic is each vertex is at most degree 3
def is_subcubic(g):
    return max_degree(g) <= 3

# Max and min degree varies by at most 1
def is_quasi_regular(g):
    if max_degree(g) - min_degree(g) < 2:
        return true
    return false

# g is bad if a block is isomorphic to k3, c5, k4*, c5*
def is_bad(g):
    blocks = g.blocks_and_cut_vertices()[0]
    # To make a subgraph of g from the ith block
    for i in blocks:
        h = g.subgraph(i)
        boolean = h.is_isomorphic(alpha_critical_easy[1]) or h.is_isomorphic(alpha_critical_easy[4]) or h.is_isomorphic(alpha_critical_easy[5]) or h.is_isomorphic(alpha_critical_easy[21])
        if boolean == True:
            return True
    return False

# Graph g is complement_hamiltonian if the complement of the graph is hamiltonian.
def is_complement_hamiltonian(g):
    return g.complement().is_hamiltonian()

# A graph is unicyclic if it is connected and has order == size
# Equivalently, graph is connected and has exactly one cycle
def is_unicyclic(g):
    """
    Tests:
        sage: is_unicyclic(graphs.BullGraph())
        True
        sage: is_unicyclic(graphs.ButterflyGraph())
        False
    """
    return g.is_connected() and g.order() == g.size()

def is_k_tough(g,k):
    return toughness(g) >= k # In invariants
def is_1_tough(g):
    return is_k_tough(g, 1)
def is_2_tough(g):
    return is_k_tough(g, 2)

# True if graph has at least two hamiltonian cycles. The cycles may share some edges.
def has_two_ham_cycles(gIn):
    g = gIn.copy()
    g.relabel()
    try:
        ham1 = g.hamiltonian_cycle()
    except EmptySetError:
        return False

    for e in ham1.edges():
        h = copy(g)
        h.delete_edge(e)
        if h.is_hamiltonian():
            return true
    return false

def has_simplical_vertex(g):
    """
    v is a simplical vertex if induced neighborhood is a clique.
    """
    for v in g.vertices():
        if is_simplical_vertex(g, v):
            return true
    return false

def has_exactly_two_simplical_vertices(g):
    """
    v is a simplical vertex if induced neighborhood is a clique.
    """
    return simplical_vertices(g) == 2

def is_two_tree(g):
    """
    Define k-tree recursively:
        - Complete Graph on (k+1)-vertices is a k-tree
        - A k-tree on n+1 vertices is constructed by selecting some k-tree on n vertices and
            adding a degree k vertex such that its open neighborhood is a clique.
    """
    if(g.is_isomorphic(graphs.CompleteGraph(3))):
        return True

    # We can just recurse from any degree-2 vertex; no need to test is_two_tree(g-w) if is_two_tree(g-v) returns False.
    # Intuition why: if neighborhood of a degree-2 v is not a triangle, it won't become one if we remove w (so clique check OK),
    # and, removing a degree-2 vertex of one triangle cannot destroy another triangle (so recursion OK).
    degree_two_vertices = (v for v in g.vertices() if g.degree(v) == 2)
    try:
        v = next(degree_two_vertices)
    except StopIteration: # Empty list. No degree 2 vertices.
        return False

    if not g.has_edge(g.neighbors(v)): # Clique
        return false
    g2 = g.copy()
    g2.delete_vertex(v)
    return is_two_tree(g2)

def is_two_path(g):
    """
    Graph g is a two_path if it is a two_tree and has exactly 2 simplical vertices
    """
    return has_exactly_two_simplical_vertices(g) and is_two_tree(g)

def is_prism_hamiltonian(g):
    """
    A graph G is prism hamiltonian if G x K2 (cartesian product) is hamiltonian
    """
    return g.cartesian_product(graphs.CompleteGraph(2)).is_hamiltonian()

# Bauer, Douglas, et al. "Long cycles in graphs with large degree sums." Discrete Mathematics 79.1 (1990): 59-70.
def is_bauer(g):
    """
    True if g is 2_tough and sigma_3 >= order
    """
    return is_2_tough(g) and sigma_k(g, 3) >= g.order()

# Jung, H. A. "On maximal circuits in finite graphs." Annals of Discrete Mathematics. Vol. 3. Elsevier, 1978. 129-144.
def is_jung(g):
    """
    True if graph has n >= 11, if graph is 1-tough, and sigma_2 >= n - 4.
    See functions toughness(g) and sigma_2(g) for more details.
    """
    return g.order() >= 11 and is_1_tough(g) and sigma_2(g) >= g.order() - 4

# Bela Bollobas and Andrew Thomason, Weakly Pancyclic Graphs. Journal of Combinatorial Theory 77: 121--137, 1999.
def is_weakly_pancyclic(g):
    """
    True if g contains cycles of every length k from k = girth to k = circumfrence

    Returns False if g is acyclic (in which case girth = circumfrence = +Infinity).

    sage: is_weakly_pancyclic(graphs.CompleteGraph(6))
    True
    sage: is_weakly_pancyclic(graphs.PetersenGraph())
    False
    """
    lengths = cycle_lengths(g)
    if not lengths: # acyclic
        raise ValueError("Graph is acyclic. Property undefined.")
    else:
        return lengths == set(range(min(lengths),max(lengths)+1))

def is_pancyclic(g):
    """
    True if g contains cycles of every length from 3 to g.order()

    sage: is_pancyclic(graphs.OctahedralGraph())
    True
    sage: is_pancyclic(graphs.CycleGraph(10))
    False
    """
    lengths = cycle_lengths(g)
    return lengths == set(range(3, g.order()+1))

def has_two_walk(g):
    """
    A two-walk is a closed walk that visits every vertex and visits no vertex more than twice.

    Two-walk is a generalization of Hamiltonian cycles. If a graph is Hamiltonian, then it has a two-walk.

    sage: has_two_walk(c4c4)
    True
    sage: has_two_walk(graphs.WindmillGraph(3,3))
    False
    """
    for init_vertex in g.vertices():
        path_stack = [[init_vertex]]
        while path_stack:
            path = path_stack.pop()
            for neighbor in g.neighbors(path[-1]):
                if neighbor == path[0] and all(v in path for v in g.vertices()):
                    return True
                elif path.count(neighbor) < 2:
                    path_stack.append(path + [neighbor])
    return False

def is_claw_free_paw_free(g):
    return is_claw_free(g) and is_paw_free(g)

def has_bull(g):
    """
    True if g has an induced subgraph isomorphic to graphs.BullGraph()
    """
    return g.subgraph_search(graphs.BullGraph(), induced = True) != None

def is_bull_free(g):
    """
    True if g does not have an induced subgraph isomoprhic to graphs.BullGraph()
    """
    return not has_bull(g)

def is_claw_free_bull_free(g):
    return is_claw_free(g) and is_bull_free(g)

def has_F(g):
    """
    Let F be a triangle with 3 pendants. True if g has an induced F.
    """
    F = graphs.CycleGraph(3)
    F.add_vertices([3,4,5])
    F.add_edges([(0,3), [1,4], [2,5]])
    return g.subgraph_search(F, induced = True) != None

def is_F_free(g):
    """
    Let F be a triangle with 3 pendants. True if g has no induced F.
    """
    return not has_F(g)

# Ronald Gould, Updating the Hamiltonian problem — a survey. Journal of Graph Theory 15.2: 121-157, 1991.
def is_oberly_sumner(g):
    """
    g is_oberly_sumner if order >= 3, is_two_connected, is_claw_free, AND is_F_free
    """
    return g.order() >= 3 and is_two_connected(g) and is_claw_free(g) and is_F_free(g)
def is_oberly_sumner_bull(g):
    """
    True if g is 2-connected, claw-free, and bull-free
    """
    return is_two_connected(g) and is_claw_free_bull_free(g)
def is_oberly_sumner_p4(g):
    """
    True if g is 2-connected, claw-free, and p4-free
    """
    return is_two_connected(g) and is_claw_free(g) and is_p4_free(g)

# Ronald Gould, Updating the Hamiltonian problem — a survey. Journal of Graph Theory 15.2: 121-157, 1991.
def is_matthews_sumner(g):
    """
    True if g is 2-connected, claw-free, and minimum-degree >= (order-1) / 3
    """
    return is_two_connected(g) and is_claw_free(g) and min_degree(g) >= (g.order() - 1) / 3
def is_broersma_veldman_gould(g):
    """
    True if g is 2-connected, claw-free, and diameter <= 2
    """
    return is_two_connected(g) and is_claw_free(g) and g.diameter() <= 2

def chvatals_condition(g):
    """
    True if g.order()>=3 and given increasing degrees d_1,..,d_n, for all i, i>=n/2 or d_i>i or d_{n-i}>=n-1

    This condition is based on Thm 1 of
    Chvátal, Václav. "On Hamilton's ideals." Journal of Combinatorial Theory, Series B 12.2 (1972): 163-168.

    [Chvatal, 72] also showed this condition is sufficient to imply g is Hamiltonian.
    """
    if g.order() < 3:
        return False
    degrees = g.degree()
    degrees.sort()
    n = g.order()
    return all(degrees[i] > i or i >= n/2 or degrees[n-i] >= n-i for i in range(0, len(degrees)))

def is_matching(g):
    """
    Returns True if this graph is the disjoint union of complete graphs of order 2.

    Tests:
        sage: is_matching(graphs.CompleteGraph(2))
        True
        sage: is_matching(graphs.PathGraph(4))
        False
        sage: is_matching(graphs.CompleteGraph(2).disjoint_union(graphs.CompleteGraph(2)))
        True
    """
    return min(g.degree())==1 and max(g.degree())==1

def has_odd_order(g):
    """
    True if the number of vertices in g is odd

    sage: has_odd_order(Graph(5))
    True
    sage: has_odd_order(Graph(2))
    False
    """
    return g.order() % 2 == 1

def has_even_order(g):
    """
    True if the number of vertices in g is even

    sage: has_even_order(Graph(5))
    False
    sage: has_even_order(Graph(2))
    True
    """
    return g.order() % 2 == 0

def is_maximal_triangle_free(g):
    """
    Evaluates whether graphs ``g`` is a maximal triangle-free graph

    Maximal triangle-free means that adding any edge to ``g`` will create a
    triangle.
    If ``g`` is not triangle-free, then returns ``False``.

    EXAMPLES:

        sage: is_maximal_triangle_free(graphs.CompleteGraph(2))
        True

        sage: is_maximal_triangle_free(graphs.CycleGraph(5))
        True

        sage: is_maximal_triangle_free(Graph('Esa?'))
        True

        sage: is_maximal_triangle_free(Graph('KsaCCA?_C?O?'))
        True

        sage: is_maximal_triangle_free(graphs.PathGraph(5))
        False

        sage: is_maximal_triangle_free(Graph('LQY]?cYE_sBOE_'))
        False

        sage: is_maximal_triangle_free(graphs.HouseGraph())
        False

    Edge cases ::

        sage: is_maximal_triangle_free(Graph(0))
        False

        sage: is_maximal_triangle_free(Graph(1))
        False

        sage: is_maximal_triangle_free(Graph(3))
        False
    """
    if not g.is_triangle_free():
        return False
    g_comp = g.complement()
    g_copy = g.copy()
    for e in g_comp.edges():
        g_copy.add_edge(e)
        if g.is_triangle_free():
            return False
        g_copy.delete_edge(e)
    return True

def is_locally_two_connected(g):
    """

    ALGORITHM:

    We modify the algorithm from our ``localise`` factory method to stop at
    subgraphs of 2 vertices, since ``is_two_connected`` is undefined on smaller
    subgraphs.
    """
    return all((f(g.subgraph(g.neighbors(v))) if len(g.neighbors(v)) >= 2
                                              else True) for v in g.vertices())

######################################################################################################################
#Below are some factory methods which create properties based on invariants or other properties

def has_equal_invariants(invar1, invar2, name=None):
    """
    This function takes two invariants as an argument and returns the property that these invariants are equal.
    Optionally a name for the new function can be provided as a third argument.
    """
    def equality_checker(g):
        return invar1(g) == invar2(g)

    if name is not None:
        equality_checker.__name__ = name
    elif hasattr(invar1, '__name__') and hasattr(invar2, '__name__'):
        equality_checker.__name__ = 'has_{}_equals_{}'.format(invar1.__name__, invar2.__name__)
    else:
        raise ValueError('Please provide a name for the new function')

    return equality_checker

"""
    sage: has_alpha_equals_clique_covering(graphs.CycleGraph(5))
    False
"""
has_alpha_equals_clique_covering = has_equal_invariants(independence_number, clique_covering_number, name="has_alpha_equals_clique_covering")


def has_invariant_equal_to(invar, value, name=None, documentation=None):
    """
    This function takes an invariant and a value as arguments and returns the property
    that the invariant value for a graph is equal to the provided value.

    Optionally a name and documentation for the new function can be provided.

    sage: order_is_five = has_invariant_equal_to(Graph.order, 5)
    sage: order_is_five(graphs.CycleGraph(5))
    True
    sage: order_is_five(graphs.CycleGraph(6))
    False
    """
    def equality_checker(g):
        return invar(g) == value

    if name is not None:
        equality_checker.__name__ = name
    elif hasattr(invar, '__name__'):
        equality_checker.__name__ = 'has_{}_equal_to_{}'.format(invar.__name__, value)
    else:
        raise ValueError('Please provide a name for the new function')

    equality_checker.__doc__ = documentation

    return equality_checker

def has_leq_invariants(invar1, invar2, name=None):
    """
    This function takes two invariants as an argument and returns the property that the first invariant is
    less than or equal to the second invariant.
    Optionally a name for the new function can be provided as a third argument.
    """
    def comparator(g):
        return invar1(g) <= invar2(g)

    if name is not None:
        comparator.__name__ = name
    elif hasattr(invar1, '__name__') and hasattr(invar2, '__name__'):
        comparator.__name__ = 'has_{}_leq_{}'.format(invar1.__name__, invar2.__name__)
    else:
        raise ValueError('Please provide a name for the new function')

    return comparator

#add all properties derived from pairs of invariants
invariant_relation_properties = [has_leq_invariants(f,g) for f in all_invariants for g in all_invariants if f != g]


def localise(f, name=None, documentation=None):
    """
    This function takes a property (i.e., a function taking only a graph as an argument) and
    returns the local variant of that property. The local variant is True if the property is
    True for the neighbourhood of each vertex and False otherwise.
    """
    #create a local version of f
    def localised_function(g):
        return all((f(g.subgraph(g.neighbors(v))) if g.neighbors(v) else True) for v in g.vertices())

    #we set a nice name for the new function
    if name is not None:
        localised_function.__name__ = name
    elif hasattr(f, '__name__'):
        if f.__name__.startswith('is_'):
            localised_function.__name__ = 'is_locally' + f.__name__[2:]
        elif f.__name__.startswith('has_'):
            localised_function.__name__ = 'has_locally' + f.__name__[2:]
        else:
            localised_function.__name__ = 'localised_' + f.__name__
    else:
        raise ValueError('Please provide a name for the new function')

    localised_function.__doc__ = documentation

    return localised_function

is_locally_dirac = localise(is_dirac)
is_locally_bipartite = localise(Graph.is_bipartite)
is_locally_planar = localise(Graph.is_planar, documentation="True if the open neighborhood of each vertex v is planar")
"""
Tests:
    sage: is_locally_unicyclic(graphs.OctahedralGraph())
    True
    sage: is_locally_unicyclic(graphs.BullGraph())
    False
"""
is_locally_unicyclic = localise(is_unicyclic, documentation="""A graph is locally unicyclic if all its local subgraphs are unicyclic.

Tests:
    sage: is_locally_unicyclic(graphs.OctahedralGraph())
    True
    sage: is_locally_unicyclic(graphs.BullGraph())
    False
""")
is_locally_connected = localise(Graph.is_connected, documentation="True if the neighborhood of every vertex is connected (stronger than claw-free)")
"""
sage: is_local_matching(graphs.CompleteGraph(3))
True
sage: is_local_matching(graphs.CompleteGraph(4))
False
sage: is_local_matching(graphs.FriendshipGraph(5))
True
"""
is_local_matching = localise(is_matching, name="is_local_matching", documentation="""True if the neighborhood of each vertex consists of independent edges.

Tests:
    sage: is_local_matching(graphs.CompleteGraph(3))
    True
    sage: is_local_matching(graphs.CompleteGraph(4))
    False
    sage: is_local_matching(graphs.FriendshipGraph(5))
    True
""")

######################################################################################################################

efficiently_computable_properties = [Graph.is_regular, Graph.is_planar,
Graph.is_forest, Graph.is_eulerian, Graph.is_connected, Graph.is_clique,
Graph.is_circular_planar, Graph.is_chordal, Graph.is_bipartite,
Graph.is_cartesian_product,Graph.is_distance_regular,  Graph.is_even_hole_free,
Graph.is_gallai_tree, Graph.is_line_graph, Graph.is_overfull, Graph.is_perfect,
Graph.is_split, Graph.is_strongly_regular, Graph.is_triangle_free,
Graph.is_weakly_chordal, is_dirac, is_ore,
is_generalized_dirac, is_van_den_heuvel, is_two_connected, is_three_connected,
is_lindquester, is_claw_free, Graph.has_perfect_matching, has_radius_equal_diameter,
is_not_forest, is_genghua_fan, is_cubic, diameter_equals_twice_radius,
is_locally_connected, matching_covered, is_locally_dirac,
is_locally_bipartite, is_locally_two_connected, Graph.is_interval, has_paw,
is_paw_free, has_p4, is_p4_free, has_dart, is_dart_free, has_kite, is_kite_free,
has_H, is_H_free, has_residue_equals_two, order_leq_twice_max_degree,
alpha_leq_order_over_two, is_factor_critical, is_independence_irreducible,
has_twin, is_twin_free, diameter_equals_two, girth_greater_than_2log, Graph.is_cycle,
pairs_have_unique_common_neighbor, has_star_center, is_complement_of_chordal,
has_c4, is_c4_free, is_subcubic, is_quasi_regular, is_bad, has_k4, is_k4_free,
is_distance_transitive, is_unicyclic, is_locally_unicyclic, has_simplical_vertex,
has_exactly_two_simplical_vertices, is_two_tree, is_locally_planar,
is_four_connected, is_claw_free_paw_free, has_bull, is_bull_free,
is_claw_free_bull_free, has_F, is_F_free, is_oberly_sumner, is_oberly_sumner_bull,
is_oberly_sumner_p4, is_matthews_sumner, chvatals_condition, is_matching, is_local_matching,
has_odd_order, has_even_order, Graph.is_circulant, Graph.has_loops,
Graph.is_asteroidal_triple_free, Graph.is_block_graph, Graph.is_cactus,
Graph.is_cograph, Graph.is_long_antihole_free, Graph.is_long_hole_free, Graph.is_partial_cube,
Graph.is_polyhedral, Graph.is_prime, Graph.is_tree, Graph.is_apex, Graph.is_arc_transitive,
Graph.is_self_complementary, is_double_clique, has_fork, is_fork_free,
has_empty_KE_part]

intractable_properties = [Graph.is_hamiltonian, Graph.is_vertex_transitive,
Graph.is_edge_transitive, has_residue_equals_alpha, Graph.is_odd_hole_free,
Graph.is_semi_symmetric, is_planar_transitive, is_class1,
is_class2, is_anti_tutte, is_anti_tutte2, has_lovasz_theta_equals_cc,
has_lovasz_theta_equals_alpha, is_chvatal_erdos, is_heliotropic_plant,
is_geotropic_plant, is_traceable, is_chordal_or_not_perfect,
has_alpha_residue_equal_two, is_complement_hamiltonian, is_1_tough, is_2_tough,
has_two_ham_cycles, is_two_path, is_prism_hamiltonian, is_bauer, is_jung,
is_weakly_pancyclic, is_pancyclic, has_two_walk, has_alpha_equals_clique_covering,
Graph.is_transitively_reduced, Graph.is_half_transitive, Graph.is_line_graph,
is_haggkvist_nicoghossian, is_chromatic_index_critical]

removed_properties = [is_pebbling_class0]

"""
    Last version of graphs packaged checked: Sage 8.2
    This means checked for new functions, and for any errors/changes in old functions!
    sage: sage.misc.banner.version_dict()['major'] < 8 or (sage.misc.banner.version_dict()['major'] == 8 and sage.misc.banner.version_dict()['minor'] <= 2)
    True

    Skip Graph.is_circumscribable() and Graph.is_inscribable() because they
        throw errors for the vast majority of our graphs.
    Skip Graph.is_biconnected() in favor of our is_two_connected(), because we
        prefer our name, and because we disagree with their definition on K2.
        We define that K2 is NOT 2-connected, it is n-1 = 1 connected.
    Implementation of Graph.is_line_graph() is intractable, despite a theoretically efficient algorithm existing.
"""
sage_properties = [Graph.is_hamiltonian, Graph.is_eulerian, Graph.is_planar,
Graph.is_circular_planar, Graph.is_regular, Graph.is_chordal, Graph.is_circulant,
Graph.is_interval, Graph.is_gallai_tree, Graph.is_clique, Graph.is_cycle,
Graph.is_transitively_reduced, Graph.is_self_complementary, Graph.is_connected,
Graph.has_loops, Graph.is_asteroidal_triple_free, Graph.is_bipartite,
Graph.is_block_graph, Graph.is_cactus, Graph.is_cartesian_product,
Graph.is_cograph, Graph.is_distance_regular, Graph.is_edge_transitive, Graph.is_even_hole_free,
Graph.is_forest, Graph.is_half_transitive, Graph.is_line_graph,
Graph.is_long_antihole_free, Graph.is_long_hole_free, Graph.is_odd_hole_free,
Graph.is_overfull, Graph.is_partial_cube, Graph.is_polyhedral, Graph.is_prime,
Graph.is_semi_symmetric, Graph.is_split, Graph.is_strongly_regular, Graph.is_tree,
Graph.is_triangle_free, Graph.is_weakly_chordal, Graph.has_perfect_matching, Graph.is_apex,
Graph.is_arc_transitive]

#speed notes
#FAST ENOUGH (tested for graphs on 140921): is_hamiltonian, is_vertex_transitive,
#    is_edge_transitive, has_residue_equals_alpha, is_odd_hole_free, is_semi_symmetric,
#    is_line_graph, is_line_graph, is_anti_tutte, is_planar_transitive
#SLOW but FIXED for SpecialGraphs: is_class1, is_class2

properties = efficiently_computable_properties + intractable_properties
properties_plus = efficiently_computable_properties + intractable_properties + invariant_relation_properties


invariants_from_properties = [make_invariant_from_property(property) for property in properties]
invariants_plus = all_invariants + invariants_from_properties

# weakly_chordal = weakly chordal, i.e., the graph and its complement have no induced cycle of length at least 5

print("loaded properties")

#############################################################################
# End of properties section                                                 #
#############################################################################
# THEORY
all_invariant_theorems = []
all_property_theorems = []

alpha_upper_bounds = []
alpha_lower_bounds = []

hamiltonian_sufficient = []

#####
# ALPHA UPPER BOUNDS
#####

# R. Pepper. Binding independence. Ph. D. Dissertation. University of Houston. Houston, TX, 2004.
alpha_annihilation_bound = annihilation_number
add_to_lists(alpha_annihilation_bound, alpha_upper_bounds, all_invariant_theorems)

# Nemhauser, George L., and Leslie Earl Trotter. "Vertex packings: structural properties and algorithms." Mathematical Programming 8.1 (1975): 232-248.
# Nemhauser, George L., and Leslie E. Trotter. "Properties of vertex packing and independence system polyhedra." Mathematical Programming 6.1 (1974): 48-61.
alpha_fractional_bound = fractional_alpha
add_to_lists(alpha_fractional_bound, alpha_upper_bounds, all_invariant_theorems)

# D. M. Cvetkovic, M. Doob, and H. Sachs. Spectra of graphs. Academic Press, New York, 1980.
alpha_cvetkovic_bound = cvetkovic
add_to_lists(alpha_cvetkovic_bound, alpha_upper_bounds, all_invariant_theorems)

# Trivial
alpha_trivial_bound = Graph.order
add_to_lists(alpha_trivial_bound, alpha_upper_bounds, all_invariant_theorems)

# Lovasz Theta
alpha_lovasz_theta_bound = Graph.lovasz_theta
add_to_lists(alpha_lovasz_theta_bound, alpha_upper_bounds, all_invariant_theorems)

# R. Pepper. Binding independence. Ph. D. Dissertation. University of Houston. Houston, TX, 2004.
def alpha_kwok_bound(g):
    return order(g) - (g.size()/max_degree(g))
add_to_lists(alpha_kwok_bound, alpha_upper_bounds, all_invariant_theorems)

# P. Hansen and M. Zheng. Sharp Bounds on the order, size, and stability number of graphs. NETWORKS 23 (1993), no. 2, 99-102.
def alpha_hansen_bound(g):
    return floor(1/2 + sqrt(1/4 + order(g)**2 - order(g) - 2*size(g)))
add_to_lists(alpha_hansen_bound, alpha_upper_bounds, all_invariant_theorems)

# Matching Number - Folklore
def alpha_matching_number_bound(g):
    return order(g) - matching_number(g)
add_to_lists(alpha_matching_number_bound, alpha_upper_bounds, all_invariant_theorems)

# Min-Degree Theorm
def alpha_min_degree_bound(g):
    return order(g) - min_degree(g)
add_to_lists(alpha_min_degree_bound, alpha_upper_bounds, all_invariant_theorems)

# Cut Vertices Theorem
# Three Bounds on the Independence Number of a Graph - C. E. Larson, R. Pepper
def alpha_cut_vertices_bound(g):
    return (g.order() - (card_cut_vertices(g)/2) - (1/2))
add_to_lists(alpha_cut_vertices_bound, alpha_upper_bounds, all_invariant_theorems)

# Median Degree Theorem
# Three Bounds on the Independence Number of a Graph - C. E. Larson, R. Pepper
def alpha_median_degree_bound(g):
    return (g.order() - (median_degree(g)/2) - 1/2)
add_to_lists(alpha_median_degree_bound, alpha_upper_bounds, all_invariant_theorems)

# Godsil-Newman Upper Bound theorem
# Godsil, Chris D., and Mike W. Newman. "Eigenvalue bounds for independent sets." Journal of Combinatorial Theory, Series B 98.4 (2008): 721-734.
def alpha_godsil_newman_bound(g):
    L = max(g.laplacian_matrix().change_ring(RDF).eigenvalues())
    return g.order()*(L-min_degree(g))/L
add_to_lists(alpha_godsil_newman_bound, alpha_upper_bounds, all_invariant_theorems)

# AGX Upper Bound Theorem
#Aouchiche, Mustapha, Gunnar Brinkmann, and Pierre Hansen. "Variable neighborhood search for extremal graphs. 21. Conjectures and results about the independence number." Discrete Applied Mathematics 156.13 (2008): 2530-2542.
def alpha_AGX_upper_bound(g):
    return (g.order() + max_degree(g) - ceil(2 * sqrt(g.order() - 1)))
add_to_lists(alpha_AGX_upper_bound, alpha_upper_bounds, all_invariant_theorems)

def alpha_li_zhang_1_bound(g):
    """
    From:
    A note on eigenvalue bounds for independence numbers of non-regular graphs
    By Yusheng Li, Zhen Zhang
    """
    return (((max_degree(g)) - min_degree(g) - min_eigenvalue(g)) / max_degree(g)) * g.order()
add_to_lists(alpha_li_zhang_1_bound, alpha_upper_bounds, all_invariant_theorems)

def alpha_li_zhang_2_bound(g):
    """
    From:
    A note on eigenvalue bounds for independence numbers of non-regular graphs
    By Yusheng Li, Zhen Zhang
    """
    return ((max_eigenvalue(g) - min_eigenvalue(g) + max_degree(g) - 2 * min_degree(g)) / (max_eigenvalue(g) - min_eigenvalue(g) + max_degree(g) - min_degree(g))) * g.order()
add_to_lists(alpha_li_zhang_2_bound, alpha_upper_bounds, all_invariant_theorems)

def alpha_haemers_bound(g):
    """
    From: W. Haemers, Interlacing eigenvalues and graphs, Linear Algebra Appl. 226/228 (1995) 593–616.
    """
    return ((-max_eigenvalue(g) * min_eigenvalue(g)) / (min_degree(g)**2 - (max_eigenvalue(g) * min_eigenvalue(g)))) * g.order()
add_to_lists(alpha_haemers_bound, alpha_upper_bounds, all_invariant_theorems)

#####
# LOWER BOUNDS
#####

# Radius Pendants Theorem
# Three Bounds on the Independence Number of a Graph - C. E. Larson, R. Pepper
def alpha_radius_pendants_bound(g):
    return (g.radius() + (card_pendants(g)/2) - 1)
add_to_lists(alpha_radius_pendants_bound, alpha_lower_bounds, all_invariant_theorems)

# AGX Lower Bound Theorem
# Aouchiche, Mustapha, Gunnar Brinkmann, and Pierre Hansen. "Variable neighborhood search for extremal graphs. 21. Conjectures and results about the independence number." Discrete Applied Mathematics 156.13 (2008): 2530-2542.
def alpha_AGX_lower_bound(g):
    return ceil(2 * sqrt(g.order()))
add_to_lists(alpha_AGX_lower_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_max_degree_minus_triangles_bound(g):
    return max_degree(g) - g.triangles_count()
add_to_lists(alpha_max_degree_minus_triangles_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_order_brooks_bound(g):
    return ceil(g.order()/brooks(g))
add_to_lists(alpha_order_brooks_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_szekeres_wilf_bound(g):
    return ceil(g.order()/szekeres_wilf(g))
add_to_lists(alpha_szekeres_wilf_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_welsh_powell_bound(g):
    return ceil(g.order()/welsh_powell(g))
add_to_lists(alpha_welsh_powell_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_staton_girth_bound(g):
    """
    Hopkins, Glenn, and William Staton. "Girth and independence ratio." Can. Math. Bull. 25.2 (1982): 179-186.
    """
    if g.girth() < 6:
        return 1
    else:
        d = max_degree(g)
        return order(g) * (2* d - 1) / (d*d + 2 * d - 1)
add_to_lists(alpha_staton_girth_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_staton_triangle_free_bound(g):
    """
    Staton, William. "Some Ramsey-type numbers and the independence ratio." Transactions of the American Mathematical Society 256 (1979): 353-370.
    """
    if g.is_triangle_free() and (max_degree(g) > 2):
        return (5 * g.order() ) / ((5 * max_degree(g)) - 1)
    return 1
add_to_lists(alpha_staton_triangle_free_bound, alpha_lower_bounds, all_invariant_theorems)

alpha_average_distance_bound = Graph.average_distance
add_to_lists(alpha_average_distance_bound, alpha_lower_bounds, all_invariant_theorems)

alpha_radius_bound = Graph.radius
add_to_lists(alpha_radius_bound, alpha_lower_bounds, all_invariant_theorems)

alpha_residue_bound = residue
add_to_lists(alpha_residue_bound, alpha_lower_bounds, all_invariant_theorems)

alpha_max_even_minus_even_horizontal_bound = max_even_minus_even_horizontal
add_to_lists(alpha_max_even_minus_even_horizontal_bound, alpha_lower_bounds, all_invariant_theorems)

alpha_critical_independence_number_bound = critical_independence_number
add_to_lists(alpha_critical_independence_number_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_max_degree_minus_number_of_triangles_bound(g):
    return max_degree(g) - g.triangles_count()
add_to_lists(alpha_max_degree_minus_number_of_triangles_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_HHRS_bound(g):
    """
    Returns 1 if max_degree > 3 or if g has k4 as a subgraph
    ONLY WORKS FOR CONNECTED GRAPHS becasue that is what we are focussing on, disconnected graphs just need to count the bad compenents

    Harant, Jochen, et al. "The independence number in graphs of maximum degree three." Discrete Mathematics 308.23 (2008): 5829-5833.
    """
    assert(g.is_connected() == true)
    if not is_subcubic(g):
        return 1
    if has_k4(g):
        return 1
    return (4*g.order() - g.size() - (1 if is_bad(g) else 0) - subcubic_tr(g)) / 7
add_to_lists(alpha_HHRS_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_seklow_bound(g):
    """
    Returns the Seklow bound from:
    Selkow, Stanley M. "A probabilistic lower bound on the independence number of graphs." Discrete Mathematics 132.1-3 (1994): 363-365.
    """
    v_sum = 0
    for v in g.vertices():
        d = g.degree(v)
        v_sum += ((1/(d + 1)) * (1 + max(0, (d/(d + 1) - sum([(1/(g.degree(w) + 1)) for w in g.neighbors(v)])))))
    return v_sum
add_to_lists(alpha_seklow_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_harant_bound(g):
    """
    From:
    A lower bound on the independence number of a graph
    Jochen Harant
    """
    return (caro_wei(g)**2) / (caro_wei(g) - sum([(g.degree(e[0]) - g.degree(e[1]))**2 * (1/g.degree(e[0]))**2 * (1/g.degree(e[1]))**2 for e in g.edges()]))
add_to_lists(alpha_harant_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_harant_schiermeyer_bound(g):
    """
    From:
    On the independence number of a graph in terms of order and size
    By J. Harant and I. Schiermeyerb
    """
    order = g.order()
    t = 2*g.size() + order + 1
    return (t - sqrt(t**2 - 4 * order**2)) / 2
add_to_lists(alpha_harant_schiermeyer_bound, alpha_lower_bounds, all_invariant_theorems)

def alpha_shearer_bound(g):
    """
    From:
    Shearer, James B. "The independence number of dense graphs with large odd girth." Electron. J. Combin 2.2 (1995).
    """
    girth = g.girth()

    if girth == +Infinity:
        return 1.0
    if is_even(girth):
        return 1.0

    k = ((girth - 1) / 2.0)
    v_sum = sum([g.degree(v)**(1/(k - 1.0)) for v in g.vertices()])
    return 2**(-((k - 1.0)/k)) * v_sum**((k - 1.0)/k)
add_to_lists(alpha_shearer_bound, alpha_lower_bounds, all_invariant_theorems)


####
# HAMILTONICITY SUFFICIENT CONDITIONS
####
# Chvátal, V., & Erdös, P. (1972). A note on hamiltonian circuits. Discrete Mathematics, 2(2), 111-113.
add_to_lists(is_chvatal_erdos, hamiltonian_sufficient, all_property_theorems)

# R.J Faudree, Ronald J Gould, Michael S Jacobson, R.H Schelp, Neighborhood unions and hamiltonian properties in graphs, Journal of Combinatorial Theory, Series B, Volume 47, Issue 1, 1989, Pages 1-9
add_to_lists(is_generalized_dirac, hamiltonian_sufficient, all_property_theorems)

# Häggkvist, Roland & Nicoghossian, G. G. (1981). A remark on hamiltonian cycles. Journal of Combinatorial Theory, 30(1), 118-120
add_to_lists(is_haggkvist_nicoghossian, hamiltonian_sufficient, all_property_theorems)

# Fan, G. H. (1984). New sufficient conditions for cycles in graphs. Journal of Combinatorial Theory, 37(3), 221-227.
add_to_lists(is_genghua_fan, hamiltonian_sufficient, all_property_theorems)

# Lindquester, T. E. (1989). The effects of distance and neighborhood union conditions on hamiltonian properties in graphs. Journal of Graph Theory, 13(3), 335-352.
# Ore, Ø. (1960), "Note on Hamilton circuits", American Mathematical Monthly, 67 (1): 55, doi:10.2307/2308928, JSTOR 2308928.
def is_lindquester_or_is_ore(g):
    return is_lindquester(g) or is_ore(g)
add_to_lists(is_lindquester_or_is_ore, hamiltonian_sufficient, all_property_theorems)

# Trivial / "belongs to folklore"
def is_cycle_or_is_clique(g):
    return is_cycle(g) or g.is_clique()
add_to_lists(is_cycle_or_is_clique, hamiltonian_sufficient, all_property_theorems)

# Geng-Hua Fan. "New Sufficient Conditions for Cycles in Graphs". Journal of Combinatorial Theory 37.3(1984):221-227.
def sigma_dist2_geq_half_n(g):
    return sigma_dist2(g) >= g.order()/2
add_to_lists(sigma_dist2_geq_half_n, hamiltonian_sufficient, all_property_theorems)

# Bauer, Douglas, et al. "Long cycles in graphs with large degree sums." Discrete Mathematics 79.1 (1990): 59-70.
add_to_lists(is_bauer, hamiltonian_sufficient, all_property_theorems)

# Jung, H. A. "On maximal circuits in finite graphs." Annals of Discrete Mathematics. Vol. 3. Elsevier, 1978. 129-144.
add_to_lists(is_jung, hamiltonian_sufficient, all_property_theorems)

# S. Goodman and S. Hedetniemi, Sufficient Conditions for a Graph to Be Hamiltonian. Journal of Combinatorial Theory 16: 175--180, 1974.
def is_two_connected_claw_free_paw_free(g):
    return is_two_connected(g) and is_claw_free_paw_free(g)
add_to_lists(is_claw_free_paw_free, hamiltonian_sufficient, all_property_theorems)

# Ronald Gould, Updating the Hamiltonian problem — a survey. Journal of Graph Theory 15.2: 121-157, 1991.
add_to_lists(is_oberly_sumner, hamiltonian_sufficient, all_property_theorems)
add_to_lists(is_oberly_sumner_bull, hamiltonian_sufficient, all_property_theorems)
add_to_lists(is_oberly_sumner_p4, hamiltonian_sufficient, all_property_theorems)
add_to_lists(is_matthews_sumner, hamiltonian_sufficient, all_property_theorems)
add_to_lists(is_broersma_veldman_gould, hamiltonian_sufficient, all_property_theorems)

# Chvátal, Václav. "On Hamilton's ideals." Journal of Combinatorial Theory, Series B 12.2 (1972): 163-168.
add_to_lists(chvatals_condition, hamiltonian_sufficient, all_property_theorems)


####
# HAMILTONICITY NECESSARY CONDITIONS
####

print("loaded theorems")

#############################################################################
# End of theorems section                                                   #
#############################################################################
# Graph Lists

graph_objects = []
alpha_critical_easy = []
alpha_critical_hard = []
chromatic_index_critical = []
chromatic_index_critical_7 = []
class0graphs = []
class0small = []
counter_examples = []
problem_graphs = []
non_connected_graphs = []
dimacs_graphs = []
all_graphs = []

# HexahedralGraph is CE to (((is_planar)&(is_regular))&(is_bipartite))->(has_residue_equals_alpha)
# WagnerGraph is a graph for which the Cvetkovic bound is the best upper bound present in the Willis Thesis
# OctohedralGraph is a graph for which the minimum degree is the best upper bound present in the Willis thesis
# BidiakisCube is a graph where none of the upper or lower bounds in the Willis thesis give the exact value for alpha
# TetrahedralGraph and MoserSpindle in the alpha critical list as "C~" and "FzEKW" respectively
# MeredithGraph and SchlaefliGraph are in the Problem Graphs list

sage_graphs = [graphs.BullGraph(), graphs.ButterflyGraph(), graphs.ClawGraph(),
graphs.DiamondGraph(), graphs.HouseGraph(), graphs.HouseXGraph(), graphs.Balaban10Cage(),
graphs.Balaban11Cage(), graphs.BidiakisCube(),
graphs.BiggsSmithGraph(), graphs.BlanusaFirstSnarkGraph(), graphs.BlanusaSecondSnarkGraph(),
graphs.BrinkmannGraph(), graphs.BrouwerHaemersGraph(), graphs.BuckyBall(),
graphs.ChvatalGraph(), graphs.ClebschGraph(),
graphs.CoxeterGraph(), graphs.DesarguesGraph(), graphs.DejterGraph(), graphs.DoubleStarSnark(),
graphs.DurerGraph(), graphs.DyckGraph(), graphs.EllinghamHorton54Graph(),
graphs.EllinghamHorton78Graph(), graphs.ErreraGraph(), graphs.F26AGraph(), graphs.FlowerSnark(),
graphs.FolkmanGraph(), graphs.FosterGraph(), graphs.FranklinGraph(), graphs.FruchtGraph(),
graphs.GoldnerHararyGraph(), graphs.GossetGraph(), graphs.GrayGraph(), graphs.GrotzschGraph(),
graphs.HallJankoGraph(), graphs.HarborthGraph(), graphs.HarriesGraph(), graphs.HarriesWongGraph(),
graphs.HeawoodGraph(), graphs.HerschelGraph(), graphs.HigmanSimsGraph(), graphs.HoffmanGraph(),
graphs.HoffmanSingletonGraph(), graphs.HoltGraph(), graphs.HortonGraph(), graphs.JankoKharaghaniTonchevGraph(), graphs.KittellGraph(),
graphs.KrackhardtKiteGraph(), graphs.Klein3RegularGraph(), graphs.Klein7RegularGraph(),
graphs.LjubljanaGraph(),
graphs.MarkstroemGraph(), graphs.McGeeGraph(),
graphs.MoebiusKantorGraph(), graphs.NauruGraph(), graphs.PappusGraph(),
graphs.PoussinGraph(), graphs.PerkelGraph(), graphs.PetersenGraph(), graphs.RobertsonGraph(),
graphs.ShrikhandeGraph(), graphs.SimsGewirtzGraph(),
graphs.SousselierGraph(), graphs.SylvesterGraph(), graphs.SzekeresSnarkGraph(),
graphs.ThomsenGraph(), graphs.TietzeGraph(),
graphs.TruncatedTetrahedralGraph(), graphs.Tutte12Cage(), graphs.TutteCoxeterGraph(),
graphs.TutteGraph(), graphs.WagnerGraph(), graphs.WatkinsSnarkGraph(), graphs.WellsGraph(),
graphs.WienerArayaGraph(),
graphs.HexahedralGraph(), graphs.DodecahedralGraph(), graphs.OctahedralGraph(), graphs.IcosahedralGraph()]

try:
    add_to_lists(graphs.CameronGraph(), sage_graphs)
except Exception as e:
    print("The Cameron graph was not loaded. Caused by:")
    print(e)

try:
    add_to_lists(graphs.M22Graph(), sage_graphs)
except Exception as e:
    print("The M22 graph was not loaded. Caused by:")
    print(e)

try:
    add_to_lists(graphs.TruncatedIcosidodecahedralGraph(), sage_graphs)
except Exception as e:
    print("The truncated icosidodecahedral graph was not loaded. Caused by:")
    print(e)

try:
    add_to_lists(graphs.McLaughlinGraph(), sage_graphs)
except Exception as e:
    print("The McLaughlin graph was not loaded. Caused by:")
    print(e)

try:
    add_to_lists(graphs.LocalMcLaughlinGraph(), sage_graphs)
except Exception as e:
    print("The local McLaughlin graph was not loaded. Caused by:")
    print(e)

#hard built-in Sage graphs
add_to_lists(graphs.IoninKharaghani765Graph(), problem_graphs, all_graphs)


#These built in graphs are nameless so here they are given names

try:
    cell120 = graphs.Cell120()
    cell120.name(new = "Cell120")
    add_to_lists(cell120, sage_graphs)
except Exception as e:
    print("The graph of the 120-cell was not loaded. Caused by:")
    print(e)

try:
    cell600 = graphs.Cell600()
    cell600.name(new = "Cell600")
    add_to_lists(cell600, sage_graphs)
except Exception as e:
    print("The graph of the 600-cell was not loaded. Caused by:")
    print(e)

mathon_strongly_regular0 = graphs.MathonStronglyRegularGraph(0)
mathon_strongly_regular0.name(new = "Mathon Strongly Regular Graph 0")

mathon_strongly_regular1 = graphs.MathonStronglyRegularGraph(1)
mathon_strongly_regular1.name(new = "Mathon Strongly Regular Graph 1")

mathon_strongly_regular2 = graphs.MathonStronglyRegularGraph(2)
mathon_strongly_regular2.name(new = "Mathon Strongly Regular Graph 2")

janko_kharaghani936 = graphs.JankoKharaghaniGraph(936)
janko_kharaghani936.name(new = "Janko-Kharaghani 936")

# janko_kharaghani1800 = graphs.JankoKharaghaniGraph(1800) # Causes memory error when doctesting. Waiting for fix in Sage.
# janko_kharaghani1800.name(new = "Janko-Kharagani 1800")

for graph in sage_graphs + [mathon_strongly_regular0, mathon_strongly_regular1, mathon_strongly_regular2, janko_kharaghani936]:
    add_to_lists(graph, graph_objects, all_graphs)

# Meredith graph is 4-reg, class2, non-hamiltonian: http://en.wikipedia.org/wiki/Meredith_graph
add_to_lists(graphs.MeredithGraph(), problem_graphs, all_graphs)
add_to_lists(graphs.SchlaefliGraph(), problem_graphs, all_graphs)

# A graph is alpha_critical if removing any edge increases independence number
# All alpha critical graphs of orders 2 to 9, 53 in total

# "E|OW" is CE to (has_alpha_residue_equal_two)->((is_perfect)|(is_regular))

alpha_critical_graph_names = ['A_','Bw', 'C~', 'Dhc', 'D~{', 'E|OW', 'E~~w', 'FhCKG', 'F~[KG',
'FzEKW', 'Fn[kG', 'F~~~w', 'GbL|TS', 'G~?mvc', 'GbMmvG', 'Gb?kTG', 'GzD{Vg', 'Gb?kR_', 'GbqlZ_',
'GbilZ_', 'G~~~~{', 'GbDKPG', 'HzCGKFo', 'H~|wKF{', 'HnLk]My', 'HhcWKF_', 'HhKWKF_', 'HhCW[F_',
'HxCw}V`', 'HhcGKf_', 'HhKGKf_', 'Hh[gMEO', 'HhdGKE[', 'HhcWKE[', 'HhdGKFK', 'HhCGGE@', 'Hn[gGE@',
'Hn^zxU@', 'HlDKhEH', 'H~~~~~~', 'HnKmH]N', 'HnvzhEH', 'HhfJGE@', 'HhdJGM@', 'Hj~KHeF', 'HhdGHeB',
'HhXg[EO', 'HhGG]ES', 'H~Gg]f{', 'H~?g]vs', 'H~@w[Vs', 'Hn_k[^o']

for s in alpha_critical_graph_names:
    g = Graph(s)
    g.name(new="alpha_critical_"+ s)
    add_to_lists(g, alpha_critical_easy, graph_objects, all_graphs)

# All order-7 chromatic_index_critical_graphs (and all are overfull)
n7_chromatic_index_critical_names = ['FhCKG', 'FzCKW', 'FzNKW', 'FlSkG', 'Fn]kG', 'FlLKG', 'FnlkG', 'F~|{G', 'FnlLG', 'F~|\\G',
'FnNLG', 'F~^LW', 'Fll\\G', 'FllNG', 'F~l^G', 'F~|^w', 'F~~^W', 'Fnl^W', 'FlNNG', 'F|\\Kg',
'F~^kg', 'FlKMG']

for s in n7_chromatic_index_critical_names:
    g=Graph(s)
    g.name(new="chromatic_index_critical_7_" + s)
    add_to_lists(g, chromatic_index_critical, chromatic_index_critical_7, problem_graphs, all_graphs)

alpha_critical_hard = [Graph('Hj\\x{F{')]
for g in alpha_critical_hard:
    add_to_lists(g, problem_graphs, all_graphs)

# Graph objects

p3 = graphs.PathGraph(3)
p3.name(new = "p3")
add_to_lists(p3, graph_objects, all_graphs)

p4 = graphs.PathGraph(4)
p4.name(new="p4")
add_to_lists(p4, graph_objects, all_graphs)

p5 = graphs.PathGraph(5)
p5.name(new = "p5")
add_to_lists(p5, graph_objects, all_graphs)

p6 = graphs.PathGraph(6)
p6.name(new="p6")
add_to_lists(p6, graph_objects, all_graphs)

"""
CE to independence_number(x) <= e^(cosh(max_degree(x) - 1))
 and to
independence_number(x) <= max_degree(x)*min_degree(x) + card_periphery(x)
"""
p9 = graphs.PathGraph(9)
p9.name(new = "p9")
add_to_lists(p9, graph_objects, counter_examples, all_graphs)

"""
P29 is a CE to independence_number(x) <=degree_sum(x)/sqrt(card_negative_eigenvalues(x))
 and to
<= max_degree(x)^e^card_center(x)
 and to
<= max_degree(x)^2 + card_periphery(x)
"""
p29 = graphs.PathGraph(29)
p29.name(new = "p29")
add_to_lists(p29, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= 2*cvetkovic(x)*log(10)/log(x.size())
p102 = graphs.PathGraph(102)
p102.name(new = "p102")
add_to_lists(p102, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x)<=welsh_powell(x)^e^different_degrees(x)
p6707 = graphs.PathGraph(6707)
p6707.name(new = "p6707")

c4 = graphs.CycleGraph(4)
c4.name(new="c4")
add_to_lists(c4, graph_objects, all_graphs)

c6 = graphs.CycleGraph(6)
c6.name(new = "c6")
add_to_lists(c6, graph_objects, all_graphs)

# CE to independence_number(x) <= (e^welsh_powell(x) - graph_rank(x))^2
c22 = graphs.CycleGraph(22)
c22.name(new = "c22")
add_to_lists(c22, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= minimum(cvetkovic(x), 2*e^sum_temperatures(x))
c34 = graphs.CycleGraph(34)
c34.name(new = "c34")
add_to_lists(c34, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= residue(x)^(degree_sum(x)^density(x))
c102 = graphs.CycleGraph(102)
c102.name(new = "c102")
add_to_lists(c102, graph_objects, counter_examples, all_graphs)

"""
Sage defines circulant graphs without the cycle, whereas the paper defines it with the cycle
From:
Brimkov, Valentin. "Algorithmic and explicit determination of the Lovasz number for certain circulant graphs." Discrete Applied Mathematics 155.14 (2007): 1812-1825.
"""
c13_2 = graphs.CirculantGraph(13, 2)
c13_2.add_cycle(range(13))
c13_2.name(new = "c13_2")
add_to_lists(c13_2, graph_objects, all_graphs)

k3 = alpha_critical_easy[1]
k4 = alpha_critical_easy[2]

k10 = graphs.CompleteGraph(10)
k10.name(new="k10")
add_to_lists(k10, graph_objects, all_graphs)

# CE to independence_number(x) >= floor(tan(floor(gutman_energy(x))))
k37 = graphs.CompleteGraph(37)
k37.name(new = "k37")
add_to_lists(k37, graph_objects, counter_examples, all_graphs)

# Lipták, László, and László Lovász. "Critical facets of the stable set polytope." Combinatorica 21.1 (2001): 61-88.
k1_4 = graphs.CompleteBipartiteGraph(1, 4)
k1_4.name(new = "k1_4")
add_to_lists(k1_4, graph_objects, all_graphs)

# A 4 ray star with each ray subdivided into two edges
# Lipták, László, and László Lovász. "Critical facets of the stable set polytope." Combinatorica 21.1 (2001): 61-88.
k1_4_sub2 = Graph("H?EA@?^")
k1_4_sub2.name(new = "k1_4_sub2")
add_to_lists(k1_4_sub2, graph_objects, all_graphs)

# CE to independence_number(x) <= minimum(lovasz_theta(x), 2*e^sum_temperatures(x))
#   and to
# independence_number(x) <= minimum(floor(lovasz_theta(x)), 2*e^sum_temperatures(x))
#   and to
# independence_number(x) >= -brinkmann_steffen(x) + 1/2*card_center(x)
k1_9 = graphs.CompleteBipartiteGraph(1,9)
k1_9.name(new = "k1_9")
add_to_lists(k1_9, graph_objects, counter_examples, all_graphs)

# The line graph of k3,3
k3_3_line_graph = graphs.CompleteBipartiteGraph(3, 3).line_graph()
k3_3_line_graph.name(new = "k3_3 line graph")
add_to_lists(k3_3_line_graph, graph_objects, all_graphs)

k5_3=graphs.CompleteBipartiteGraph(5,3)
k5_3.name(new = "k5_3")
add_to_lists(k5_3, graph_objects, all_graphs)

# CE to independence_number(x) <= diameter^(max_degree-1)
# diameter is 16, Delta=3, alpha = 341
bt2_8 = graphs.BalancedTree(2,8)
bt2_8.name(new = "bt2_8")
add_to_lists(bt2_8, graph_objects, counter_examples, all_graphs)

#two c4's joined at a vertex
c4c4=graphs.CycleGraph(4)
for i in [4,5,6]:
    c4c4.add_vertex()
c4c4.add_edge(3,4)
c4c4.add_edge(5,4)
c4c4.add_edge(5,6)
c4c4.add_edge(6,3)
c4c4.name(new="c4c4")
add_to_lists(c4c4, graph_objects, all_graphs)

#two c5's joined at a vertex: eulerian, not perfect, not hamiltonian
c5c5=graphs.CycleGraph(5)
for i in [5,6,7,8]:
    c5c5.add_vertex()
c5c5.add_edge(0,5)
c5c5.add_edge(0,8)
c5c5.add_edge(6,5)
c5c5.add_edge(6,7)
c5c5.add_edge(7,8)
c5c5.name(new="c5c5")
add_to_lists(c5c5, graph_objects, all_graphs)

K4a=graphs.CompleteGraph(4)
K4b=graphs.CompleteGraph(4)
K4a.delete_edge(0,1)
K4b.delete_edge(0,1)
regular_non_trans = K4a.disjoint_union(K4b)
regular_non_trans.add_edge((0,0),(1,1))
regular_non_trans.add_edge((0,1),(1,0))
regular_non_trans.name(new="regular_non_trans")
add_to_lists(regular_non_trans, graph_objects, all_graphs)

c6ee = graphs.CycleGraph(6)
c6ee.add_edges([(1,5), (2,4)])
c6ee.name(new="c6ee")
add_to_lists(c6ee, graph_objects, all_graphs)

#c6ee plus another chord: hamiltonian, regular, vertex transitive
c6eee = copy(c6ee)
c6eee.add_edge(0,3)
c6eee.name(new="c6eee")
add_to_lists(c6eee, graph_objects, all_graphs)

#c8 plus one long vertical chord and 3 parallel horizontal chords
c8chorded = graphs.CycleGraph(8)
c8chorded.add_edge(0,4)
c8chorded.add_edge(1,7)
c8chorded.add_edge(2,6)
c8chorded.add_edge(3,5)
c8chorded.name(new="c8chorded")
add_to_lists(c8chorded, graph_objects, all_graphs)

#c8 plus 2 parallel chords: hamiltonian, tri-free, not vertex-transitive
c8chords = graphs.CycleGraph(8)
c8chords.add_edge(1,6)
c8chords.add_edge(2,5)
c8chords.name(new="c8chords")
add_to_lists(c8chords, graph_objects, all_graphs)

# C10 with an edge through the center
c10e = graphs.CycleGraph(10)
c10e.add_edge(0,5)
c10e.name(new = "c10e")
add_to_lists(c10e, graph_objects, all_graphs)

# C10e with another edge through center
c10ee = graphs.CycleGraph(10)
c10ee.add_edges([(0,5), (9, 4)])
c10ee.name(new = "c10ee")
add_to_lists(c10ee, graph_objects, all_graphs)

prismsub = graphs.CycleGraph(6)
prismsub.add_edge(0,2)
prismsub.add_edge(3,5)
prismsub.add_edge(1,4)
prismsub.subdivide_edge(1,4,1)
prismsub.name(new="prismsub")
add_to_lists(prismsub, graph_objects, all_graphs)

# ham, not vertex trans, tri-free, not cartesian product
prismy = graphs.CycleGraph(8)
prismy.add_edge(2,5)
prismy.add_edge(0,3)
prismy.add_edge(4,7)
prismy.name(new="prismy")
add_to_lists(prismy, graph_objects, all_graphs)

#c10 with chords, ham, tri-free, regular, planar, vertex transitive
sixfour = graphs.CycleGraph(10)
sixfour.add_edge(1,9)
sixfour.add_edge(0,2)
sixfour.add_edge(3,8)
sixfour.add_edge(4,6)
sixfour.add_edge(5,7)
sixfour.name(new="sixfour")
add_to_lists(sixfour, graph_objects, all_graphs)

#unique 24-vertex fullerene: hamiltonian, planar, not vertex transitive
fullerene_24 = Graph('WsP@H?PC?O`?@@?_?GG@??CC?G??GG?E???o??B???E???F')
fullerene_24.name(new="fullerene_24")
add_to_lists(fullerene_24, graph_objects, all_graphs)

#unique 26-atom fullerene: hamiltonian, planar, not vertex trans, radius=5, diam=6
fullerene_26 = Graph('YsP@H?PC?O`?@@?_?G?@??CC?G??GG?E??@_??K???W???W???H???E_')
fullerene_26.name(new="fullerene_26")
add_to_lists(fullerene_26, graph_objects, all_graphs)

#the unique 100-atom fullerene with minimum independence number of 43 (and IPR, tetrahedral symmetry)
fullerene_100 = Graph("~?@csP@@?OC?O`?@?@_?O?A??W??_??_G?O??C??@_??C???G???G@??K???A????O???@????A????A?G??B?????_????C?G???O????@_?????_?????O?????C?G???@_?????E??????G??????G?G????C??????@???????G???????o??????@???????@????????_?_?????W???????@????????C????????G????????G?G??????E????????@_????????K?????????_????????@?@???????@?@???????@_?????????G?????????@?@????????C?C????????W??????????W??????????C??????????@?@?????????G???????????_??????????@?@??????????_???????????O???????????C?G??????????O???????????@????????????A????????????A?G??????????@_????????????W????????????@_????????????E?????????????E?????????????E?????????????B??????????????O?????????????A@?????????????G??????????????OG?????????????O??????????????GC?????????????A???????????????OG?????????????@?_?????????????B???????????????@_???????????????W???????????????@_???????????????F")
fullerene_100.name(new="fullerene_100")
add_to_lists(fullerene_100, graph_objects, all_graphs)

"""
The Holton-McKay graph is the smallest planar cubic hamiltonian graph with an edge
that is not contained in a hamiltonian cycle. It has 24 vertices and the edges (0,3)
and (4,7) are not contained in a hamiltonian cycle. This graph was mentioned in
D. A. Holton and B. D. McKay, Cycles in 3-connected cubic planar graphs II, Ars
Combinatoria, 21A (1986) 107-114.

    sage: holton_mckay
    holton_mckay: Graph on 24 vertices
    sage: holton_mckay.is_planar()
    True
    sage: holton_mckay.is_regular()
    True
    sage: max(holton_mckay.degree())
    3
    sage: holton_mckay.is_hamiltonian()
    True
    sage: holton_mckay.radius()
    4
    sage: holton_mckay.diameter()
    6
"""
holton_mckay = Graph('WlCGKS??G?_D????_?g?DOa?C?O??G?CC?`?G??_?_?_??L')
holton_mckay.name(new="holton_mckay")
add_to_lists(holton_mckay, graph_objects, all_graphs)

#an example of a bipartite, 1-tough, not van_den_heuvel, not hamiltonian graph
kratsch_lehel_muller = graphs.PathGraph(12)
kratsch_lehel_muller.add_edge(0,5)
kratsch_lehel_muller.add_edge(6,11)
kratsch_lehel_muller.add_edge(4,9)
kratsch_lehel_muller.add_edge(1,10)
kratsch_lehel_muller.add_edge(2,7)
kratsch_lehel_muller.name(new="kratsch_lehel_muller")
add_to_lists(kratsch_lehel_muller, graph_objects, all_graphs)

#ham, not planar, not anti_tutte
c6xc6 = graphs.CycleGraph(6).cartesian_product(graphs.CycleGraph(6))
c6xc6.name(new="c6xc6")
add_to_lists(c6xc6, graph_objects, all_graphs)

c7xc7 = graphs.CycleGraph(7).cartesian_product(graphs.CycleGraph(7))
c7xc7.name(new="c7xc7")
add_to_lists(c7xc7, graph_objects, all_graphs)

# Product Graphs, fig. 1.13
c6xk2 = graphs.CycleGraph(6).cartesian_product(graphs.CompleteGraph(2))
c6xk2.name(new = "c6xk2")
add_to_lists(c6xk2, graph_objects, all_graphs)

# Product Graphs, fig. 1.13
k1_4xp3 = graphs.CompleteBipartiteGraph(1, 4).cartesian_product(graphs.PathGraph(3))
k1_4xp3.name(new = "k1_4xp3")
add_to_lists(k1_4xp3, graph_objects, all_graphs)

# Product Graphs, fig. 1.14
p4xk3xk2 = graphs.PathGraph(4).cartesian_product(graphs.CompleteGraph(3)).cartesian_product(graphs.CompleteGraph(2))
p4xk3xk2.name(new = "p4xk3xk2")
add_to_lists(p4xk3xk2, graph_objects, all_graphs)

# Product Graphs, fig. 4.1
p3xk2xk2 = graphs.PathGraph(3).cartesian_product(graphs.CompleteGraph(2)).cartesian_product(graphs.CompleteGraph(2))
p3xk2xk2.name(new = "p3xk2xk2")
add_to_lists(p3xk2xk2, graph_objects, all_graphs)

# Product Graphs, fig. 5.1
p4Xp5 = graphs.PathGraph(4).strong_product(graphs.PathGraph(5))
p4Xp5.name(new = "p4Xp5")
add_to_lists(p4Xp5, graph_objects, all_graphs)

# Product Graphs, Fig 6.1
k3lxp3 = graphs.CompleteGraph(3).lexicographic_product(graphs.PathGraph(3))
k3lxp3.name(new = "k3lxp3")
add_to_lists(k3lxp3, graph_objects, all_graphs)

# Product Graphs, Fig 6.1
p3lxk3 = graphs.PathGraph(3).lexicographic_product(graphs.CompleteGraph(3))
p3lxk3.name(new = "p3lxk3")
add_to_lists(p3lxk3, graph_objects, all_graphs)

"""
Referenced p.15
Mathew, K. Ashik, and Patric RJ Östergård. "New lower bounds for the Shannon capacity of odd cycles." Designs, Codes and Cryptography (2015): 1-10.
"""
c5Xc5 = graphs.CycleGraph(5).strong_product(graphs.CycleGraph(5))
c5Xc5.name(new = "c5Xc5")
add_to_lists(c5Xc5, graph_objects, all_graphs)

#non-ham, 2-connected, eulerian (4-regular)
gould = Graph('S~dg?CB?wC_L????_?W?F??c?@gOOOGGK')
gould.name(new="gould")
add_to_lists(gould, graph_objects, all_graphs)

#two k5s with single edge removed from each and lines joining these 4 points to a new center point, non-hamiltonian
throwing = Graph('J~wWGGB?wF_')
throwing.name(new="throwing")
add_to_lists(throwing, graph_objects, all_graphs)

#k4 plus k2 on one side, open k5 on other, meet at single point in center, non-hamiltonian
throwing2 = Graph("K~wWGKA?gB_N")
throwing2.name(new="throwing2")
add_to_lists(throwing2, graph_objects, all_graphs)

#similar to throwing2 with pair of edges swapped, non-hamiltonian
throwing3 = Graph("K~wWGGB?oD_N")
throwing3.name(new="throwing3")
add_to_lists(throwing3, graph_objects, all_graphs)

#graph has diameter != radius but is hamiltonian
tent = graphs.CycleGraph(4).join(Graph(1),labels="integers")
tent.name(new="tent")
add_to_lists(tent, graph_objects, all_graphs)

# C5 with chords from one vertex to other 2 (showed up in auto search for CE's): hamiltonian
bridge = Graph("DU{")
bridge.name(new="bridge")
add_to_lists(bridge, graph_objects, all_graphs)

# nico found the smallest hamiltonian overfull graph
non_ham_over = Graph("HCQRRQo")
non_ham_over.name(new="non_ham_over")
add_to_lists(non_ham_over, graph_objects, all_graphs)

# From Ryan Pepper
ryan = Graph("WxEW?CB?I?_R????_?W?@?OC?AW???O?C??B???G?A?_??R")
ryan.name(new="ryan")
add_to_lists(ryan, graph_objects, all_graphs)

# Ryan Pepper
# CE to independence_number(x) <= 2 * x.chromatic_number() + 2 * residue(x)
# has alpha=25,chi=2,residue=10
ryan2=graphs.CirculantGraph(50,[1,3])
ryan2.name(new="circulant_50_1_3")
add_to_lists(ryan2, graph_objects, counter_examples, all_graphs)

# From Ryan Pepper
# CE to independence_number(x) >= diameter(x) - 1 for regular graphs
pepper_1_gadget = Graph('Ot???CA?WB`_B@O_B_B?A')
pepper_1_gadget.name(new = "pepper_1_gadget")
add_to_lists(pepper_1_gadget, graph_objects, counter_examples, all_graphs)

# p10 joined to 2 points of k4
# CE to chromatic_number <= avg_degree + 1
p10k4=Graph('MhCGGC@?G?_@_B?B_')
p10k4.name(new="p10k4")
add_to_lists(p10k4, graph_objects, counter_examples, all_graphs)

# star on 13 points with added edge:
# CE to independence_number(x) <= dom + girth(x)^2
s13e = Graph('M{aCCA?_C?O?_?_??')
s13e.name(new="s13e")
add_to_lists(s13e, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= 2 * girth(x)^2 + 2
# Star with 22 rays plus extra edge
s22e = graphs.StarGraph(22)
s22e.add_edge(1,2)
s22e.name(new="s22e")
add_to_lists(s22e, graph_objects, counter_examples, all_graphs)

# Graph from delavina's jets paper
starfish = Graph('N~~eeQoiCoM?Y?U?F??')
starfish.name(new="starfish")
add_to_lists(starfish, graph_objects, all_graphs)

# difficult graph from INP: order=11, alpha=4, best lower bound < 3
difficult11 = Graph('J?`FBo{fdb?')
difficult11.name(new="difficult11")
add_to_lists(difficult11, graph_objects, all_graphs)

# c4 joined to K# at point: not KE, alpha=theta=nu=3, delting any vertex gives KE graph
c5k3=Graph('FheCG')
c5k3.name(new="c5k3")
add_to_lists(c5k3, graph_objects, all_graphs)

# mycielskian of a triangle:
# CE to chi <= max(clique, nu)
# chi=4, nu = clique = 3
c3mycielski = Graph('FJnV?')
c3mycielski.name(new="c3mycieski")
add_to_lists(c3mycielski, problem_graphs , counter_examples, all_graphs)

# 4th mycielskian of a triangle,
# CE to chi <= clique + girth
# chi = 7, clique = girth = 3
c3mycielski4 = Graph('~??~??GWkYF@BcuIsJWEo@s?N?@?NyB`qLepJTgRXkAkU?JPg?VB_?W[??Ku??BU_??ZW??@u???Bs???Bw???A??F~~_B}?^sB`o[MOuZErWatYUjObXkZL_QpWUJ?CsYEbO?fB_w[?A`oCM??DL_Hk??DU_Is??Al_Dk???l_@k???Ds?M_???V_?{????oB}?????o[M?????WuZ?????EUjO?????rXk?????BUJ??????EsY??????Ew[??????B`o???????xk???????FU_???????\\k????????|_????????}_????????^_?????????')
c3mycielski4.name(new="c3mycielski4")
add_to_lists(c3mycielski4, graph_objects, counter_examples, all_graphs)

# A PAW is a traingle with a pendant
# Shows up in a sufficient condition for hamiltonicity
paw=Graph('C{')
paw.name(new="paw")
add_to_lists(paw, graph_objects, all_graphs)

# 2 octahedrons, remove one edge from each, add vertex, connect it to deleted edge vertices
# its regular of degree 4
binary_octahedron = Graph('L]lw??B?oD_Noo')
binary_octahedron.name(new = "binary_octahedron")
add_to_lists(binary_octahedron, graph_objects, all_graphs)

# this graph shows that the cartesian product of 2 KE graphs is not necessarily KE
# appears in Abay-Asmerom, Ghidewon, et al. "Notes on the independence number in the Cartesian product of graphs." Discussiones Mathematicae Graph Theory 31.1 (2011): 25-35.
paw_x_paw = paw.cartesian_product(paw)
paw_x_paw.name(new = "paw_x_paw")
add_to_lists(paw_x_paw, graph_objects, all_graphs)

#a DART is a kite with a pendant
dart = Graph('DnC')
dart.name(new="dart")
add_to_lists(dart, graph_objects, all_graphs)

# CE to ((is_chordal)^(is_forest))->(has_residue_equals_alpha)
ce2=Graph("HdGkCA?")
ce2.name(new = "ce2")
add_to_lists(ce2, graph_objects, counter_examples, all_graphs)

# CE to ((~(is_planar))&(is_chordal))->(has_residue_equals_alpha)
ce4=Graph("G~sNp?")
ce4.name(new = "ce4")
add_to_lists(ce4, graph_objects, counter_examples, all_graphs)

# CE to (((is_line_graph)&(is_cartesian_product))|(is_split))->(has_residue_equals_alpha)
ce5=Graph("X~}AHKVB{GGPGRCJ`B{GOO`C`AW`AwO`}CGOO`AHACHaCGVACG^")
ce5.name(new = "ce5")
add_to_lists(ce5, graph_objects, counter_examples, all_graphs)

# CE to (is_split)->((order_leq_twice_max_degree)&(is_chordal))
ce6 = Graph("H??E@cN")
ce6.name(new = "ce6")
add_to_lists(ce6, graph_objects, counter_examples, all_graphs)

# CE to (has_residue_equals_alpha)->((is_bipartite)->(order_leq_twice_max_degree))
ce7 = Graph("FpGK?")
ce7.name(new = "ce7")
add_to_lists(ce7, graph_objects, counter_examples, all_graphs)

# CE to ((has_paw)&(is_circular_planar))->(has_residue_equals_alpha)
ce8 = Graph('IxCGGC@_G')
ce8.name(new = "ce8")
add_to_lists(ce8, graph_objects, counter_examples, all_graphs)

# CE to ((has_H)&(is_forest))->(has_residue_equals_alpha)
ce9 = Graph('IhCGGD?G?')
ce9.name(new = "ce9")
add_to_lists(ce9, graph_objects, counter_examples, all_graphs)

# CE to (((is_eulerian)&(is_planar))&(has_paw))->(has_residue_equals_alpha)
ce10=Graph('KxkGGC@?G?o@')
ce10.name(new = "ce10")
add_to_lists(ce10, graph_objects, counter_examples, all_graphs)

# CE to (((is_cubic)&(is_triangle_free))&(is_H_free))->(has_residue_equals_two)
ce12 = Graph("Edo_")
ce12.name(new = "ce12")
add_to_lists(ce12, graph_objects, counter_examples, all_graphs)

# CE to ((diameter_equals_twice_radius)&(is_claw_free))->(has_residue_equals_two)
ce13 = Graph("ExOG")
ce13.name(new = "ce13")
add_to_lists(ce13, graph_objects, counter_examples, all_graphs)

# CE to (~(matching_covered))->(has_residue_equals_alpha)
ce14 = Graph('IhCGGC_@?')
ce14.name(new = "IhCGGC_@?")
add_to_lists(ce14, graph_objects, counter_examples, all_graphs)

"""
CE to independence_number(x) <= 10^order_automorphism_group(x)

    sage: order(ce15)
    57
    sage: independence_number(ce15)
    25
"""
ce15 = Graph("x??C?O?????A?@_G?H??????A?C??EGo?@S?O@?O??@G???CO???CAC_??a?@G?????H???????????O?_?H??G??G??@??_??OA?OCHCO?YA????????A?O???G?O?@????OOC???_@??????MCOC???O_??[Q??@???????O??_G?P?GO@A?G_???A???A@??g???W???@CG_???`_@O??????@?O@?AGO?????C??A??F??????@C????A?E@L?????P@`??")
ce15.name(new = "ce15")
add_to_lists(ce15, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= 2*maximum(welsh_powell(x), max_even_minus_even_horizontal(x))
ce16 = Graph("mG???GP?CC?Aa?GO?o??I??c??O??G?ACCGW@????OC?G@?_A_W_OC@??@?I??O?_AC?Oo?E@_?O??I??B_?@_A@@@??O?OC?GC?CD?C___gAO?G??KOcGCiA??SC????GAVQy????CQ?cCACKC_?A?E_??g_AO@C??c??@@?pY?G?")
ce16.name(new = "ce16")
add_to_lists(ce16, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= 1/2*cvetkovic(x)
ce17 = Graph("S??wG@@h_GWC?AHG?_gMGY_FaIOk@?C?S")
ce17.name(new = "ce17")
add_to_lists(ce17, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= matching_number - sigma_dist2
ce18 = Graph("cGO_?CCOB@O?oC?sTDSOCC@O???W??H?b???hO???A@CCKB??I??O??AO@CGA???CI?S?OGG?ACgQa_Cw^GP@AID?Gh??ogD_??dR[?AG?")
ce18.name(new = "ce18")
add_to_lists(ce18, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(max_even_minus_even_horizontal(x), radius(x)*welsh_powell(x))
ce19 = Graph('J?@OOGCgO{_')
ce19.name(new = "ce19")
add_to_lists(ce19, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= card_center(x) + max_even_minus_even_horizontal(x) + 1
ce20 = Graph('M?CO?k?OWEQO_O]c_')
ce20.name(new = "ce20")
add_to_lists(ce20, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= median_degree(x)^2 + card_periphery(x)
ce21 = Graph('FiQ?_')
ce21.name(new = "ce21")
add_to_lists(ce21, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= brinkmann_steffen(x) + max_even_minus_even_horizontal(x) + 1
ce22 = Graph('Ss?fB_DYUg?gokTEAHC@ECSMQI?OO?GD?')
ce22.name(new = "ce22")
add_to_lists(ce22, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= inverse_degree(x) + order_automorphism_group(x) + 1
ce23 = Graph("HkIU|eA")
ce23.name(new = "ce23")
add_to_lists(ce23, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= ceil(eulerian_faces(x)/diameter(x)) +max_even_minus_even_horizontal(x)
ce24 = Graph('JCbcA?@@AG?')
ce24.name(new = "ce24")
add_to_lists(ce24, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= floor(e^(maximum(max_even_minus_even_horizontal(x), fiedler(x))))
ce25 = Graph('OX??ZHEDxLvId_rgaC@SA')
ce25.name(new = "ce25")
add_to_lists(ce25, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(card_periphery(x), radius(x)*welsh_powell(x))
ce26 = Graph("NF?_?o@?Oa?BC_?OOaO")
ce26.name(new = "ce26")
add_to_lists(ce26, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= floor(average_distance(x)) + maximum(max_even_minus_even_horizontal(x), brinkmann_steffen(x))
ce27 = Graph("K_GBXS`ysCE_")
ce27.name(new = "ce27")
add_to_lists(ce27, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= minimum(annihilation_number(x), 2*e^sum_temperatures(x))
ce28 = Graph("g??O?C_?`?@?O??A?A????????C?????G?????????A@aA??_???G??GA?@????????_???GHC???CG?_???@??_??OB?C?_??????_???G???C?O?????O??A??????G??")
ce28.name(new = "ce28")
add_to_lists(ce28, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(2*welsh_powell(x), maximum(max_even_minus_even_horizontal(x), laplacian_energy(x)))
ce29 = Graph("P@g??BSCcIA???COcSO@@O@c")
ce29.name(new = "ce29")
add_to_lists(ce29, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(order_automorphism_group(x), 2*cvetkovic(x) - matching_number(x))
ce30 = Graph("G~q|{W")
ce30.name(new = "ce30")
add_to_lists(ce30, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= max_even_minus_even_horizontal(x) + min_degree(x) + welsh_powell(x)
ce31 = Graph("VP??oq_?PDOGhAwS??bSS_nOo?OHBqPi?I@AGP?POAi?")
ce31.name(new = "ce31")
add_to_lists(ce31, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= order(x)/szekeres_wilf(x)
ce32 = Graph('H?`@Cbg')
ce32.name(new = "ce32")
add_to_lists(ce32, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= max_even_minus_even_horizontal(x) + minimum(card_positive_eigenvalues(x), card_center(x) + 1)
ce33 = Graph("O_aHgP_kVSGOCXAiODcA_")
ce33.name(new = "ce33")
add_to_lists(ce33, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= card_center(x) + maximum(diameter(x), card_periphery(x))
ce34 = Graph('H?PA_F_')
ce34.name(new = "ce34")
add_to_lists(ce34, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= card_center(x) + maximum(diameter(x), card_periphery(x))ce35 = Graph("")
ce35 = Graph("HD`cgGO")
ce35.name(new = "ce35")
add_to_lists(ce35, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= max_degree(x) - order_automorphism_group(x)
ce36 = Graph('ETzw')
ce36.name(new = "ce36")
add_to_lists(ce36, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(card_center(x), diameter(x)*max_degree(x))
ce37 = Graph("~?AA?G?????@@??@?A???????????O??????????G_?A???????????????A?AO?????????G???G?@???@???O?????????????C???????_???????C?_?W???C????????_??????????????????_???????_???O????????D??????????C????????GCC???A??G??????A@??A??@G???_?????@_??????_??G???K??????A????C??????????A???_?A????`??C_O????G????????????A?G???????????????????O?????C??????@???__?@O_G??C????????OA?????????????????????????GA_GA????O???_??O??O?G??G?_C???@?G???O???_?O???_??????C???????????????E_???????????????_@???O??????CC???O?????????OC_????_A????????_?G??????O??????_??????_?I?O??????A???????O?G?O???C@????????????_@????C?????@@???????C???O??A?????_??????A_??????????A?G????AB???A??C?G??????????G???A??@?A???????@???????D?_????B????????????????????g?C???C????G????????@??????@??A????????@????_??_???o?????????@????????????_???????A??????C????A?????C????O????@?@???@?A_????????CA????????????????H???????????????????O????_??OG??Ec?????O??A??_???_???O?C??`?_@??@??????O????G????????????A????@???_?????????_?A???AAG???O????????????????????C???_???@????????????_??H???A??W?O@????@_???O?_A??O????OG???????G?@??G?C?????G?????????@?????????G?O?????G???????_?????????@????@?????????G????????????C?G?????????_C?@?A????G??GA@????????????@?????C??G??????_?????????_@?????@???A?????@?????????????????CG??????_?????@???????@C???O????_`?????OA?G??????????????Q?A?????????????A????@C?????GO??_?C???????O???????@?G?A????O??G???_????_?????A?G_?C?????????C?")
ce37.name(new = "ce37")
add_to_lists(ce37, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= abs(-card_center(x) + min_degree(x)) + max_even_minus_even_horizontal(x)
ce38 = Graph('FVS_O')
ce38.name(new = "ce38")
add_to_lists(ce38, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= abs(-card_center(x) + max_degree(x)) + max_even_minus_even_horizontal(x)
ce39 = Graph("FBAuo")
ce39.name(new = "ce39")
add_to_lists(ce39, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= floor(inverse_degree(x)) + order_automorphism_group(x) + 1
ce40 = Graph('Htji~Ei')
ce40.name(new = "ce40")
add_to_lists(ce40, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= card_center(x) + maximum(residue(x), card_periphery(x))
ce42 = Graph('GP[KGC')
ce42.name(new = "ce42")
add_to_lists(ce42, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(girth(x), (barrus_bound(x) - order_automorphism_group(x))^2)
ce43 = Graph("Exi?")
ce43.name(new = "ce43")
add_to_lists(ce43, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= (brinkmann_steffen(x) - szekeres_wilf(x))^2 + max_even_minus_even_horizontal(x)
ce44 = Graph('GGDSsg')
ce44.name(new = "ce44")
add_to_lists(ce44, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(max_even_minus_even_horizontal(x), radius(x)*szekeres_wilf(x))
ce45 = Graph("FWKH?")
ce45.name(new = "ce45")
add_to_lists(ce45, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(card_periphery(x), radius(x)*szekeres_wilf(x))
ce46 = Graph('F`I`?')
ce46.name(new = "ce46")
add_to_lists(ce46, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(card_periphery(x), diameter(x) + inverse_degree(x))
ce47 = Graph("KVOzWAxewcaE")
ce47.name(new = "ce47")
add_to_lists(ce47, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(card_periphery(x), max_even_minus_even_horizontal(x) + min_degree(x))
ce48 = Graph('Iq]ED@_s?')
ce48.name(new = "ce48")
add_to_lists(ce48, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= sqrt(card_positive_eigenvalues(x))
ce49 = Graph("K^~lmrvv{~~Z")
ce49.name(new = "ce49")
add_to_lists(ce49, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= max_degree(x) + maximum(max_even_minus_even_horizontal(x), sigma_dist2(x))
ce50 = Graph('bCaJf?A_??GY_O?KEGA???OMP@PG???G?CO@OOWO@@m?a?WPWI?G_A_?C`OIG?EDAIQ?PG???A_A?C??CC@_G?GDI]CYG??GA_A??')
ce50.name(new = "ce50")
add_to_lists(ce50, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= matching_number(x) - order_automorphism_group(x) - 1
ce51 = Graph("Ivq~j^~vw")
ce51.name(new = "ce51")
add_to_lists(ce51, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= order(x)/szekeres_wilf(x)
ce52 = Graph('H?QaOiG')
ce52.name(new = "ce52")
add_to_lists(ce52, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= matching_number(x) - sigma_dist2(x) - 1
ce53 = Graph("]?GEPCGg]S?`@??_EM@OTp?@E_gm?GW_og?pWO?_??GQ?A?^HIRwH?Y?__BC?G?[PD@Gs[O?GW")
ce53.name(new = "ce53")
add_to_lists(ce53, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -average_distance(x) + ceil(lovasz_theta(x))
ce54 = Graph('lckMIWzcWDsSQ_xTlFX?AoCbEC?f^xwGHOA_q?m`PDDvicEWP`qA@``?OEySJX_SQHPc_H@RMGiM}`CiG?HCsm_JO?QhI`?ARLAcdBAaOh_QMG?`D_o_FvQgHGHD?sKLEAR^ASOW~uAUQcA?SoD?_@wECSKEc?GCX@`DkC')
ce54.name(new = "ce54")
add_to_lists(ce54, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -card_periphery(x) + matching_number(x)
ce55 = Graph("I~~~~~~zw")
ce55.name(new = "ce55")
add_to_lists(ce55, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= lovasz_theta(x)/edge_con(x)
ce56 = Graph('HsaGpOe')
ce56.name(new = "ce56")
add_to_lists(ce56, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(max_degree(x), floor(lovasz_theta(x)))
ce57 = Graph("^?H{BDHqHosG??OkHOhE??B[CInU?@j_A?CoA^azGPLcb_@GEYYRPgG?K@gdPAg?d@_?_sGcED`@``O")
ce57.name(new = "ce57")
add_to_lists(ce57, graph_objects, counter_examples, all_graphs)

# CE to independence_number>= barrus_bound(x) - max(card_center(x), card_positive_eigenvalues(x))
ce58 = Graph('Sj[{Eb~on~nls~NJWLVz~~^|{l]b\uFss')
ce58.name(new = "ce58")
add_to_lists(ce58, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= floor(tan(barrus_bound(x) - 1))
ce59 = Graph("RxCWGCB?G?_B?@??_?N??F??B_??w?")
ce59.name(new = "ce59")
add_to_lists(ce59, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -1/2*diameter(x) + lovasz_theta(x)
ce60 = Graph('wSh[?GCfclJm?hmgA^We?Q_KIXbf\@SgDNxpwHTQIsIB?MIDZukArBAeXE`vqDLbHCwf{fD?bKSVLklQHspD`Lo@cQlEBFSheAH?yW\YOCeaqmOfsZ?rmOSM?}HwPCIAYLdFx?o[B?]ZYb~IK~Z`ol~Ux[B]tYUE`_gnVyHRQ?{cXG?k\BL?vVGGtCufY@JIQYjByg?Q?Qb`SKM`@[BVCKDcMxF|ADGGMBW`ANV_IKw??DRkY\KOCW??P_?ExJDSAg')
ce60.name(new = "ce60")
add_to_lists(ce60, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(card_negative_eigenvalues(x), max_common_neighbors(x) + max_even_minus_even_horizontal(x))
ce61 = Graph("KsaAA?OOC??C")
ce61.name(new = "ce61")
add_to_lists(ce61, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(floor(lovasz_theta(x)), tan(spanning_trees_count(x)))
ce62 = Graph("qWGh???BLQcAH`aBAGCScC@SoBAAFYAG?_T@@WOEBgRC`oSE`SG@IoRCK[_K@QaQq?c@?__G}ScHO{EcCa?K?o?E?@?C[F_@GpV?K_?_?CSW@D_OCr?b_XOag??C@gGOGh??QFoS?@OHDAKWIX_OBbHGOl??\Cb@?E`WehiP@IGAFC`GaCgC?JjQ???AGJgDJAGsdcqEA_a_q?")
ce62.name(new = "ce62")
add_to_lists(ce62, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= diameter(x)/different_degrees(x)
ce63 = Graph("KOGkYBOCOAi@")
ce63.name(new = "ce63")
add_to_lists(ce63, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -max_common_neighbors(x) + min_degree(x)
ce64 = Graph('`szvym|h~RMQLTNNiZzsgQynDR\p~~rTZXi~n`kVvKolVJfP}TVEN}Thj~tv^KJ}D~VqqsNy|NY|ybklZLnz~TfyG')
ce64.name(new = "ce64")
add_to_lists(ce64, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -10^different_degrees(x) + matching_number(x)
ce65 = Graph("W~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
ce65.name(new = "ce65")
add_to_lists(ce65, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= girth^max_degree+1
ce66 = Graph("~?@EG??????????@G????_???a???C????????@???A???????G??????C?GCG????????A???C@??????@????O??A??C?????_??O???CA???c??_?_?@????A????@??????C???C?G?O?C???G?????????O?_G?C????G??????_?????@??G???C??????O?GA?????O???@????????A?G?????????_C???????@??G??@??_??IA@???????G?@??????@??_?@????C??G???_????O???P???@???o??????O?????S?O???A???G?????c_?????D?????A???A?????G@???????O???H????O????@@????@K????????C??C?????G??")
ce66.name(new = "ce66")
add_to_lists(ce66, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(cycle_space_dimension(x), floor(lovasz_theta(x)))
ce67 = Graph("G??EDw")
ce67.name(new = "ce67")
add_to_lists(ce67, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(card_positive_eigenvalues(x), 2*card_zero_eigenvalues(x))
ce68 = Graph('HzzP|~]')
ce68.name(new = "ce68")
add_to_lists(ce68, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(max_degree(x), radius(x)^card_periphery(x))
ce69 = Graph("F?BvO")
ce69.name(new = "ce69")
add_to_lists(ce69, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= floor(lovasz_theta(x))/vertex_con(x)
ce70 = Graph('~?@Z??????O?M??`S??A?`?A?????@????`?????A?A?????A@????GO?@@??A_????????O_???I@_??G??A?`?C????????@???????????@??C?@?????O??@??CA??A?D??G?_?????_Q@G????C?_?A??@???O????G?O?G?_?????CoG?G???X??C???_CAG_C??????G?????@?Ao?????C???A??????_??SG??cOC??????????Ao????????_?????G???????D?????C??_?B?????a??_???????G?@?????C??????C?c?????G_?_??G??_Q????C????B?_CG????AGC???G?O??_I????@??????_??a??@?O_G??O??aA@@?????EA???@???????@???????O?O??@??`_G???????GCA?_GO????_?_????????????_??I?@?C???@????????G?aG??????W????@PO@???oC?CO???_??G?@@?CO??K???C@??O???@????D?????A?@G?G?O???_???????Ao??AC???G?_???G????????A??????_?p???W?A?Ao@?????_?????GA??????????????_?C??????@O????_@??O@Gc@??????????A_??????')
ce70.name(new = "ce70")
add_to_lists(ce70, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(matching_number(x), critical_independence_number(x))
ce71 = Graph('ECYW')
ce71.name(new = "ce71")
add_to_lists(ce71, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x)>=-1/2*x.diameter() + x.lovasz_theta()
ce72 = Graph('fdSYkICGVs_m_TPs`Fmj_|pGhC@@_[@xWawsgEDe_@g`TC{P@pqGoocqOw?HBDS[R?CdG\e@kMCcgqr?G`NHGXgYpVGCoJdOKBJQAsG|ICE_BeMQGOwKqSd\W?CRg')
ce72.name(new = "ce72")
add_to_lists(ce72, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(floor(lovasz_theta(x)), max_even_minus_even_horizontal(x) + 1)
ce73 = Graph('h???_?CA?A?@AA????OPGoC@????A@?A?_C?C?C_A_???_??_G????HG????c?G_?G??HC??A@GO?G?A@A???_@G_?_G_GC_??E?O?O`??@C?@???O@?AOC?G?H??O?P??C_?O_@??')
ce73.name(new = "ce73")
add_to_lists(ce73, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(diameter(x), lovasz_theta(x))
ce74 = Graph("FCQb_")
ce74.name(new = "ce74")
add_to_lists(ce74, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(girth(x), floor(lovasz_theta(x)))
ce75 = Graph('E?Bw')
ce75.name(new = "ce75")
add_to_lists(ce75, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(average_distance(x), max_even_minus_even_horizontal(x))*sum_temperatures(x)
ce76 = Graph("~?@DS?G???G_?A_?OA?GC??oa?A@?@?K???L?_?S_??CCSA_g???@D?????_?A??EO??GAOO_@C`???O?_CK_???_o_?@O??XA???AS???oE`?A?@?CAa?????C?G??i???C@qo?G?Og?_O?_?@???_G????o?A_@_?O?@??EcA???__?@GgO?O@oG?C?@??CIO?_??G??S?A?@oG_K?@C??@??QOA?C????AOo?p?G???oACAOAC@???OG??qC???C??AC_G?@??GCHG?AC@?_@O?CK?@?B???AI??OO_S_a_O??????AO?OHG?@?????_???EGOG??@?EF@?C?Pc?????C?W_PA?O@?_?@A@??OD_C?@?@?A??CC?_?i@?K?_O_CG??A?")
ce76.name(new = "ce76")
add_to_lists(ce76, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(matching_number(x), critical_independence_number(x))
ce77 = Graph("iF\ZccMAoW`Po_E_?qCP?Ag?OGGOGOS?GOH??oAAS??@CG?AA?@@_??_P??G?SO?AGA??M????SA????I?G?I???Oe?????OO???_S?A??A????ECA??C?A@??O??S?@????_@?_??S???O??")
ce77.name(new = "ce77")
add_to_lists(ce77, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(max_degree(x), radius(x)^card_periphery(x))
ce78 = Graph("G_aCp[")
ce78.name(new = "ce78")
add_to_lists(ce78, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= residue(x)^2
ce79 = Graph('J?B|~fpwsw_')
ce79.name(new = "ce79")
add_to_lists(ce79, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= 10^(card_center(x)*log(10)/log(sigma_dist2(x)))
ce80 = Graph('T?????????????????F~~~v}~|zn}ztn}zt^')
ce80.name(new = "ce80")
add_to_lists(ce80, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= diameter(x)^card_periphery(x)
ce81 = Graph('P?????????^~v~V~rzyZ~du{')
ce81.name(new = "ce81")
add_to_lists(ce81, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= radius(x)*residue(x) + girth(x)
ce82 = Graph('O????B~~^Zx^wnc~ENqxY')
ce82.name(new = "ce82")
add_to_lists(ce82, graph_objects, counter_examples, all_graphs)

"""
CE to independence_number(x) <= minimum(lovasz_theta(x), residue(x)^2)
    and
    <= minimum(annihilation_number(x), residue(x)^2)
    and
    <= minimum(fractional_alpha(x), residue(x)^2)
    and
    <= minimum(cvetkovic(x), residue(x)^2)
    and
    <= minimum(residue(x)^2, floor(lovasz_theta(x)))
    and
    <= minimum(size(x), residue(x)^2)
"""
ce83 = Graph('LEYSrG|mrQ[ppi')
ce83.name(new = "ce83")
add_to_lists(ce83, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(laplacian_energy(x), brinkmann_steffen(x)^2)
ce84 = Graph('~?@r?A??OA?C??????@?A????CC?_?A@????A?@???@?S?O????AO??????G???????C????????C?C???G?????_??????_?G?????O?A?_?O?O@??O???T@@??????O????C_???C?CO???@??@?@???_???O??O??A??O???O?A?OB?C?AD???C`?B?__?_????????Q?C??????????????_???C??_???A?gO??@C???C?EC?O??GG`?O?_?_??O????_?@?GA?_????????????G????????????????????AO_?C?????????P?IO??I??OC???O????A??AC@AO?o????????o@??O?aI?????????_A??O??G??o?????????_??@?????A?O?O?????G?????H???_????????A??a?O@O?_?D???????O@?????G???GG?CA??@?A@?A????GA?@???G??O??A??????AA???????O??_c??@???A?????_????@CG????????????A???A???????A?W???B????@?????HGO???????_@_?????C??????????_a??????_???????@G?@O?@@_??G@???????GG?O??A??????@????_??O_?_??CC?B???O??@????W??`AA????O??_?????????????????_???A??????@G??????I@C?G????????A@?@@?????C???p???????????????????G?_G????Z?A????_??????G????Q????@????????_@O????@???_QC?A??@???o???G???@???????O???CC??O?D?O?@C????@O?G?????A??@C???@????O?????????_??C??????_?@????O??????O?Y?C???_?????A??@OoG???????A???G??????CC??A?A?????????????????GA_???o???G??O??C???_@@??????@?????G??????????O???@O???????????A????S??_o????????A??B??????_??C????C?')
ce84.name(new = "ce84")
add_to_lists(ce84, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= girth(x)^ceil(laplacian_energy(x))
ce85 = Graph('bd_OPG_J_G?apBB?CPk@`X?hB_?QKEo_op`C?|Gc?K_?P@GCoGPTcGCh?CBIlqf_GQ]C_?@jlFP?KSEALWGi?bIS?PjO@?CCA?OG?')
ce85.name(new = "ce85")
add_to_lists(ce85, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= diameter(x)*residue(x) + different_degrees(x)
ce86 = Graph('SK|KWYc|^BJKlaCnMH^ECUoSC[{LHxfMG')
ce86.name(new = "ce86")
add_to_lists(ce86, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(max_common_neighbors(x), girth(x)^laplacian_energy(x))
ce87 = Graph('~?@iA?B@@b?[a??oHh_gC?@AGD?Wa???_E@_@o_AkGA@_o?_h??GG??cO??g?_?SD?d@IW?s?P_@@cSG?_B??d?CSI?OCQOH_?bo?CAaC???pGC@DO@?PHQOpO??A?_A@K[PC@?__???@OSCOGLO?oOAAA?IOX@??GC?O?P??oA_?KPIK?Q@A?sQC???LA???aQOC_AeG?Q?K_Oo?AB?OU?COD?VoQ?@D????A?_D?CAa?@@G?C??CGHcCA_cB?@c@_O?H??_@?@OWGGCo??AGC??AQ?QOc???Ow_?C[?O@@G_QH?H?O???_I@@PO????FAGk??C?ka@D@I?P?CooC@_O@?agAE??CpG?AA_`OO??_?Q?AiOQEK?GhB@CAOG?G?CC??C@O@GdC__?OIBKO?aOD_?OG???GACH@?b?@?B_???WPA?@_?o?XQQ?ZI_@?O_o_?@O??EDGOBEA??_aOSQsCO@?_DD`O??D?JaoP?G?AOQOCAS?k??S?c@?XW?QCO??_OAGOWc__G?_??G??L@OP?b?O?GCCMAH????????@@?A?C@oDaGG?Wk@H@OM?_A?IOu`SG?E@??W?I@EQA@@_@Wa?@?_??C??AAAiGQG@@?`@oA?_??OgC?K_G??G`?@S@B?A?HWc?HG??`gO???A?W?A?O?MpS??D?GS?GDC_??I@??IPAOdk`?CG??A?pPAgIDlCYCTSDgg?@FW?DI?O_OW?_S??AAQB_OOCF????XS_?@l_kAw__Ea?O?C_CGO??EG??WLb@_H??OCaAET@S?@?I???_??LaO_HCYG@G_G?_?_C???os?_G?OO@s_??_?_GGE`Os??_GCa?DWO?A@?@_CB`MOBCGIC???GKA_c?@BSh??@?RC[?eg?@hOC?_?BeGOaC?AWOSCm@G?A??A?G?Ga_')
ce87.name(new = "ce87")
add_to_lists(ce87, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(radius(x), max_degree(x))^2
ce88 = Graph('h@`CA???GH?AAG?OW@@????E???O?O???PO?O?_?G??`?O_???@??E?E??O??A?S@???S???????U?GAI???A?DA??C?C@??PA?A???_C_?H?AA??_C??DCO?C???_?AAG??@O?_?G')
ce88.name(new = "ce88")
add_to_lists(ce88, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= max_degree(x) + maximum(max_even_minus_even_horizontal(x), geometric_length_of_degree_sequence(x))
ce89 = Graph("_qH?S@??`??GG??O?_?C?_??@??@??G??C??_??C????O??G???@????O???A???@????C???C?????G????")
ce89.name(new = "ce89")
add_to_lists(ce89, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= floor(arccosh(lovasz_theta(x)))^2
ce90 = Graph("~?@Td|wi\\fbna~}wepkkbXcrW}\\~NvtLKpY\\J_Ub^~yM~^tHnM}jPffKkqnijvxD@xa{UOzzvr?L^PFi||yt@OQ\YU{Vh]tWzwzpj\\n|kR]`Y}RpCvxk{rEMRP\\}|}dNdNtbO~yrkgMxlOXr|FvQ{tvfKKnHrp^}jV\\B^n\\LvLZeyX}QSKN^sm~yl\\[NJZXqdk]O|^zHl~vC{w`Nsn}x]utqrJozKXV|eIUUPv~ydc}]xJNWZjW|lpYm}{Jf~JWMixb^t]e|S~B[vKc{K[Kjut~}Kj~iAl\\tVNgyZadvoA}rdTlr\\\\wNr^^kJzrp|qlVy]siKncI~`oNm|ul\\PxDRyzddDzrjUn~ciOgbR}p~Cz|~MlxYoEVnVuZkxJgvmtE]]}~PRp[He]oBQz]PVJ~gVnvSUR|QF|`lomFh[j|jIaS~vh~_rYiiK}FnEW}ovnntxtRFBakzvwn[biJhNvf|VDV?m~Y]ndmfJQ|M@QvnNf~MCyn~{HSU~fvEv~@}u|spOXzTVNY\\kjDNt\\zRMXxU|g|XrzFzDYiVvho}bQbyfI{{w[_~nrm}J~LhwH}TNmfM^}jqajl_ChY]M}unRK\\~ku")
ce90.name(new = "ce90")
add_to_lists(ce90, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(2*welsh_powell(x), max_even_minus_even_horizontal(x)^2)
ce91 = Graph("q?}x{k\FGNCRacDO`_gWKAq?ED?Qc?IS?Da?@_E?WO_@GOG@B@?Cc?@@OW???qO?@CC@?CA@C?E@?O?KK???E??GC?CO?CGGI??@?cGO??HG??@??G?SC???AGCO?KAG???@O_O???K?GG????WCG??C?C??_C????q??@D??AO???S????CA?a??A?G??IOO????B?A???_??")
ce91.name(new = "ce91")
add_to_lists(ce91, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -max_common_neighbors(x) + min_degree(x) - 1
ce92 = Graph("qR}fexr{J\\innanomndYrzmy^p~Ri]c]lA{~jVurv]n~reCed~|j{TtvnMtB~nZFrz{wUnV^fzV\\rUlt|qvJubnFwWSxxzfZ}Btj`yV~rv\\nknwl~Z?T]{qwn~bFzh^\\{Ezv}p~I^RV|oXe~knL~x^nNtvYlrezLX^tj{S^Rflqqv]e|S^}vpbe~Ni]m]}zfbZolnPl{N~}]X?")
ce92.name(new = "ce92")
add_to_lists(ce92, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= diameter for regular graphs
# Ryan Pepper, June 2017
ce93 = Graph('_t???CA???_B?E?@??WAB?G??_GA?W?????@???W??B???A???BA??@__???G??@A???LA???AW???@_???G')
ce93.name(new = "ce93")
add_to_lists(ce93, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= diameter for regular graphs
# Ryan Pepper, June 2017
ce94 = Graph('Yv?GW?@?WB?A?A?@_?oGA?_KG????G??K??A???W??@???AO??BG??B?')
ce94.name(new = "ce94")
add_to_lists(ce94, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -average_distance(x) + ceil(lovasz_theta(x))
ce95 = Graph('epCpih@K}gSGIZfc?Rkf{EWtVKJTmJtWYl_IoDOKOikwDSKtbH\\fi_g`affO\\|Agq`WcLoakSLNPaWZ@PQhCh?ylTR\\tIR?WfoJNYJ@B{GiOWMUZX_puFP?')
ce95.name(new = "ce95")
add_to_lists(ce95, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= ceil(1/2*cvetkovic(x))
# CE to independence_number(x) >= 1/2*cvetkovic(x)
ce96 = Graph('Gvz~r{')
ce96.name(new = "ce96")
add_to_lists(ce96, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -max_common_neighbors(x) + min_degree(x)
ce97 = Graph('eLvnv~yv{yJ~rlB^Mn|v^nz~V]mwVji}^vZf{\\\\nqZLfVBze}y[ym|jevvt~NNucret|~ejj~rz}Q\\~^an}XzTV~t]a]v}nx\\u]n{}~ffqjn`~e}lZvV]t_')
ce97.name(new = "ce97")
add_to_lists(ce97, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= lovasz_theta(x)/radius(x)
ce100 = Graph('~?@A~~~~~~z~~~~~~~~^~~~~~z~~~~~~~~~~~~~~~v~~~v~~~~~~~~~~z~~~~~~~~^~~~~~~~~~}\~~}v~^~~}~~^~~~~~~~~~~~~^~~~~~~~~V~~~n~~n~~~~~~}~~|~}~~~~~~~~~~~~~~~~~~~~~vv~|~~~~~~~~~~~~~~~~~z~~w~~~~~~~~~~~~~~~~n~~~|~~~~~~~v~|~~~~~~~~~~}~|~r~V~~~n~~~~~~~~z~~}}~}~~~~vz~~z~~~z}~~~n~~~~~~~~~~~~n~~~~~~~z~~~~~~~~~~~~~~^~~~~~~~~~n~~]~~~~~n~~~}~~~~~~~~~~^~^~~~~}~~~~~~~~~~~z~~~~^~~~~~~w')
ce100.name(new = "ce100")
add_to_lists(ce100, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= matching_number(x) - order_automorphism_group(x) - 1
ce101 = Graph('I~~Lt~\Nw')
ce101.name(new = "ce101")
add_to_lists(ce101, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= card_positive_eigenvalues(x) - lovasz_theta(x)
ce102 = Graph('N^nN~~}Z~|}~~\~]zzw')
ce102.name(new = "ce102")
add_to_lists(ce102, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= card_negative_eigenvalues(x) - sigma_dist2(x)
ce103 = Graph('IOilnemjG')
ce103.name(new = "ce103")
add_to_lists(ce103, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(min_degree(x), floor(lovasz_theta(x)))
ce105 =  Graph('z@M@E?OYOSCPBTp?mOWaP_?W[OG[abE_?P[@?@REt?ggAAOH?N@?CATE\oE?WO@GOKu?LJ_??SDP@CIA?AFHCC?kZQMo@CkOGoiJSs`?g?oDJqC?S?qJSqA?GN]?OPd?cGHE?AOpE_c_O@kC_?DF@HGgJ?ygAACdcCMPA[d`SHE@?PqRE?CO_?CWO?H_b_EBoOKI@CWAadQ?eOO?oT_@STAWCCCMOK?A@?TsBoJa@?PGQ_CiKPC_@_iE_hL@ACAIJQDgOSG?G[cG_D[A_CbDKO[goBH_?S?')
ce105.name(new = "ce105")
add_to_lists(ce105, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= minimum(floor(lovasz_theta(x)), 10^laplacian_energy(x))
ce106 = Graph("k??????????????????????????????????????F~~~z~~~\~~~~{~^|nvny\^~~Njj~~zo}^yB|z~}h|Vv\Jft]~RlhV~tZMC^~fpvBynshVa~yw~@Tv\IVaJ}tvA\erD|Xx_rijkiIxLx}GE\pZ{yIwW?vV}K")
ce106.name(new = "ce106")
add_to_lists(ce106, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= max_even_minus_even_horizontal(x) + sinh(max_degree(x) - 1)
ce107 = Graph("~?@S???CO@_??C??????O?D????A?@?O?_????????????_???__?_O???????G??????A@????C????????????H???G??????_?G???????@????????OG?G_?C????C??K????A?_O???O?O????O?O????OOG?G??????C???????g???????C@???????A?OG_???CO?_?_??CC????@?G?????OO?@?C??????_?????O???A???????O?i??????????O?C???O????G??@??A?G??????A???_??A????OC?G???C?@?O???G??A?O???G?A??????C??C???@??????A??@????O???@??G?_?_???_???@G@???@???G??_?C????A??A?@AA????E????G?????????@O??@A????A????@?G?????????@@??_C???????G??@?@_???????@?????K?_???GO????_???O?C?C?@G??????????CG??@?G??????CQ??????G???????C__??C???_A?????????A_??o????_?@????")
ce107.name(new = "ce107")
add_to_lists(ce107, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= 10^cosh(log(residue(x)) - 1)
ce108 = Graph("U??????g}yRozOzw\wBn?zoBv_FN?Bn?B|??vO??")
ce108.name(new = "ce108")
add_to_lists(ce108, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= floor(caro_wei(x))^min_common_neighbors(x)
ce109 = Graph("Z???????????????????????????????B~~~v~~z~~|~nvnnjz~~xfntuV~w")
ce109.name(new = "ce109")
add_to_lists(ce109, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= min(card_positive_eigenvalues(x), 2*card_zero_eigenvalues(x))
ce110 = Graph("GUxvuw")
ce110.name(new = "ce110")
add_to_lists(ce110, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(lovasz_theta(x), max_degree(x)/card_center(x))
ce112 = Graph("flthktLhme|L|L]efhg|LbstFhhFhgbssG|L`FhiC]ecG|LCG|LaC]ew`FhnCG|L{Obstw`Fhlw`Fhi{ObssnCG|Ldw`FhmVaC]eknCG|LknCG|L??????_?????G")
ce112.name(new = "ce112")
add_to_lists(ce112, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(e^average_distance(x), max_degree(x)^2)
ce114 = Graph("~?@W?g??????????????????_???O??A???@c???W?S?P????O?@?@??G??????A????????O?????????????G??_?O?@G??????a??????GO???O????????C????O?A?@?AO???G_?AAG_?????o???????????????I??DG????????G??A_????C??O?G??_?_?????_G???????`??@??????A??C????OA?BG???????C?_???????a?@??O??_G?????????@@???O??????C@???A?A??G????????????@???_?????G?@O??????E???????????????O???@?E?O????G????C????A@????????A?????A_?Q???????AOO?@_?@??????????OG????g?????_?CG?????AA???O?G?????????__???????@??A??Q?????GOG??C????@??CC???????@???????G?C@???A??_?????A?????_????AC??C?@??????_?C??A???G???A???OGA????????A????_????K??O??????????@?????a???_??O??`??????A?????G???@?OOC??C???_?????")
ce114.name(new = "ce114")
add_to_lists(ce114, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= 2*wilf(x)^2 + radius(x)
ce115 = Graph("z??C????????A????AA?_??G????????????C?????_??@?????????????G?@??C?????A??C?????C??????C?????????C??????????O?_?????????????G@??A?C???O?????AC?????????O???@???_?S??????I???C???O?G????????G??C?_????A_??CG?A?????????_????A????????????????G???C???????????CC?G???C?????_????????o?I???_???????")
ce115.name(new = "ce115")
add_to_lists(ce115, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= card_periphery(x) + floor(e^laplacian_energy(x))
ce116 = Graph("J?Bzvrw}Fo?")
ce116.name(new = "ce116")
add_to_lists(ce116, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= residue(x)^2/density(x)
ce117 = Graph("N???F~}~f{^_z_~_^o?")
ce117.name(new = "ce117")
add_to_lists(ce117, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(caro_wei(x), e^different_degrees(x))^2
ce118 = Graph("O????B~~v}^w~o~o^wF}?")
ce118.name(new = "ce118")
add_to_lists(ce118, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= 10^sinh(average_vertex_temperature(x) + card_center(x))
ce119 = Graph("\?@CoO_CDOC?G?_?O?CO?_?BO?C???O?Bw??k??D_??O???_???C???A???@????g????")
ce119.name(new = "ce119")
add_to_lists(ce119, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= maximum(girth(x), min_degree(x))^laplacian_energy(x)
ce120 = Graph("^????????????????????X~~Umf|mezrBcjoezwF^{_Un}?|w{?kQ[?@Z}?FNl??Etw??Oz??F~Z_??")
ce120.name(new = "ce120")
add_to_lists(ce120, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= (2*girth(x))^card_periphery(x)
ce121 = Graph("~?@HhCGGC@?G?_@?@??_?G?@??C??G??G??C??@???G???_??@???@????_???G???@????C????G????G????C????@?????G?????_????@?????@??????_?????G?????@??????C??????G??????G??????C??????@???????G???????_??????@???????@????????_???????G???????@????????C????????G????????G????????C????????@?????????G?????????_????????@?????????@??????????_?????????G?????????@??????????C??????????G??????????G??????????C??????????@???????????G???????????_??????????@???????????@")
ce121.name(new = "ce121")
add_to_lists(ce121, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= ceil(laplacian_energy(x)*max_degree(x))
ce122 = Graph("~?@B??????????????????????????????????????????????????????????????????????????????????B\jeRlsk[rya~Sdr[HeojcW}xwcX_TgTVa?UhcYC?BTaaSo?}YoCRo@ov@_b?EysEu}?Do`uhm?@Ebfkm??~AHGh_?Awyl{w??TrUZDg??AuxBGO??FJ{LUo??O_IF]g??EVmFSY???`YcP_????l|v`}???Bg_[ge???ERCdO[???APuTc^????NQUWCO???B[QrBO????BMP^A_????eo{v`_????NgB\A_????O[Q@HO????@V_oTC?????FCDLPo????AECLPI?????DqZqCE??????")
ce122.name(new = "ce122")
add_to_lists(ce122, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= minimum(cvetkovic(x), 10^laplacian_energy(x))
ce123 = Graph("`??????????????????????????????????????????^^}nx~~[~~x}^k~~F~v^o^~vm@^~~wF~v}_F~~^_B~~~W?")
ce123.name(new = "ce123")
add_to_lists(ce123, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= minimum(fractional_alpha(x), 10^laplacian_energy(x))
ce124 = Graph("Z????????????????????~~~~~v~vf|~b~~o~~sF~~_^~}?~|k?z~w?^~}??")
ce124.name(new = "ce124")
add_to_lists(ce124, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= ceil(e^caro_wei(x))
ce125 = Graph("L??F~z{~FwN_~?")
ce125.name(new = "ce125")
add_to_lists(ce125, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= ceil(e^inverse_degree(x))
ce126 = Graph("Ov~~~}Lvs]^~~~~t~~}yJ")
ce126.name(new = "ce126")
add_to_lists(ce126, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= minimum(annihilation_number(x), 10^laplacian_energy(x))
ce127 = Graph("[??????~~~^{~w~w^{F~?~WB~_F~?F~?B~_?~w?F~??^s??~w??~w??^{??F~???")
ce127.name(new = "ce127")
add_to_lists(ce127, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= (diameter(x) + 1)*residue(x)
ce128 = Graph("M????B~~v}^w~o~o?")
ce128.name(new = "ce128")
add_to_lists(ce128, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= floor(10^sqrt(average_distance(x)))
ce129 = Graph("X????????????????????????????F~~~~z~~~Z~~{n}|u~utn~")
ce129.name(new = "ce129")
add_to_lists(ce129, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= minimum(lovasz_theta(x), 10^laplacian_energy(x))
ce130 = Graph("]?????????????????F|~nzz~~f~~F|~B~~_~~WF~~?^~{?nng?~~w?^^{?F~n??~~w?@~~_??")
ce130.name(new = "ce130")
add_to_lists(ce130, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= (residue(x) + 1)*girth(x)
ce131 = Graph("W?????????^~~}~}^~F~o~}B~wF}oF~oB~w?~}?F~o?^~??")
ce131.name(new = "ce131")
add_to_lists(ce131, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) <= minimum(size(x), 10^laplacian_energy(x))
ce132 = Graph("b????????????????????~~|~~|}~x~n~vp~{Nz{^e~svN}Xc~zFKZ~uyX[z[J\\ti@M~mT@]}X{SzQZQQ^posGNlZg?R}lp`LX{L?")
ce132.name(new = "ce132")
add_to_lists(ce132, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -brinkmann_steffen(x) - girth(x) + matching_number(x)
ce133 = Graph("~?@VNtyzkW^v~_?UMVuzfYa_~}|tWZ}v~~v}WgheAI[pTRjr\\Wv}y~VeypzF\\^zmq}C\\UFoD^XJFQwvU^AovUND~XnF]STE_EF~v^~~JF\\X{X\\VFoeMvmy~xzZv\\^{|n~v~~~^v}y~xz]Wihy_Lzmq]CxSawvUNFZr]zj~fl|vMy~wz^Z}q}MxvsZv\\^{|nnuMy~wr^\\vmy~xz^^z~\\^}|nny{qUMHRpZSSE_EC_A@VXJAShyGe|vV~NZz~i}vUNnZr~n]zj~fl|vr^u~p~~}~~z}v}N~~v~~nzNwzf^\\n~TuQodI]AHvuMy^wr^\\wkNz^w~|~^}~y}vUNNZr~n~v}y~|z^^|~~^zn~~n~~v~y}q]MxVtZn|y{qUMHRpZfx|WyhIbL|vap[~}~~~~~~~~~}|vV~NZz~fz~jzHWydNDmzvz~~~~~~~~~~~~c?AGgA]Kw_PC_?_???O?????V~v~~~^~~n~~}\\uRofIca@FHcd~z~N~~~~~~~}Zaw}?oscOOx?d}ptR|EZznDbxsj~z~~~~~~~~~}^cAAYgA^KwgPCc]~v^~~^~~n~~}znz\\w~|~^}~~~r|v}y~|z^^|~~~t^Vuyp|z]^|~~~dZz~\\^{|nn}~~~ynw")
ce133.name(new = "ce133")
add_to_lists(ce133, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= -max_common_neighbors(x) + min_degree(x) - 1
ce134 = Graph('rQjxS{d~tvtrkz~pIJZ{gflAUdYPfybdzswqqS~i`~EfCmswgpu[zfAxLl\TtJEFlilHnZicmo}ZYJjAluT]d|scS\LgJ[|cs~}TBXxNQnJxSm]}oSMt{\kxUl|UhPZHlz`smizxCPTiNL[Mv|kbKUI}^r}oiAdMLE\^rga{v]z@U]Hb}wupjLh`Yg|Rn|`b[iLNp}Oudo~r_`oFEjTzvw')
ce134.name(new = "ce134")
add_to_lists(ce134, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= floor(tan(brooks(x)))
ce135 = Graph('Nzx~VT}yzxNd^J^Jn~w')
ce135.name(new = "ce135")
add_to_lists(ce135, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= floor(lovasz_theta(x))*sin(gutman_energy(x))
paley_17 = graphs.PaleyGraph(17)
paley_17.name(new = "paley_17")
add_to_lists(paley_17, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= ceil(lovasz_theta(x)) - diameter(x)
# CE to independence_number(x) >= ceil(lovasz_theta(x)) - radius(x)
paley_37 = graphs.PaleyGraph(37)
paley_37.name(new = "paley_37")
add_to_lists(paley_37, graph_objects, counter_examples, all_graphs)

# CE to independence_number(x) >= minimum(floor(lovasz_theta(x)), tan(randic(x)))
paley_53e = graphs.PaleyGraph(53)
paley_53e.add_edge(52,53)
paley_53e.name(new = "paley_53e")
add_to_lists(paley_53e, graph_objects, counter_examples, all_graphs)

paley_101 = graphs.PaleyGraph(101)
paley_101.name(new = "paley_101")
add_to_lists(paley_101, graph_objects, all_graphs)

# CE to independence_number(x) >= cos(alon_spencer(x))*floor(lovasz_theta(x))
paley_149 = graphs.PaleyGraph(149)
paley_149.name(new = "paley_149")
add_to_lists(paley_149, graph_objects, counter_examples, all_graphs)

#a K5 with a pendant
# CE to dirac => regular or planar
k5pendant = Graph('E~}?')
k5pendant.name(new="k5pendant")
add_to_lists(k5pendant, graph_objects, counter_examples, all_graphs)

#alon_seymour graph:
# CE to the rank-coloring conjecture,
# 56-regular, vertex_trans, alpha=2, omega=22, chi=chi'=edge_connect=56
alon_seymour=Graph([range(64), lambda x,y : operator.xor(x,y) not in (0,1,2,4,8,16,32,63)])
alon_seymour.name(new="alon_seymour")
add_to_lists(alon_seymour, problem_graphs, counter_examples, all_graphs)

edge_critical_5=graphs.CycleGraph(5)
edge_critical_5.add_edge(0,3)
edge_critical_5.add_edge(1,4)
edge_critical_5.name(new="edge_critical_5")
add_to_lists(edge_critical_5, graph_objects, chromatic_index_critical, all_graphs)

# CE to independence_number(x) >= min(e - n + 1, diameter(x))
heather = graphs.CompleteGraph(4)
heather.add_vertex()
heather.add_vertex()
heather.add_edge(0,4)
heather.add_edge(5,4)
heather.name(new="heather")
add_to_lists(heather, graph_objects, counter_examples, all_graphs)

#residue = alpha = 3
# CE to residue = alpha => is_ore
ryan3=graphs.CycleGraph(15)
for i in range(15):
    for j in [1,2,3]:
        ryan3.add_edge(i,(i+j)%15)
        ryan3.add_edge(i,(i-j)%15)
ryan3.name(new="ryan3")
add_to_lists(ryan3, graph_objects, counter_examples, all_graphs)

#sylvester graph: 3-reg, 3 bridges, no perfect matching (why Petersen theorem requires no more than 2 bridges)
sylvester = Graph('Olw?GCD@o??@?@?A_@o`A')
sylvester.name(new="sylvester")
add_to_lists(sylvester, graph_objects, all_graphs)

star_1_1_3 = graphs.PathGraph(4)
star_1_1_3.add_vertex()
star_1_1_3.add_edge(1,4)
star_1_1_3.name(new="fork")
add_to_lists(star_1_1_3, graph_objects, all_graphs)

# one of the 2 order 11 chromatic edge-critical graphs discovered by brinkmann and steffen
edge_critical_11_1 = graphs.CycleGraph(11)
edge_critical_11_1.add_edge(0,2)
edge_critical_11_1.add_edge(1,6)
edge_critical_11_1.add_edge(3,8)
edge_critical_11_1.add_edge(5,9)
edge_critical_11_1.name(new="edge_critical_11_1")
add_to_lists(edge_critical_11_1, graph_objects, chromatic_index_critical, all_graphs)

#one of the 2 order 11 chromatic edge-critical graphs discovered by brinkmann and steffen
edge_critical_11_2 = graphs.CycleGraph(11)
edge_critical_11_2.add_edge(0,2)
edge_critical_11_2.add_edge(3,7)
edge_critical_11_2.add_edge(6,10)
edge_critical_11_2.add_edge(4,9)
edge_critical_11_2.name(new="edge_critical_11_2")
add_to_lists(edge_critical_11_2, graph_objects, chromatic_index_critical, all_graphs)

# chromatic_index_critical but not overfull
pete_minus=graphs.PetersenGraph()
pete_minus.delete_vertex(9)
pete_minus.name(new="pete_minus")
add_to_lists(pete_minus, graph_objects, chromatic_index_critical, all_graphs)

"""
The Haemers graph was considered by Haemers who showed that alpha(G)=theta(G)<vartheta(G).
The graph is a 108-regular graph on 220 vertices. The vertices correspond to the 3-element
subsets of {1,...,12} and two such vertices are adjacent whenever the subsets
intersect in exactly one element.

    sage: haemers
    haemers: Graph on 220 vertices
    sage: haemers.is_regular()
    True
    sage: max(haemers.degree())
    108
"""
haemers = Graph([Subsets(12,3), lambda s1,s2: len(s1.intersection(s2))==1])
haemers.relabel()
haemers.name(new="haemers")
add_to_lists(haemers, problem_graphs, all_graphs)

"""
The Pepper residue graph was described by Ryan Pepper in personal communication.
It is a graph which demonstrates that the residue is not monotone. The graph is
constructed by taking the complete graph on 3 vertices and attaching a pendant
vertex to each of its vertices, then taking two copies of this graph, adding a
vertex and connecting it to all the pendant vertices. This vertex has degree
sequence [6, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2] which gives residue equal to 4.
By removing the central vertex with degree 6, you get a graph with degree
sequence [3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1] which has residue equal to 5.

    sage: pepper_residue_graph
    pepper_residue_graph: Graph on 13 vertices
    sage: sorted(pepper_residue_graph.degree(), reverse=True)
    [6, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2]
    sage: residue(pepper_residue_graph)
    4
    sage: residue(pepper_residue_graph.subgraph(vertex_property=lambda v:pepper_residue_graph.degree(v)<6))
    5
"""
pepper_residue_graph = graphs.CompleteGraph(3)
pepper_residue_graph.add_edges([(i,i+3) for i in range(3)])
pepper_residue_graph = pepper_residue_graph.disjoint_union(pepper_residue_graph)
pepper_residue_graph.add_edges([(0,v) for v in pepper_residue_graph.vertices() if pepper_residue_graph.degree(v)==1])
pepper_residue_graph.relabel()
pepper_residue_graph.name(new="pepper_residue_graph")
add_to_lists(pepper_residue_graph, graph_objects, all_graphs)

"""
The Barrus graph was suggested by Mike Barrus in "Havel-Hakimi residues of Unigraphs" (2012) as an example of a graph whose residue (2) is
less than the independence number of any realization of the degree sequence. The degree sequence is [4^8,2].
The realization is the one given by reversing the Havel-Hakimi process.

    sage: barrus_graph
    barrus_graph: Graph on 9 vertices
    sage: residue(barrus_graph)
    2
    sage: independence_number(barrus_graph)
    3
"""
barrus_graph = Graph('HxNEG{W')
barrus_graph.name(new = "barrus_graph")
add_to_lists(barrus_graph, graph_objects, all_graphs)

# CE to (is_split)->((is_eulerian)->(is_regular))
# split graph from k4 and e2 that is eulerian but not regular
# isomorphic to c6 with a k4 subgraph
# eulerain, diameter = 3, radius=2, hamiltonian

k4e2split = graphs.CompleteGraph(4)
k4e2split.add_vertices([4,5])
k4e2split.add_edge(4,0)
k4e2split.add_edge(4,1)
k4e2split.add_edge(5,2)
k4e2split.add_edge(5,3)
k4e2split.name(new = "k4e2split")
add_to_lists(k4e2split, graph_objects, counter_examples, all_graphs)

# CE to (has_residue_equals_alpha)->((is_eulerian)->(alpha_leq_order_over_two))
triangle_star = Graph("H}qdB@_")
triangle_star.name(new = "triangle_star")
add_to_lists(triangle_star, graph_objects, counter_examples, all_graphs)

#flower with n petals
def flower(n):
    g = graphs.StarGraph(2*n)
    for x in range(n):
        v = 2*x+1
        g.add_edge(v,v+1)
    return g

flower_with_3_petals = flower(3)
flower_with_3_petals.name(new = "flower_with_3_petals")
add_to_lists(flower_with_3_petals, graph_objects, all_graphs)

flower_with_4_petals = flower(4)
flower_with_4_petals.name(new = "flower_with_4_petals")
add_to_lists(flower_with_4_petals, graph_objects, all_graphs)

# Gallai Tree graph
gallai_tree = Graph("`hCKGC@?G@?K?@?@_?w?@??C??G??G??c??o???G??@_??F???N????_???G???B????C????W????G????G????C")
gallai_tree.name(new = "gallai_tree")
add_to_lists(gallai_tree, graph_objects, all_graphs)

# Trigonal Antiprism w/ capped top face
trig_antiprism_capped = Graph("Iw?EthkF?")
trig_antiprism_capped.name(new = "trig_antiprism_capped")
add_to_lists(trig_antiprism_capped, graph_objects, all_graphs)

"""
From Willis's thesis, page 4
Alpha = Fractional Alpha = 4

    sage: independence_number(willis_page4)
    4
    sage: fractional_alpha(willis_page4)
    4.0
"""
willis_page4 = Graph("GlCKIS")
willis_page4.name(new = "willis_page4")
add_to_lists(willis_page4, graph_objects, all_graphs)

"""
From Willis's thesis, page 7

    sage: willis_page7.radius()
    2
    sage: willis_page7.average_distance()
    22/15
"""
willis_page7 = Graph("ELRW")
willis_page7.name(new = "willis_page7")
add_to_lists(willis_page7, graph_objects, all_graphs)

"""
From Willis's thesis, page 13, Fig. 2.7

    sage: independence_number(willis_page13_fig27)
    3
    sage: willis_page13_fig27.order()
    7
    sage: willis_page13_fig27.size()
    15
"""
willis_page13_fig27 = Graph("Fs\zw")
willis_page13_fig27.name(new = "willis_page13_fig27")
add_to_lists(willis_page13_fig27, graph_objects, all_graphs)

"""
From Willis's thesis, page 10, Figure 2.3
Graph for which the Cvetkovic bound is the best upper bound present in the thesis

    sage: independence_number(willis_page10_fig23)
    3
    sage: willis_page10_fig23.order()
    8
    sage: willis_page10_fig23.size()
    15
    sage: max_degree(willis_page10_fig23)
    6
    sage: min_degree(willis_page10_fig23)
    2
"""
willis_page10_fig23 = Graph("G|eKHw")
willis_page10_fig23.name(new = "willis_page10_fig23")
add_to_lists(willis_page10_fig23, graph_objects, all_graphs)

"""
From Willis's thesis, page 10, Figure 2.4
Graph for which the Cvetkovic bound is the best upper bound present in the thesis

    sage: independence_number(willis_page10_fig24)
    9
    sage: willis_page10_fig24.order()
    24
    sage: willis_page10_fig24.size()
    36
    sage: max_degree(willis_page10_fig24)
    3
    sage: min_degree(willis_page10_fig24)
    3
"""
willis_page10_fig24 = Graph("WvOGWK@?G@_B???@_?O?F?????G??W?@K_?????G??@_?@B")
willis_page10_fig24.name(new = "willis_page10_fig24")
add_to_lists(willis_page10_fig24, graph_objects, all_graphs)

"""
From Willis's thesis, page 13, Figure 2.6
Graph for which the fractional independence bound is the best upper bound present in the thesis

    sage: independence_number(willis_page13_fig26)
    3
    sage: willis_page13_fig26.order()
    7
    sage: willis_page13_fig26.size()
    12
    sage: max_degree(willis_page13_fig26)
    4
    sage: min_degree(willis_page13_fig26)
    3
"""
willis_page13_fig26 = Graph("FstpW")
willis_page13_fig26.name(new = "willis_page13_fig26")
add_to_lists(willis_page13_fig26, graph_objects, all_graphs)

"""
From Willis's thesis, page 21, Figure 3.1
Graph for which n/chi is the best lower bound present in the thesis

    sage: independence_number(willis_page21)
    4
    sage: willis_page21.order()
    12
    sage: willis_page21.size()
    20
    sage: max_degree(willis_page21)
    4
    sage: willis_page21.chromatic_number()
    3
"""
willis_page21 = Graph("KoD?Xb?@hBBB")
willis_page21.name(new = "willis_page21")
add_to_lists(willis_page21, graph_objects, all_graphs)

"""
From Willis's thesis, page 25, Figure 3.2
Graph for which residue is the best lower bound present in the thesis

    sage: independence_number(willis_page25_fig32)
    3
    sage: willis_page25_fig32.order()
    8
    sage: willis_page25_fig32.size()
    15
    sage: max_degree(willis_page25_fig32)
    6
    sage: willis_page25_fig32.chromatic_number()
    4
"""
willis_page25_fig32 = Graph("G@N@~w")
willis_page25_fig32.name(new = "willis_page25_fig32")
add_to_lists(willis_page25_fig32, graph_objects, all_graphs)

"""
From Willis's thesis, page 25, Figure 3.3
Graph for which residue is the best lower bound present in the thesis

    sage: independence_number(willis_page25_fig33)
    4
    sage: willis_page25_fig33.order()
    14
    sage: willis_page25_fig33.size()
    28
    sage: max_degree(willis_page25_fig33)
    4
    sage: willis_page25_fig33.chromatic_number()
    4
"""
willis_page25_fig33 = Graph("Mts?GKE@QDCIQIKD?")
willis_page25_fig33.name(new = "willis_page25_fig33")
add_to_lists(willis_page25_fig33, graph_objects, all_graphs)

# The Lemke Graph
lemke = Graph("G_?ztw")
lemke.name(new = "Lemke")
add_to_lists(lemke, graph_objects, all_graphs)

"""
From Willis's thesis, page 29, Figure 3.6
Graph for which the Harant Bound is the best lower bound present in the thesis

    sage: independence_number(willis_page29)
    13
    sage: willis_page29.order()
    28
    sage: willis_page29.size()
    42
    sage: max_degree(willis_page29)
    3
    sage: willis_page29.chromatic_number()
    3
"""
willis_page29 = mobius_ladder(14)
willis_page29.name(new = "willis_page29")
add_to_lists(willis_page29, graph_objects, all_graphs)

"""
From Willis's thesis, page 35, Figure 5.1
A graph where none of the upper bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page35_fig51)
    2
    sage: willis_page35_fig51.order()
    10
"""
willis_page35_fig51 = Graph("I~rH`cNBw")
willis_page35_fig51.name(new = "willis_page35_fig51")
add_to_lists(willis_page35_fig51, graph_objects, all_graphs)

"""
From Willis's thesis, page 35, Figure 5.2
A graph where none of the upper bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page35_fig52)
    2
    sage: willis_page35_fig52.order()
    10
"""
willis_page35_fig52 = Graph("I~zLa[vFw")
willis_page35_fig52.name(new = "willis_page35_fig52")
add_to_lists(willis_page35_fig52, graph_objects, all_graphs)

"""
From Willis's thesis, page 36, Figure 5.3
A graph where none of the upper bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page36_fig53)
    4
    sage: willis_page36_fig53.order()
    11
"""
willis_page36_fig53 = Graph("JscOXHbWqw?")
willis_page36_fig53.name(new = "willis_page36_fig53")
add_to_lists(willis_page36_fig53, graph_objects, all_graphs)

"""
From Willis's thesis, page 36, Figure 5.4
A graph where none of the upper bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page36_fig54)
    2
    sage: willis_page36_fig54.order()
    9
    sage: willis_page36_fig54.size()
    24
"""
willis_page36_fig54 = Graph("H~`HW~~")
willis_page36_fig54.name(new = "willis_page36_fig54")
add_to_lists(willis_page36_fig54, graph_objects, all_graphs)

"""
From Willis's thesis, page 36, Figure 5.5
A graph where none of the lower bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page36_fig55)
    3
    sage: willis_page36_fig55.order()
    7
    sage: willis_page36_fig55.size()
    13
"""
willis_page36_fig55 = Graph("F@^vo")
willis_page36_fig55.name(new = "willis_page36_fig55")
add_to_lists(willis_page36_fig55, graph_objects, all_graphs)

"""
From Willis's thesis, page 37, Figure 5.6
A graph where none of the lower bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page37_fig56)
    3
    sage: willis_page37_fig56.order()
    7
    sage: willis_page37_fig56.size()
    15
"""
willis_page37_fig56 = Graph("Fimzw")
willis_page37_fig56.name(new = "willis_page37_fig56")
add_to_lists(willis_page37_fig56, graph_objects, all_graphs)

"""
From Willis's thesis, page 37, Figure 5.8
A graph where none of the lower bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page37_fig58)
    4
    sage: willis_page37_fig58.order()
    9
    sage: willis_page37_fig58.size()
    16
    sage: min_degree(willis_page37_fig58)
    2
    sage: max_degree(willis_page37_fig58)
    6
"""
willis_page37_fig58 = Graph("H?iYbC~")
willis_page37_fig58.name(new = "willis_page37_fig58")
add_to_lists(willis_page37_fig58, graph_objects, all_graphs)

"""
From Willis's thesis, page 38, Figure 5.9
A graph where none of the lower bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page38)
    3
    sage: willis_page38.order()
    7
    sage: willis_page38.size()
    13
"""
willis_page38 = Graph("FSpzw")
willis_page38.name(new = "willis_page38")
add_to_lists(willis_page38, graph_objects, all_graphs)

"""
From Willis's thesis, page 39, Figure 5.10
A graph where none of the upper or lower bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page39_fig510)
    5
    sage: willis_page39_fig510.order()
    12
    sage: willis_page39_fig510.size()
    18
"""
willis_page39_fig510 = Graph("Kt?GOKEOGal?")
willis_page39_fig510.name(new = "willis_page39_fig510")
add_to_lists(willis_page39_fig510, graph_objects, all_graphs)

"""
From Willis's thesis, page 40, Figure 5.12
A graph where none of the upper or lower bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page40_fig512)
    6
    sage: willis_page40_fig512.order()
    14
    sage: willis_page40_fig512.size()
    21
"""
willis_page40_fig512 = Graph("Ms???\?OGdAQJ?J??")
willis_page40_fig512.name(new = "willis_page40_fig512")
add_to_lists(willis_page40_fig512, graph_objects, all_graphs)

"""
From Willis's thesis, page 40, Figure 5.13
A graph where none of the upper or lower bounds in the thesis give the exact value for alpha
"""
willis_page40_fig513 = Graph("UhCGKE??Q?_D?K??__g?@G?C??OC???ACG?DC??_")
willis_page40_fig513.name(new = "willis_page40_fig513")
add_to_lists(willis_page40_fig513, graph_objects, all_graphs)

"""
From Willis's thesis, page 41, Figure 5.14
A graph where none of the upper or lower bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page41_fig514)
    5
    sage: willis_page41_fig514.order()
    12
    sage: willis_page41_fig514.size()
    18
"""
willis_page41_fig514 = Graph("Kt?GGGBQGeL?")
willis_page41_fig514.name(new = "willis_page41_fig514")
add_to_lists(willis_page41_fig514, graph_objects, all_graphs)

"""
From Willis's thesis, page 41, Figure 5.15
A graph where none of the upper or lower bounds in the thesis give the exact value for alpha

    sage: independence_number(willis_page41_fig515)
    4
    sage: willis_page41_fig515.order()
    11
    sage: willis_page41_fig515.size()
    22
"""
willis_page41_fig515 = Graph("JskIIDBLPh?")
willis_page41_fig515.name(new = "willis_page41_fig515")
add_to_lists(willis_page41_fig515, graph_objects, all_graphs)

"""
From Elphick-Wocjan page 8
"""
elphick_wocjan_page8 = Graph("F?Azw")
elphick_wocjan_page8.name(new = "Elphick-Wocjan p.8")
add_to_lists(elphick_wocjan_page8, graph_objects, all_graphs)

"""
From Elphick-Wocjan page 9
"""
elphick_wocjan_page9 = Graph("FqhXw")
elphick_wocjan_page9.name(new = "Elphick-Wocjan p.9")
add_to_lists(elphick_wocjan_page9, graph_objects, all_graphs)

"""
An odd wheel with 8 vertices
p.175
Rebennack, Steffen, Gerhard Reinelt, and Panos M. Pardalos. "A tutorial on branch and cut algorithms for the maximum stable set problem." International Transactions in Operational Research 19.1-2 (2012): 161-199.

    sage: odd_wheel_8.order()
    8
    sage: odd_wheel_8.size()
    14
"""
odd_wheel_8 = Graph("G|eKMC")
odd_wheel_8.name(new = "odd_wheel_8")
add_to_lists(odd_wheel_8, graph_objects, all_graphs)

"""
A facet-inducing graph
p.176
Rebennack, Steffen, Gerhard Reinelt, and Panos M. Pardalos. "A tutorial on branch and cut algorithms for the maximum stable set problem." International Transactions in Operational Research 19.1-2 (2012): 161-199.

    sage: facet_inducing.order()
    8
    sage: facet_inducing.size()
    11
"""
facet_inducing = Graph("G@hicc")
facet_inducing.name(new = "facet_inducing")
add_to_lists(facet_inducing, graph_objects, all_graphs)

"""
Double Fork
p.185
Rebennack, Steffen, Gerhard Reinelt, and Panos M. Pardalos. "A tutorial on branch and cut algorithms for the maximum stable set problem." International Transactions in Operational Research 19.1-2 (2012): 161-199.

    sage: double_fork.order()
    6
    sage: double_fork.size()
    5
"""
double_fork = Graph("E?dg")
double_fork.name(new = "double_fork")
add_to_lists(double_fork, graph_objects, all_graphs)

double_fork_sub = Graph("G??MPg")
double_fork_sub.name(new = "double_fork_sub")
add_to_lists(double_fork_sub, graph_objects, all_graphs)

"""
Golomb Graph
Appears in THE FRACTIONAL CHROMATIC NUMBER OF THE PLANE by Cranston and Rabern
"""
golomb = Graph("I?C]dPcww")
golomb.name(new = "Golomb Graph")
add_to_lists(golomb, graph_objects, all_graphs)

"""
Fig. 1, p. 2 of
Steinberg’s Conjecture is false by
 Vincent Cohen-Addad, Michael Hebdige, Daniel Král,
 Zhentao Li, Esteban Salgado
"""
steinberg_ce_g1 = Graph("N?CWGOOOH@OO_POdCHO")
steinberg_ce_g1.name(new = "steinberg_ce_g1")
add_to_lists(steinberg_ce_g1, graph_objects, counter_examples, all_graphs)

"""
Fig. 2, p. 3 of
Steinberg’s Conjecture is false by
 Vincent Cohen-Addad, Michael Hebdige, Daniel Král,
 Zhentao Li, Esteban Salgado
"""
steinberg_ce_g2 = Graph("ihCGGC@?G?o@o???_?H?@??K??Go?K?G??B???@gW?????G???P???K???@????P???@????B????BG????_?G??G?????G????A?O???H?????C????`?_???CO??????P?K????o@_????o")
steinberg_ce_g2.name(new = "steinberg_ce_g2")
add_to_lists(steinberg_ce_g2, graph_objects, counter_examples, all_graphs)

"""
Fig. 3, p. 4 of
Steinberg’s Conjecture is false by
 Vincent Cohen-Addad, Michael Hebdige, Daniel Král,
 Zhentao Li, Esteban Salgado
"""
steinberg_ce_g3 = Graph("mhE?GC@?G?`@AG?G_?G?@_?E?????GO?EG????O????`??@_??G????_???GO??@?????????G????GO???CG???GA??????????_????@????AHA???????????O????O???????O??????_??????_???C??O???A??C????_??_")
steinberg_ce_g3.name(new = "steinberg_ce_g3")
add_to_lists(steinberg_ce_g3, graph_objects, counter_examples, all_graphs)

"""
4-pan from p. 1691 of
Graphs with the Strong Havel–Hakimi Property by Michael D. Barrus and Grant Molnar
"""
four_pan = Graph("DBw")
four_pan.name(new = "4-pan")
add_to_lists(four_pan, graph_objects, all_graphs)

"""
kite from p. 1691 of
Graphs with the Strong Havel–Hakimi Property by Michael D. Barrus and Grant Molnar
NOTE: Called kite in the paper, but will be called kite_with_tail here because we already have a kite
"""
kite_with_tail = Graph("DJk")
kite_with_tail.name(new = "kite with tail")
add_to_lists(kite_with_tail, graph_objects, all_graphs)

"""
Chartrand Fig 1.1

    sage: chartrand_11.order()
    8
    sage: chartrand_11.size()
    15
"""
chartrand_11 = Graph("G`RHx{")
chartrand_11.name(new = "chartrand fig 1.1")
add_to_lists(chartrand_11, graph_objects, all_graphs)

"""
Chartrand Fig 1.2

    sage: chartrand_12.order()
    8
    sage: chartrand_12.size()
    9
"""
chartrand_12 = Graph("G??|Qo")
chartrand_12.name(new = "chartrand fig 1.2")
add_to_lists(chartrand_12, graph_objects, all_graphs)

"""
Chartrand Fig 1.3

    sage: chartrand_13.order()
    8
    sage: chartrand_13.size()
    10
"""
chartrand_13 = Graph("G`o_g[")
chartrand_13.name(new = "chartrand fig 1.3")
add_to_lists(chartrand_13, graph_objects, all_graphs)

"""
Chartrand Fig 1.8 - G

    sage: chartrand_18_g.order()
    7
    sage: chartrand_18_g.size()
    8
"""
chartrand_18_g = Graph("Fo@Xo")
chartrand_18_g.name(new = "chartrand fig 1.8 - G")
add_to_lists(chartrand_18_g, graph_objects, all_graphs)

"""
Chartrand Fig 1.8 - F1

    sage: chartrand_18_f1.order()
    7
    sage: chartrand_18_f1.size()
    10
"""
chartrand_18_f1 = Graph("F@J]o")
chartrand_18_f1.name(new = "chartrand fig 1.8 - F1")
add_to_lists(chartrand_18_f1, graph_objects, all_graphs)

"""
Chartrand Fig 1.8 - F2

    sage: chartrand_18_f2.order()
    7
    sage: chartrand_18_f2.size()
    10
"""
chartrand_18_f2 = Graph("F?NVo")
chartrand_18_f2.name(new = "chartrand fig 1.8 - F2")
add_to_lists(chartrand_18_f2, graph_objects, all_graphs)

"""
Chartrand Fig 1.10 - H1
CE to independence_number(x) <= maximum(girth(x), card_center(x) + card_periphery(x))

    sage: chartrand_110_h1.order()
    7
    sage: chartrand_110_h1.size()
    7
"""
chartrand_110_h1 = Graph("F@@Kw")
chartrand_110_h1.name(new = "chartrand fig 1.10 - H1")
add_to_lists(chartrand_110_h1, graph_objects, counter_examples, all_graphs)

"""
Chartrand Fig 1.10 - H2

    sage: chartrand_110_h2.order()
    7
    sage: chartrand_110_h2.size()
    7
"""
chartrand_110_h2 = Graph("F?C^G")
chartrand_110_h2.name(new = "chartrand fig 1.10 - H2")
add_to_lists(chartrand_110_h2, graph_objects, all_graphs)

"""
Chartrand Fig 1.10 - H3

    sage: chartrand_110_h3.order()
    9
    sage: chartrand_110_h3.size()
    8
"""
chartrand_110_h3 = Graph("H???]Os")
chartrand_110_h3.name(new = "chartrand fig 1.10 - H3")
add_to_lists(chartrand_110_h3, graph_objects, all_graphs)

"""
Chartrand Fig 1.10 - H4

    sage: chartrand_110_h4.order()
    9
    sage: chartrand_110_h4.size()
    8
"""
chartrand_110_h4 = Graph("H?C?JEK")
chartrand_110_h4.name(new = "chartrand fig 1.10 - H4")
add_to_lists(chartrand_110_h4, graph_objects, all_graphs)

# From their Mathing Theory book
lovasz_plummer = Graph('iOQBC__???G_?OCG@??C???_C?G?@_?__??????_??@???E?C?C?A?A??CC????O???@??G??_????o?????????A?????O????B?????A????CO?????C?????@??????C??????W?????CO')
lovasz_plummer.name(new = "lovasz_plummer graph")
add_to_lists(lovasz_plummer, graph_objects, all_graphs)

# Jorgenson graphs from: Jørgensen, Leif K. "Diameters of cubic graphs." Discrete applied mathematics 37 (1992): 347-351.
jorgenson_1 = Graph('Ss??GOG?OC?_?I?DGCa?oDO?i??_C@?AC')
jorgenson_1.name(new = "jorgenson_1")
add_to_lists(jorgenson_1, graph_objects, all_graphs)

jorgenson_2 = Graph('GtP@Ww')
jorgenson_2.name(new = "jorgenson_2")
add_to_lists(jorgenson_2, graph_objects, all_graphs)

# CGT graphs come from
#     Examples and Counter Examples in Graph Theory by Michael Capobianco and John C. Molluzzo

cgt_5 = Graph("J??GkPPgbG?")
cgt_5.name(new = "CGT Page 5")
add_to_lists(cgt_5, graph_objects, all_graphs)

cgt_10_left = Graph("E`~o")
cgt_10_left.name(new = "CGT Page 10, left")
add_to_lists(cgt_10_left, graph_objects, all_graphs)

cgt_10_right = Graph("EFxw")
cgt_10_right.name(new = "CGT Page 10, right")
add_to_lists(cgt_10_right, graph_objects, all_graphs)

cgt_11_1221 = Graph("H`_YPN~")
cgt_11_1221.name(new = "CGT Page 11, Figure 1.22.1")
add_to_lists(cgt_11_1221, graph_objects, all_graphs)

cgt_13_bottom = Graph("Iv?GOKFY?")
cgt_13_bottom.name(new = "CGT Page 13, Bottom")
add_to_lists(cgt_13_bottom, graph_objects, all_graphs)

cgt_15_left = Graph("FD^vW")
cgt_15_left.name(new = "CGT Page 15, left")
add_to_lists(cgt_15_left, graph_objects, all_graphs)

# Sabidussi Graphs from Sabidussi, Gert. "The centrality index of a graph." Psychometrika 31.4 (1966): 581-603.

sabidussi_2 = Graph('Ls_aGcKSpiDCQH')
sabidussi_2.name(new = "sabidussi_2")
add_to_lists(sabidussi_2, graph_objects, all_graphs)

sabidussi_3 = Graph('H`?NeW{')
sabidussi_3.name(new = "sabidussi_3")
add_to_lists(sabidussi_3, graph_objects, all_graphs)

sabidussi_4 = Graph('L?O_?C@?G_oOF?')
sabidussi_4.name(new = "sabidussi_4")
add_to_lists(sabidussi_4, graph_objects, all_graphs)

sabidussi_5 = Graph('L??GH?GOC@AWKC')
sabidussi_5.name(new = "sabidussi_5")
add_to_lists(sabidussi_5, graph_objects, all_graphs)

sabidussi_6 = Graph('L??G?COGQCOCN?')
sabidussi_6.name(new = "sabidussi_6")
add_to_lists(sabidussi_6, graph_objects, all_graphs)

barnette = Graph("Ss?GOCDA?@_I@??_C?q?QC?_O@@??I??S")
barnette.name(new = "Barnette-Bosak-Lederberg Graph")
add_to_lists(barnette, graph_objects, all_graphs)

# Maximally Irregular Graphs
mir_6 = MIR(6)
mir_6.name(new = "max_irregular_6")
add_to_lists(mir_6, graph_objects, all_graphs)

mir_7 = MIR(7)
mir_7.name(new = "max_irregular_7")
add_to_lists(mir_7, graph_objects, all_graphs)

# Radius Critical Ciliates
c4_1 = Ciliate(2, 3)
c4_1.name(new = "Ciliate 4, 1")
add_to_lists(c4_1, graph_objects, all_graphs)

c4_2 = Ciliate(2, 4)
c4_2.name(new = "Ciliate 4, 2")
add_to_lists(c4_2, graph_objects, all_graphs)

c6_1 = Ciliate(3, 4)
c6_1.name(new = "Ciliate 6, 1")
add_to_lists(c6_1, graph_objects, all_graphs)

# Antiholes
"""
An odd antihole with 7 vertices
p.175
Rebennack, Steffen, Gerhard Reinelt, and Panos M. Pardalos. "A tutorial on branch and cut algorithms for the maximum stable set problem." International Transactions in Operational Research 19.1-2 (2012): 161-199.

    sage: antihole_7.order()
    7
    sage: antihole_7.size()
    14
"""
antihole_7 = Antihole(7)
antihole_7.name(new = "Antihole 7")
add_to_lists(antihole_7, graph_objects, all_graphs)

antihole_8 = Antihole(8)
antihole_8.name(new = "Antihole 8")
add_to_lists(antihole_8, graph_objects, all_graphs)

"""
p.10
Barrus, Michael D. "On fractional realizations of graph degree sequences." arXiv preprint arXiv:1310.1112 (2013).
"""
fish = Graph("E@ro")
fish.name(new = "fish")
add_to_lists(fish, graph_objects, all_graphs)

"""
p.10
Barrus, Michael D. "On fractional realizations of graph degree sequences." arXiv preprint arXiv:1310.1112 (2013).
"""
fish_mod = Graph("EiKw")
fish_mod.name(new = "fish_mod")
add_to_lists(fish_mod, graph_objects, all_graphs)

"""
All of the graphs with the name barrus_[0-9]{6} comes from the appendix of
Barrus, Michael D. "On fractional realizations of graph degree sequences." arXiv preprint arXiv:1310.1112 (2013).
"""

barrus_322111a = Graph("EAIW")
barrus_322111a.name(new = "barrus_322111a")
add_to_lists(barrus_322111a, graph_objects, all_graphs)

barrus_322111b = Graph("E?NO")
barrus_322111b.name(new = "barrus_322111b")
add_to_lists(barrus_322111b, graph_objects, all_graphs)

barrus_322221b = Graph("ECXo")
barrus_322221b.name(new = "barrus_322221b")
add_to_lists(barrus_322221b, graph_objects, all_graphs)

barrus_322221c = Graph("EAN_")
barrus_322221c.name(new = "barrus_322221c")
add_to_lists(barrus_322221c, graph_objects, all_graphs)

barrus_332211c = Graph("E@hW")
barrus_332211c.name(new = "barrus_332211c")
add_to_lists(barrus_332211c, graph_objects, all_graphs)

barrus_332211d = Graph("E?lo")
barrus_332211d.name(new = "barrus_332211d")
add_to_lists(barrus_332211d, graph_objects, all_graphs)

barrus_332222a = Graph("E`ow")
barrus_332222a.name(new = "barrus_332222a")
add_to_lists(barrus_332222a, graph_objects, all_graphs)

barrus_332222b = Graph("E`dg")
barrus_332222b.name(new = "barrus_332222b")
add_to_lists(barrus_332222b, graph_objects, all_graphs)

barrus_332222c = Graph("EoSw")
barrus_332222c.name(new = "barrus_332222c")
add_to_lists(barrus_332222c, graph_objects, all_graphs)

barrus_332222d = Graph("E_lo")
barrus_332222d.name(new = "barrus_332222d")
add_to_lists(barrus_332222d, graph_objects, all_graphs)

barrus_333221a = Graph("E`LW")
barrus_333221a.name(new = "barrus_333221a")
add_to_lists(barrus_333221a, graph_objects, all_graphs)

# CE to claw-free & chordal => Hamiltonian
barrus_333221b = Graph("EKSw")
barrus_333221b.name(new = "barrus_333221b(c5_chord_tail)")
add_to_lists(barrus_333221b, graph_objects, all_graphs)
c5_chord_tail = barrus_333221b
add_to_lists(c5_chord_tail, graph_objects, all_graphs)

barrus_333221c = Graph("EELg")
barrus_333221c.name(new = "barrus_333221c")
add_to_lists(barrus_333221c, graph_objects, all_graphs)

barrus_333221d = Graph("EC\o")
barrus_333221d.name(new = "barrus_333221d")
add_to_lists(barrus_333221d, graph_objects, all_graphs)

barrus_333311 = Graph("E@lo")
barrus_333311.name(new = "barrus_333311")
add_to_lists(barrus_333311, graph_objects, all_graphs)

barrus_333322a = Graph("ES\o")
barrus_333322a.name(new = "barrus_333322a")
add_to_lists(barrus_333322a, graph_objects, all_graphs)

barrus_333322c = Graph("ED^_")
barrus_333322c.name(new = "barrus_333322c")
add_to_lists(barrus_333322c, graph_objects, all_graphs)

barrus_422211a = Graph("EGEw")
barrus_422211a.name(new = "barrus_422211a")
add_to_lists(barrus_422211a, graph_objects, all_graphs)

barrus_422211b = Graph("E?No")
barrus_422211b.name(new = "barrus_422211b")
add_to_lists(barrus_422211b, graph_objects, all_graphs)

barrus_432221a = Graph("E@pw")
barrus_432221a.name(new = "barrus_432221a")
add_to_lists(barrus_432221a, graph_objects, all_graphs)

barrus_432221b = Graph("E_Lw")
barrus_432221b.name(new = "barrus_432221b")
add_to_lists(barrus_432221b, graph_objects, all_graphs)

barrus_432221c = Graph("EANg")
barrus_432221c.name(new = "barrus_432221c")
add_to_lists(barrus_432221c, graph_objects, all_graphs)

barrus_432221d = Graph("E?^o")
barrus_432221d.name(new = "barrus_432221d")
add_to_lists(barrus_432221d, graph_objects, all_graphs)

barrus_433222a = Graph("E@vo")
barrus_433222a.name(new = "barrus_433222a")
add_to_lists(barrus_433222a, graph_objects, all_graphs)

barrus_433222c = Graph("EPVW")
barrus_433222c.name(new = "barrus_433222c")
add_to_lists(barrus_433222c, graph_objects, all_graphs)

barrus_433222d = Graph("E`NW")
barrus_433222d.name(new = "barrus_433222d")
add_to_lists(barrus_433222d, graph_objects, all_graphs)

barrus_433321a = Graph("EIMw")
barrus_433321a.name(new = "barrus_433321a")
add_to_lists(barrus_433321a, graph_objects, all_graphs)

barrus_433321b = Graph("E@^o")
barrus_433321b.name(new = "barrus_433321b")
add_to_lists(barrus_433321b, graph_objects, all_graphs)

barrus_433321c = Graph("EPTw")
barrus_433321c.name(new = "barrus_433321c")
add_to_lists(barrus_433321c, graph_objects, all_graphs)

barrus_433332a = Graph("EBzo")
barrus_433332a.name(new = "barrus_433332a")
add_to_lists(barrus_433332a, graph_objects, all_graphs)

barrus_433332b = Graph("E`^o")
barrus_433332b.name(new = "barrus_433332b")
add_to_lists(barrus_433332b, graph_objects, all_graphs)

barrus_433332c = Graph("EqLw")
barrus_433332c.name(new = "barrus_433332c")
add_to_lists(barrus_433332c, graph_objects, all_graphs)

barrus_442222a = Graph("E?~o")
barrus_442222a.name(new = "barrus_442222a")
add_to_lists(barrus_442222a, graph_objects, all_graphs)

barrus_442222b = Graph("E_lw")
barrus_442222b.name(new = "barrus_442222b")
add_to_lists(barrus_442222b, graph_objects, all_graphs)

barrus_443322a = Graph("E@~o")
barrus_443322a.name(new = "barrus_443322a")
add_to_lists(barrus_443322a, graph_objects, all_graphs)

barrus_443322b = Graph("EHuw")
barrus_443322b.name(new = "barrus_443322b")
add_to_lists(barrus_443322b, graph_objects, all_graphs)

barrus_443322c = Graph("EImw")
barrus_443322c.name(new = "barrus_443322c")
add_to_lists(barrus_443322c, graph_objects, all_graphs)

barrus_443322d = Graph("EQlw")
barrus_443322d.name(new = "barrus_443322d")
add_to_lists(barrus_443322d, graph_objects, all_graphs)

barrus_443322e = Graph("E`lw")
barrus_443322e.name(new = "barrus_443322e")
add_to_lists(barrus_443322e, graph_objects, all_graphs)

barrus_443331a = Graph("EBxw")
barrus_443331a.name(new = "barrus_443331a")
add_to_lists(barrus_443331a, graph_objects, all_graphs)

barrus_443331b = Graph("E`\w")
barrus_443331b.name(new = "barrus_443331b")
add_to_lists(barrus_443331b, graph_objects, all_graphs)

barrus_443333a = Graph("Es\w")
barrus_443333a.name(new = "barrus_443333a")
add_to_lists(barrus_443333a, graph_objects, all_graphs)

barrus_443333c = Graph("Eqlw")
barrus_443333c.name(new = "barrus_443333c")
add_to_lists(barrus_443333c, graph_objects, all_graphs)

barrus_444332b = Graph("Ed\w")
barrus_444332b.name(new = "barrus_444332b")
add_to_lists(barrus_444332b, graph_objects, all_graphs)

barrus_444332c = Graph("EMlw")
barrus_444332c.name(new = "barrus_444332c")
add_to_lists(barrus_444332c, graph_objects, all_graphs)

barrus_444433a = Graph("ER~o")
barrus_444433a.name(new = "barrus_444433a")
add_to_lists(barrus_444433a, graph_objects, all_graphs)

barrus_444433b = Graph("Et\w")
barrus_444433b.name(new = "barrus_444433b")
add_to_lists(barrus_444433b, graph_objects, all_graphs)

"""
From:
Alcón, Liliana, Marisa Gutierrez, and Glenn Hurlbert. "Pebbling in split graphs." SIAM Journal on Discrete Mathematics 28.3 (2014): 1449-1466.
"""
pyramid = Graph("EElw")
pyramid.name(new = "pyramid")
add_to_lists(pyramid, graph_objects, all_graphs)

"""
From:
p.3
Dvořák, Zdeněk, and Jordan Venters. "Triangle-free planar graphs with small independence number." arXiv preprint arXiv:1702.02888 (2017).
"""
thomas_walls_3 = Graph("IRaIACbFG")
thomas_walls_3.name(new = "thomas_walls_3")
add_to_lists(thomas_walls_3, graph_objects, all_graphs)

"""
From:
p.3
Dvořák, Zdeněk, and Jordan Venters. "Triangle-free planar graphs with small independence number." arXiv preprint arXiv:1702.02888 (2017).
"""
thomas_walls_4 = Graph("LQCkCD?OGM@EKB")
thomas_walls_4.name(new = "thomas_walls_4")
add_to_lists(thomas_walls_4, graph_objects, all_graphs)

"""
P. 24, 1st figure
From a knuth paper, linked in issue #342
"""
knuth_24_1 = Graph("E`~w")
knuth_24_1.name(new = "knuth_24_1")
add_to_lists(knuth_24_1, graph_objects, all_graphs)

"""
P. 24, 2nd figure
From a knuth paper, linked in issue #343
"""
knuth_24_2 = Graph("Er~w")
knuth_24_2.name(new = "knuth_24_2")
add_to_lists(knuth_24_2, graph_objects, all_graphs)

"""
From Craig Larson, Critical Independence paper
Has non empty critical independence set
"""
larson = Graph("F@N~w")
larson.name(new = "larson")
add_to_lists(larson, graph_objects, all_graphs)

"""
From:
Vizing's independence number conjecture is true asymptotically
Eckhard Steffen
"""
steffen_1 = Graph("HqP@xw{")
steffen_1.name(new = "steffen_1")
add_to_lists(steffen_1, graph_objects, all_graphs)

"""
From:
Vizing's independence number conjecture is true asymptotically
Eckhard Steffen
"""
steffen_2 = Graph("N??xpow@o@?AoBoBW@_")
steffen_2.name(new = "steffen_2")
add_to_lists(steffen_2, graph_objects, all_graphs)

"""
From:
Vizing's independence number conjecture is true asymptotically
Eckhard Steffen
"""
steffen_3 = Graph("Z??xpow@o@?A?B?B?@_?C??_?@??@??A???__?Dc??kO?AoO?AWO?AWG?@K?")
steffen_3.name(new = "steffen_3")
add_to_lists(steffen_3, graph_objects, all_graphs)

"""
From:
p.231
Balinski, Michel L. "Notes—On a Selection Problem." Management Science 17.3 (1970): 230-231.
"""
balanski = Graph("H??xuRo")
balanski.name(new = "balanski")
add_to_lists(balanski, graph_objects, all_graphs)

"""
Instance of the Erdos-Faber-Lovasz conjecture
"""
efl_instance = Graph("J`?GECrB~z_")
efl_instance.name(new = "efl_instance")
add_to_lists(efl_instance, graph_objects, all_graphs)

"""
From Lipták, László, and László Lovász. "Critical facets of the stable set polytope." Combinatorica 21.1 (2001): 61-88.
with defect 2
"""
basic_facet_1 = Graph("FCS~?")
basic_facet_1.name(new = "basic facet-graph")
add_to_lists(basic_facet_1, graph_objects, all_graphs)

"""
From Lipták, László, and László Lovász. "Critical facets of the stable set polytope." Combinatorica 21.1 (2001): 61-88.
with defect 2
"""
basic_facet_2 = Graph("I_?BSgcEG")
basic_facet_2.name(new = "basic facet-graph two")
add_to_lists(basic_facet_2, graph_objects, all_graphs)

"""
From Lipták, László, and László Lovász. "Critical facets of the stable set polytope." Combinatorica 21.1 (2001): 61-88.
with defect 2
"""
basic_facet_3 = Graph("L@Q????o`QAc?w")
basic_facet_3.name(new = "basic facet-graph three")
add_to_lists(basic_facet_3, graph_objects, all_graphs)

"""
From Lipták, László, and László Lovász. "Critical facets of the stable set polytope." Combinatorica 21.1 (2001): 61-88.
"""
crit_facet_1 = Graph("H@BDQo{")
crit_facet_1.name(new = "critical facet graph 1")
add_to_lists(crit_facet_1, graph_objects, all_graphs)

"""
From Lipták, László, and László Lovász. "Critical facets of the stable set polytope." Combinatorica 21.1 (2001): 61-88.
"""
crit_facet_2 = Graph("J?AAHGIC^o?")
crit_facet_2.name(new = "critical facet graph 2")
add_to_lists(crit_facet_2, graph_objects, all_graphs)

"""
From:
p.222
Tarjan, Robert E. "Decomposition by clique separators." Discrete mathematics 55.2 (1985): 221-232.
"""
tarjan = Graph("JQ?CQOKDXL_")
tarjan.name(new = "tarjan")
add_to_lists(tarjan, graph_objects, all_graphs)

"""
From:
p.225
Tarjan, Robert E. "Decomposition by clique separators." Discrete mathematics 55.2 (1985): 221-232.
"""
tarjan_fillin = Graph("JQAa_OFJWv_")
tarjan_fillin.name(new = "tarjan_fillin")
add_to_lists(tarjan_fillin, graph_objects, all_graphs)

"""
From:
p.252
Sewell, E. C., and L. E. Trotter. "Stability critical graphs and ranks facets of the stable set polytope." Discrete Mathematics 147.1-3 (1995): 247-255.
"""
sewell_1 = Graph("H@GOkXI")
sewell_1.name(new = "sewell_1")
add_to_lists(sewell_1, graph_objects, all_graphs)

"""
Graphs which are two cliques somehow connected to each other
"""
two_clique_1 = Graph("OwCW?CB???_Bw?F?_[W?~")
two_clique_1.name(new = "two-clique 1")
add_to_lists(two_clique_1, graph_objects, all_graphs)

two_clique_2 = Graph("FwC^w")
two_clique_2.name(new = "two-clique 2")
add_to_lists(two_clique_2, graph_objects, all_graphs)

caro_roditty_4 = Caro_Roditty(4)
caro_roditty_4.name(new = "Caro-Roditty 4 Graph")
add_to_lists(caro_roditty_4, graph_objects, all_graphs)

caro_roditty_5 = Caro_Roditty(5)
caro_roditty_5.name(new = "Caro-Roditty 5 Graph")
add_to_lists(caro_roditty_5, graph_objects, all_graphs)

jakovac_2a = Graph("a???????GO???@???_?????C??W????????@_A???B??W??[??????X?E?Q?????????C??Bb???C?o?K??s?@?GZ??F?Ew")
jakovac_2a.name(new = "jakovac fig 2a")
add_to_lists(jakovac_2a, graph_objects, all_graphs)

jakovac_2b = Graph("a???????????????????????@???C??????C?????oO??_I?G?o@_??[????o?O`?????????G???AW???_[??O_N??W?Bw")
jakovac_2b.name(new = "jakovac fig 2b")
add_to_lists(jakovac_2b, graph_objects, all_graphs)

jakovac_5 = Graph("Q`?G?C??G??@?B?K?W?W@o?go@O")
jakovac_5.name(new = "jakovac fig 5")
add_to_lists(jakovac_5, graph_objects, all_graphs)

# From A survey of selected recent results on total domination in graphs By Michael A. Henning
henning_5 = Graph("H?qipno")
henning_5.name(new = "henning fig 5")
add_to_lists(henning_5, graph_objects, all_graphs)

henning_8 = Graph("[SP???_C?O?_?_?O?G?C????????CO?AG??c??E??W??E?????@???A_??QG??BD")
henning_8.name(new = "henning fig 8")
add_to_lists(henning_8, graph_objects, all_graphs)

henning_13 = Graph("khCGGC@?G?_@?@??_?G?@??C??G??K??EG?????KO??_??@???@???G__??????@?C??C????G????G???@C?G_???????G?@???_????@?????@?????G_?A?????????@??CO??C??????G??????G?????@C")
henning_13.name(new = "henning fig 13")
add_to_lists(henning_13, graph_objects, all_graphs)

henning_14 = Graph("M_GSA?_C?G@??b?[?")
henning_14.name(new = "henning fig 14")
add_to_lists(henning_14, graph_objects, all_graphs)

henning_15 = graphs.CycleGraph(4)
for v in henning_15.vertices():
    count = len(henning_15.vertices())
    henning_15.add_cycle(range(count,count+10))
    henning_15.add_edge((v, count))
henning_15.name(new = "henning fig 15")
add_to_lists(henning_15, graph_objects, all_graphs)

henning_16_g1 = Graph("Fq?gw")
henning_16_g1.name(new = "henning fig 16 g1")
add_to_lists(henning_16_g1, graph_objects, all_graphs)

henning_16_g2 = Graph("FWEYo")
henning_16_g2.name(new = "henning fig 16 g2")
add_to_lists(henning_16_g2, graph_objects, all_graphs)

henning_16_g3 = Graph("JQQ@?cCAGF_")
henning_16_g3.name(new = "henning fig 16 g3")
add_to_lists(henning_16_g3, graph_objects, all_graphs)

henning_16_g4 = Graph("NC`@A?_C?@_JA??___W")
henning_16_g4.name(new = "henning fig 16 g4")
add_to_lists(henning_16_g4, graph_objects, all_graphs)

henning_16_g5 = Graph("JSP@?cG@GF_")
henning_16_g5.name(new = "henning fig 16 g5")
add_to_lists(henning_16_g5, graph_objects, all_graphs)

henning_16_g6 = Graph("LSP??CAGOa`C@H")
henning_16_g6.name(new = "henning fig 16 g6")
add_to_lists(henning_16_g6, graph_objects, all_graphs)

henning_16_g7 = Graph("NCGaC@?C?@_J?_A?__W")
henning_16_g7.name(new = "henning fig 16 g7")
add_to_lists(henning_16_g7, graph_objects, all_graphs)

"""
From:
Weighted and Unweighted Maximum Clique Algorithms with Upper Bounds from Fractional Coloring
E. Balas and Jue Xue
"""
balas_1 = Graph("HWFZvq}")
balas_1.name(new = "balas_1")
add_to_lists(balas_1, graph_objects, all_graphs)

"""
From:
On alpha+ - Stable K¨onig-Egervary Graphs
Vadim E. Levit and Eugen Mandrescu
"""
levit_1 = Graph("G?rHx{")
levit_1.name(new = "levit_1")
add_to_lists(levit_1, graph_objects, all_graphs)

"""
From:
On alpha+ - Stable K¨onig-Egervary Graphs
Vadim E. Levit and Eugen Mandrescu
"""
levit_2 = Graph("GCOihs")
levit_2.name(new = "levit_2")
add_to_lists(levit_2, graph_objects, all_graphs)

"""
From:
On alpha+ - Stable K¨onig-Egervary Graphs
Vadim E. Levit and Eugen Mandrescu
"""
levit_3 = Graph("G@G]@{")
levit_3.name(new = "levit_3")
add_to_lists(levit_3, graph_objects, all_graphs)

"""
From:
On alpha-Critical Edges in K¨onig-Egerv´ary Graphs
Vadim E. Levit and Eugen Mandrescu
"""
levit_4 = Graph("KGD?_O_@GE~~")
levit_4.name(new = "levit_4")
add_to_lists(levit_4, graph_objects, all_graphs)

# Two cycles of order cycle1 and cycle2 adjoined at a single vertex.
def glasses_graph(cycle1, cycle2):
    glasses = graphs.CycleGraph(cycle1)
    glasses.add_cycle(range(cycle1, cycle1 + cycle2))
    glasses.merge_vertices([0, cycle1])
    return glasses

# CE to (~weakly_chordial) & is_eularian => is_hamiltonian
glasses_5_5 = glasses_graph(5,5)
add_to_lists(glasses_5_5, graph_objects, all_graphs)

# CE to Hamiltonian => g.is_bipartite() and g.is_strongly_regular()
# CE to Hamiltonian => g.is_circular_planar() and g.is_bipartite()
ham1 = Graph("I~EGYCxyG")
ham1.name(new = "ham1")
add_to_lists(ham1, graph_objects, all_graphs)

# CE to ((is_van_den_heuvel)&(is_circular_planar))->(is_hamiltonian)
umbrella_4 = Graph("Ep{G")
umbrella_4.name(new = "umbrella_4")
add_to_lists(umbrella_4, graph_objects, all_graphs)

def kite_necklace(k):
    #returns k kites joined head to tail
    if k == 1:
        return Graph('DJk')
    g = graphs.CycleGraph(2*k)
    for i in range(k):
        g.subdivide_edge((2*i, 1 + 2*i), 1)
        g.add_edge(2*i, 1 + 2*i)
        g.subdivide_edge((2*i, 1 + 2*i), 1)
        g.add_edge(2*k + 2*i, 2*k + 2*i + 1)
    return g

# CE to (is_hamiltonian)->( (is_regular)->(is_kite_free) )
kite_necklace_3 = kite_necklace(3)
kite_necklace_3.name(new = "kite_necklace_3")
add_to_lists(kite_necklace_3, graph_objects, all_graphs)

# CE to (locally connected)->(is_hamiltonian)
bus = graphs.CycleGraph(4)
bus.add_vertex(4)
bus.add_edges([(0,4),(2,4),(0,2)])
bus.name(new = "bus")
add_to_lists(bus, graph_objects, all_graphs)

# from p.37 of Algorithmic Graph Theory In Sage by authors DaMNeD
DaMNeD1 = Graph('E@~w')
DaMNeD1.name(new = "DaMNeD1")
DaMNeD2 = Graph('F@N]w')
DaMNeD2.name(new = "DaMNeD2")
DaMNeD3 = Graph('GIaHx{')
DaMNeD3.name(new = "DaMNeD3")
DaMNeD4 = Graph('HIaJ`{~')
DaMNeD4.name(new = "DaMNeD4")
add_to_lists(DaMNeD1, graph_objects, all_graphs)
add_to_lists(DaMNeD2, graph_objects, all_graphs)
add_to_lists(DaMNeD3, graph_objects, all_graphs)
add_to_lists(DaMNeD4, graph_objects, all_graphs)

# These graphs are cubic, planar, and vertex transitive
tricone = Graph('It?IQGiDO')
tricone.name(new = "tricone")
truncatedCubical = Graph('Wt?GWGAA?A?C?C?C_?_?O??S?A_??o?@H??@O??gaO?CC_?')
truncatedCubical.name(new = "truncatedCubical")
truncatedDodecahedral = Graph('{t?GW???oH?G?G??_?gO??S??g??E??H???O??CG??A???O??@???A????A???@?????O???A?????g???@O???C????A?????AO????O_????GO????C_??????_?????O??????O?????A??????__????@@???????C??????AG??????c??????CG??????@G??????AC????????_???????O????????c???????@_????????o???????@H????????@O????????g_??G@????C??@?A????')
truncatedDodecahedral.name(new = "truncatedDodecahedral")
truncatedOctahedral = Graph ('Ws?GO?@?O??????D?CO@o?_GC@?M??_W?OI?G@@A?COL???')
truncatedOctahedral.name(new = "truncatedOctahedral")
add_to_lists(tricone, graph_objects, all_graphs)
add_to_lists(truncatedCubical, graph_objects, all_graphs)
add_to_lists(truncatedDodecahedral, graph_objects, all_graphs)
add_to_lists(truncatedOctahedral, graph_objects, all_graphs)

# CE to ((is_heliotropic_plant)&(is_regular))->(is_hamiltonian)
crossingNumberGraph3E = Graph('Ms??WX?CH@CQCQR??')
crossingNumberGraph3E.name(new = "crossingNumberGraph3E")
add_to_lists(crossingNumberGraph3E, graph_objects, all_graphs)

# CE to ((is_quasi_regular)&(is_cartesian_product))->(is_hamiltonian)
ce136 = Graph('K{CY?CBG??_B').cartesian_product(graphs.CompleteGraph(2))
ce136.name(new = "ce136")
add_to_lists(ce136, graph_objects, all_graphs)

# CE to (((has_radius_equal_diameter)&(is_line_graph))&(~(is_perfect)))->(is_hamiltonian)
# CE to (((has_radius_equal_diameter)&(is_line_graph))&(~(is_quasi_regular)))->(is_hamiltonian)
# (equivalent) CE to (((diameter_equals_radius)&(is_line_graph))&(~(is_quasi_regular)))->(is_hamiltonian)
ce137 = Graph('X~aKWOHAYA?H?ROAG@H@?G@C_?WGGOGACC?B?GSO@?__?`O??OS')
ce137.name(new = "ce137")
add_to_lists(ce137, graph_objects, all_graphs)

# CE to ((~(is_perfect))&(girth_greater_than_2log))->(is_hamiltonian)
glasses_17_17 = glasses_graph(17,17)
glasses_17_17.name(new = "glasses_17_17")
add_to_lists(glasses_17_17, graph_objects, all_graphs)

# CE to (((is_factor_critical)&(has_radius_equal_diameter))&((is_perfect)^(has_lovasz_theta_equals_alpha)))->(is_hamiltonian)
ce138 = Graph('N_goPePG?_POB_aWyB_')
ce138.name(new = "ce138")
add_to_lists(ce138, graph_objects, all_graphs)

# CE to (((is_quasi_regular)&(is_H_free))&(has_dart))->(is_hamiltonian)
ce139 = Graph('Iv??G[N]?')
ce139.name(new = "ce139")
add_to_lists(ce139, graph_objects, all_graphs)

# CE to (((has_radius_equal_diameter)&(has_kite))&(is_quasi_regular))->(is_hamiltonian)
ce140 = Graph('Mt?GOGB@?CgHOKM??')
ce140.name(new = "ce140")
add_to_lists(ce140, graph_objects, all_graphs)

# CE to ((~((is_quasi_regular)|(is_perfect)))&(has_radius_equal_diameter))->(is_hamiltonian)
ce141 = Graph('KGh?Q?ALCjQ[')
ce141.name(new = "ce141")
add_to_lists(ce141, graph_objects, all_graphs)

# CE to ((~(is_c4_free))&(is_locally_connected))->(is_hamiltonian)
ce142 = Graph('F?~vw')
ce142.name(new = "ce142")
add_to_lists(ce142, graph_objects, all_graphs)

# CE to (is_perfect & is_three_connected & alpha_leq_order_over_two)->(is_hamiltonian)
# CE to (((is_factor_critical)^(is_independence_irreducible))&((is_H_free)&(has_radius_equal_diameter)))->(is_hamiltonian)
triangleReplacedPetersen = Graph(']t?G?C????_CAG@C?H?CG?G_?P??G_?P???G???W??G???P???K???BG???I???DF????b????')
triangleReplacedPetersen.name(new = "triangleReplacedPetersen")
add_to_lists(triangleReplacedPetersen, graph_objects, all_graphs)

# CE to ((alpha_leq_order_over_two)&(is_locally_two_connected))->(is_hamiltonian)
ce143 = Graph('K~e[Mm@oYaAg')
ce143.name(new = "ce143")
add_to_lists(ce143, graph_objects, all_graphs)

# CE to (is_hamiltonian)->((order_leq_twice_max_degree)|(is_locally_bipartite))
ce144 = Graph('LdEIDOHA{dc_Sa')
ce144.name(new = "ce144")
add_to_lists(ce144, graph_objects, all_graphs)

petersen_line_graph = (graphs.PetersenGraph()).line_graph()
petersen_line_graph.relabel()
petersen_line_graph.name(new = "Line graph of Petersen graph")
add_to_lists(petersen_line_graph, graph_objects, all_graphs)

# CE to is_locally_unicyclic -> is_hamiltonian
ce145 = Graph('K~?GW[PeW@_F')
ce145.name(new = "ce145") # Contributed by Sarah
add_to_lists(ce145, graph_objects, all_graphs)

# CE to independence number >= min( girth, floor(lovasz_theta) )
ce146 = Graph('hUYuvZu}rzVuvuzz]}vvu^^Y}}q}}t^^ZVvuy}}vjzzNVvunVvuVjzzTy}}unVvuy|^^Zty}}vty}}ry|^^Y}nVvuvty}}v^Vjzz]}nVvu}}nVvu^^VjzzVvty}}u}}nVvuZzy|^^W')
ce146.name(new = "ce146") # Contributed by Jianxian Chen, @a234
add_to_lists(ce146, graph_objects, all_graphs)

c4_free_subgraph_of_Q3 = Graph('Gb_k@C')
c4_free_subgraph_of_Q3.name(new = "c4_free_subgraph_of_Q3")
add_to_lists(c4_free_subgraph_of_Q3, graph_objects, all_graphs)

ce147 = Graph('L`?M@_LBf_Q~Y}')
ce147.name(new = "ce147")
add_to_lists(ce147, graph_objects, all_graphs)

# Vincent Cohen-Addad, Michael Hebdige, Daniel Král', Zhentao Li, and Esteban Salgado, Steinberg's Conjecture is false. Journal of Combinatorial Theory, Series B, 2017.
CaHKLS17 = Graph("~?AeCsAGK_WG??@?B?A?@GG@@?C??I??I?AC?@@???G???_??b??KA?@????_?G@??@?G??C????I????I???AC???@@?????G?????_????b????KA??_?????O???G@????@?G????C??????GG?????GG????AC?????@@???????G???????_??????b??????KA????????????????G???????B????????O???????@I????????I????????C????????@_????????K????????O_???????@@?????????@??????????_????????CW????????KA????????G??????????_?H??????????H??????????C??????????@_??????????K??????????O_?????????@@???????????@????????????_??????????CW??????????KA????????C????????????O???H????????????H????????????C????????????@O????????????I????????????O_???????????@@?????????????@??????????????_????????????CW????????????KA?????????????????????????????G??????????????W??????????????O??????????????H?O?????????????GA??????????????_??????????????@O??????????????@O??????????????O_??????????????GG???????????????@????????????????C???????????????CW??????????????@_O??????????????G????????????????C?@?G???????????????G@????????????????_????????????????@O????????????????@O????????????????O_????????????????GG?????????????????@??????????????????C?????????????????CW????????????????@_O??????????????C??????????????????A???@?G?????????????????G@??????????????????_??????????????????@?O?????????????????@?O?????????????????O_??????????????????GG???????????????????@????????????????????C???????????????????CW??????????????????@_O?????????????????????????????????????????@?????????????????????W????????????????????A?????????????????????HG????????????????????@G?????????????????????_?????????????????????I?????????????????????@O????????????????????AC?????????????????????GG??????????????????????G??????????????????????C??????????????????????b?????????????????????@_O????????????????????@???????????????????????C?@C??????????????????????@C???????????????????????_???????????????????????I???????????????????????@O??????????????????????AC???????????????????????GG????????????????????????G????????????????????????C????????????????????????b???????????????????????@_O?????????????????????_????????????????????????A???@C????????????????????????@C?????????????????????????_?????????????????????????H?????????????????????????@G????????????????????????AC?????????????????????????GG??????????????????????????G??????????????????????????C??????????????????????????b?????????????????????????@_O")
CaHKLS17.name(new = "CaHKLS17")
add_to_lists(CaHKLS17, graph_objects, all_graphs)

# Dmytrenko, V. , Lazebnik, F. and Viglione, R. (2005), Isomorphism criterion for monomial graphs. J. Graph Theory, 48: 322-328. doi:10.1002/jgt.20055
DLV05 = Graph( 'Qs???CA??B_M?_B?`_QW?KC@o??')
DLV05.name(new = "DLV05")
add_to_lists(DLV05, graph_objects, all_graphs)

# Garnick, D. K., Kwong, Y. H. and Lazebnik, F. (1993), Extremal graphs without three‐cycles or four‐cycles. J. Graph Theory, 17: 633-645. doi:10.1002/jgt.3190170511
GKL11 = Graph('Jo?OQoqJAK?')
GKL11.name(new = "GKL11")
add_to_lists(GKL11, graph_objects, all_graphs)

triangleReplacedCoxeter = Graph("~?@S{CWOCB?O?_B?A??_?W?A??C??W??O??C??B@?????A_??B???@????_???W???A????C????W????O????C????B?????O?????_????B?????A??????_?????Y????????????S??????W??????G??????C??????B????@?????????A_??????B??@????????????@_???????W???????@????????C????????W????????O????????C????????B?????????O?????????_????????B?????????A??????????_?????????W???@????????????????S??????????W??????????G??????????C??????????BG???????????????????G??_??????????J???G??????????????G?????_?????????_?W?@???????????????@??????C???????????_W?G?????????????????@?????C??????????_?B?G????????????????@????????_????????C???B")
triangleReplacedCoxeter.name(new = "triangleReplacedCoxeter")
add_to_lists(triangleReplacedCoxeter, graph_objects, all_graphs)

# Fig 5.4 of Chartrand, Gary, Linda Lesniak, and Ping Zhang. Graphs & digraphs. Vol. 39. CRC press, 2010.
CGLZ10_f54 = Graph('I?_aCwvUw')
CGLZ10_f54.name(new = "CGLZ10_f54")
add_to_lists(CGLZ10_f54, graph_objects, all_graphs)

# Fig 5.5 of Chartrand, Gary, Linda Lesniak, and Ping Zhang. Graphs & digraphs. Vol. 39. CRC press, 2010.
CGLZ10_f55 = Graph('K??H?C@?W`z_')
CGLZ10_f55.name(new = "CGLZ10_f55")
add_to_lists(CGLZ10_f55, graph_objects, all_graphs)

# Jan Goedgebeur, On minimal triangle-free 6-chromatic graphs. 2017. https://arxiv.org/pdf/1707.07581.pdf
Goedgebeur17 = Graph('U???CA?O?O_aGC?`A@?HDGQOPAA@AGE@?Gc@~_??')
Goedgebeur17.name(new = "Goedgebuer17")
add_to_lists(Goedgebeur17, graph_objects, all_graphs)

# David Garnick, Y.H. Harris Kwong, and Felxi Lazebnik, Algorithmic search for extremal graphs of girth at least five. 1992.
GKL92_1 = Graph('Q??G_GBD?SOAOAGKcHaPGcObe??')
GKL92_1.name(new = "GKL92_1")
add_to_lists(GKL92_1, graph_objects, all_graphs)
GKL92_2 = Graph('WhCGKC@QGC_@CPP?_?HC@a@C?`H?OGQ@D?C@@G?K_P?aO?c')
GKL92_2.name(new = "GKL92_2")
add_to_lists(GKL92_2, graph_objects, all_graphs)

# http://mathworld.wolfram.com/ThomassenGraphs.html
thomassen20 = Graph("ShCKK?DOGC_H?@O?__H?HG??C?G_CGOCO")
thomassen20.name(new = "thomassen20")
add_to_lists(thomassen20, graph_objects, all_graphs)

thomassen32 = Graph("_hCKGCH?G?_@?`??_@G?@??C??K?CG??C??H?C?H???o??@O??CC??@aG???G_?@?CO???CO?G??a????G_C")
thomassen32.name(new = "thomassen32")
add_to_lists(thomassen32, graph_objects, all_graphs)

thomassen34 = Graph("aUW??GE?o????A?B@?o???????O??o?_Y?_?O??H???a??@@????_??_G?CG?O?G?@??C?A??G?A_?G??O?C??C?@???__G")
thomassen34.name(new = "thomassen34")
add_to_lists(thomassen34, graph_objects, all_graphs)

thomassen41 = Graph("hhDGHEHC??_@?@??_OG_???C??G??G??E??@C????O?_??@?C?@?@?C_???_?@?@??_?CA???G?A?@G???????G?@C????G??G??_?A??H?????O???G??_??O??K?????@???O??c")
thomassen41.name(new = "thomassen41")
add_to_lists(thomassen41, graph_objects, all_graphs)

thomassen60 = Graph("{hCGGCDAG?o@O???_?G?@??C??GE?GC?G??H???G?C?o?????O@????_???G???@???_C@???G????g????C???C@???@??????A_????C?????d?????B????C?G???C?@????C?C???@?@G?A???????_???C??G???A??G????G??????A_??@???@???G???@???C???A??O?????WO???????G???????C????????G_???????I????????c?C??????C?C???????G?O??????GO????????B")
thomassen60.name(new = "thomassen60")
add_to_lists(thomassen60, graph_objects, all_graphs)

thomassen94 = Graph("~?@]l_GGD@?G?_@G@??_?G?@C?C??G??GO?C??A???G???_??@???@????_???G??@@?A???????G????G????C???A@?????G?????_???@@?_??????????_?????G?????@??????C??????G??????G?????CC??_???????????G???????_??????@???????@????????_???????G??????@@??O?????C?C??????G???????@G????????C?????C??@????@??????????????_??????O?@?C???????@?O?????O??__????G?????????@??????????????C???O??????G????_????????????????C???????G??@??@????????G???????G??A???????????@????????_??@????????????_???????GG??G????????@??A?????A??????C????????????G???@????????G??????????CGC???@?O??????C???@?O?????????????????????_??@?????????@??????????@??@??????????????_?????@???????G?????????????@?????????C????C????A????????GG??????G??O????_??????_???O??A???@???????o??????C????C???C????")
thomassen94.name(new = "thomassen94")
add_to_lists(thomassen94, graph_objects, all_graphs)

thomassen105 = Graph("~?@hhe?IC@GG?a@?@A?__GG???CA?GC????C@?@?O?????_C?@?G??????_A??G?_??????C?G??G?O???????C?C??@?@?????????_?O??@??_?????????_?G???G?A??????????C??_???G?@???????????CC?????@???????G??_????_??_???????_???@???G???????A????G???G????????_???C????_????????_???G????G????????A???@?????G?????????_???_?????_?????????_??@??????G?????????A???G??????G??????????_??C???????G?????O???????G???????G??C???????A??????O???????G???????A???_???????C??????A???????@????????C???_???????@???????A???????@????????@???C????????A????????O???????G????????A???C?????????_????????O???????G?????????_???_????????@?????????A???????@?????????@????_?????????O?????????A???????@??????????O???C??????????_??????????O???????G??????????_???C??????????G???????????O???????G???????_???????_??????????_???@???????????W???@???????????B????_???????????K???G????????????W??@?????????????W??C?????????????K??G?????????????B??G??????????????W?C??????????????@c@")
thomassen105.name(new = "thomassen105")
add_to_lists(thomassen105, graph_objects, all_graphs)

# R.L. Graham, On edgewise 2-colord graphs with monchromatic triangles and containing no complete hexagon. Journal of Combinatorial Theory, 4(3): 300, 1968.
Graham68 = Graph('GUZ~~{')
Graham68.name(new = "Graham68")
add_to_lists(Graham68, graph_objects, all_graphs)

# Distance Regular Graphs:
split_cayley_hex_2 = Graph("~??~{aSO???GA??????_?_???????G??_?????@???????_?_G??_A?@?C??CC??A?_??OO??A?_??@?O?@?GG?@?G?A?GC?O??O_?_?A?O?_?A@?A??O?_G??A@?O?ABo????O@w???D??]???A??Bo??H???GaO?_??@GQ?G???@h?H???D?BA@?_O_?_?C?c?_C??A?Q?CG??A?C_C?O??C@_?CO???_`?@O???CCG@??_??GAC?OA???a?AG@??C?G_?__O?@?CC?CC@??G?OO?S?C?G??W?AG?G?@??c?OA?G?C?@G?A?o???_?`?C?`???_?")
split_cayley_hex_2.name(new = "split_cayley_hex_2")
add_to_lists(split_cayley_hex_2, graph_objects, all_graphs)
# Bipartite, not strongly regular
distreg_not_stronglyreg1 = Graph("QKUalPTiaitSTTiiIilTSTTUii_")
distreg_not_stronglyreg1.name(new = "distreg_not_stronglyreg1")
distreg_not_stronglyreg2 = Graph("IKUalPTi_")
distreg_not_stronglyreg2.name(new = "distreg_not_stronglyreg2")
distreg_not_stronglyreg3 = Graph("KKUalPTiaitS")
distreg_not_stronglyreg3.name(new = "distreg_not_stronglyreg3")
distreg_not_stronglyreg4 = Graph("SKUalPTiaitSTTiiIilTSTTUiiaiilTTO")
distreg_not_stronglyreg4.name(new = "distreg_not_stronglyreg4")
distreg_not_stronglyreg5 = Graph("MKUalPTiaitSTTii?")
distreg_not_stronglyreg5.name(new = "distreg_not_stronglyreg5")
distreg_not_stronglyreg6 = Graph("OKUalPTiaitSTTiiIilTS")
distreg_not_stronglyreg6.name(new = "distreg_not_stronglyreg6")
graph_objects.extend([distreg_not_stronglyreg1, distreg_not_stronglyreg2, distreg_not_stronglyreg3, distreg_not_stronglyreg4, distreg_not_stronglyreg5,
                   distreg_not_stronglyreg6])
all_graphs.extend([distreg_not_stronglyreg1, distreg_not_stronglyreg2, distreg_not_stronglyreg3, distreg_not_stronglyreg4, distreg_not_stronglyreg5,
                   distreg_not_stronglyreg6])
# Not bipartite, not strongly regular
distreg_not_stronglyreg7 = Graph("L~~~~~~~~~~~~~")
distreg_not_stronglyreg7.name(new = "distreg_not_stronglyreg7")
distreg_not_stronglyreg8 = Graph("N~~~~~~~~~~~~~~~~~w")
distreg_not_stronglyreg8.name(new = "distreg_not_stronglyreg8")
distreg_not_stronglyreg9 = Graph("P~~~~~~~~~~~~~~~~~~~~~~{")
distreg_not_stronglyreg9.name(new = "distreg_not_stronglyreg9")
distreg_not_stronglyreg10 = Graph("J~~~~~~~~~_")
distreg_not_stronglyreg10.name(new = "distreg_not_stronglyreg10")
distreg_not_stronglyreg11 = Graph("Q~~~~~~~~~~~~~~~~~~~~~~~~~w")
distreg_not_stronglyreg11.name(new = "distreg_not_stronglyreg11")
distreg_not_stronglyreg12 = Graph("M~~~~~~~~~~~~~~~_")
distreg_not_stronglyreg12.name(new = "distreg_not_stronglyreg12")
distreg_not_stronglyreg13 = Graph("R~~~~~~~~~~~~~~~~~~~~~~~~~~~~w")
distreg_not_stronglyreg13.name(new = "distreg_not_stronglyreg13")
distreg_not_stronglyreg14 = Graph("O~~~~~~~~~~~~~~~~~~~~")
distreg_not_stronglyreg14.name(new = "distreg_not_stronglyreg14")
distreg_not_stronglyreg15 = Graph("K~~~~~~~~~~~")
distreg_not_stronglyreg15.name(new = "distreg_not_stronglyreg15")
distreg_not_stronglyreg16 = Graph("S~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{")
distreg_not_stronglyreg16.name(new = "distreg_not_stronglyreg16")
graph_objects.extend([distreg_not_stronglyreg7, distreg_not_stronglyreg8, distreg_not_stronglyreg9, distreg_not_stronglyreg10, distreg_not_stronglyreg11,
                   distreg_not_stronglyreg12, distreg_not_stronglyreg13, distreg_not_stronglyreg14, distreg_not_stronglyreg15, distreg_not_stronglyreg16])
all_graphs.extend([distreg_not_stronglyreg7, distreg_not_stronglyreg8, distreg_not_stronglyreg9, distreg_not_stronglyreg10, distreg_not_stronglyreg11,
                   distreg_not_stronglyreg12, distreg_not_stronglyreg13, distreg_not_stronglyreg14, distreg_not_stronglyreg15, distreg_not_stronglyreg16])

######  DISCONNECTED GRAPHS  ######

# Felix Lazebnik and Spencer Tofts, An Extremal Property of Turan Graphs. The electronic journal of combinatorics, 2010.
LozTof10 = Graph('P????????????@?@?Y?@UBEO')
LozTof10.name(new = "LozTof10")
add_to_lists(LozTof10, non_connected_graphs)

# Product Graphs, fig. 5.4
p5txp3 = graphs.PathGraph(5).tensor_product(graphs.PathGraph(3))
p5txp3.name(new = "p5txp3")
add_to_lists(p5txp3, non_connected_graphs)

add_to_lists(graphs.WorldMap(), non_connected_graphs)


#graph_objects: all graphs with no duplicates
#obvious way to remove duplicates in list of ALL objects

def remove_duplicates(seq, idfun=None):
    """
    Utility method to remove duplicates from a list. Equality is determined
    based on the return value of the idfun parameter. If idfun is not given,
    the identity is used.

    This method is taken from http://www.peterbe.com/plog/uniqifiers-benchmark

    sage: graphs = [graphs.CompleteGraph(4), graphs.CompleteGraph(3), graphs.CycleGraph(4), graphs.CycleGraph(3)]
    sage: remove_duplicates(graphs, idfun=lambda g: g.canonical_label(algorithm='sage').graph6_string())
    Cycle graph was already in the list
    [Complete graph: Graph on 4 vertices,
     Complete graph: Graph on 3 vertices,
     Cycle graph: Graph on 4 vertices]
    """
    if idfun is None:
        def idfun(x): return x
    seen = {}
    result = []
    for item in seq:
        marker = idfun(item)
        if marker in seen:
            print "{} was already in the list".format(item)
            continue
        seen[marker] = 1
        result.append(item)
    return result

def remove_duplicates_colours(seq, idfuns, verbose=False):
    """
    Utility method to remove duplicates from a list. Equality is determined
    based on the return values of the idfuns parameter. This parameter expects
    to receive a list of functions (colours) which can be used to distinguish
    graphs. The only requirements are that calling any of the colours on isomorphic
    graphs should always return the same value, and that the last colour in
    the list should be different for non-isomorphic graphs.

    This method is based on a method from http://www.peterbe.com/plog/uniqifiers-benchmark

        sage: graphs = [graphs.CompleteGraph(4), graphs.CompleteGraph(3), graphs.CycleGraph(4), graphs.CycleGraph(3)]
        sage: remove_duplicates_colours(graphs, [Graph.order, (lambda g: max(g.degree())), lambda g: g.canonical_label(algorithm='sage').graph6_string()])
        [Complete graph: Graph on 4 vertices,
         Complete graph: Graph on 3 vertices,
         Cycle graph: Graph on 4 vertices]
    """
    seen = {}
    result = []
    for item in seq:
        current = seen
        for pos, idfun in enumerate(idfuns):
            colour = idfun(item)
            if colour in current:
                if type(current[colour]) == dict:
                    current = current[colour]
                elif pos == len(idfuns) - 1:
                    if verbose: print "{} was already in the list. Previous version was {}.".format(item, current[colour])
                else:
                    prev_item = current[colour]
                    remaining_idfuns = idfuns[pos+1:]
                    for pos2, idfun in enumerate(remaining_idfuns):
                        colour1, colour2 = idfun(prev_item), idfun(item)
                        if colour1 == colour2:
                            if pos2 == len(remaining_idfuns) - 1:
                                current[colour] = {colour1: prev_item}
                                if verbose: print "{} was already in the list. Previous version was {}.".format(item, prev_item)
                            else:
                                current[colour] = {}
                                current, colour = current[colour], colour1
                        else:
                            current[colour] = {colour1: prev_item, colour2: item}
                            result.append(item)
                            break
                    break
            else:
                current[colour] = item
                result.append(item)
                break
    return result


#could run this occasionally to check there are no duplicates
#graph_objects = remove_duplicates(union_objects, idfun=g.canonical_label(algorithm='sage').graph6_string())
# Class 0 pebbling graphs

class0graphs_dict = {
 'C05': 'IheA@GUAo',
 'C05C05': 'XheAHCPBGG?P?P?G_BG?O?@C?AG?AG?@e??OO?AH??Ga??PA??X',
 'C05C05C05': '~?@|heAHCPBGG?P?P?G_BG?O?@C?AG?AG?@e??OO?AH??Ga??PA??X_???G???H???@C???CG??@GG??A?C??@C@???P?G??AG?_??K_@???O?@???P??_??G_?G??AG?@???X??C??@???G??AG??G??AG??C??@C??@???X???GO?A????`??G_??@A??P???@A??P????`??K_???G???????@???@????C???C????G???G????G??@G????C??@?????@???P?????G??AG?????_??G_????@???X?????@???O??????_??G_?????G??AG?????@???P??????C??@c??????G??A???????G??AG??????C??@C??????@???P???????G??BG???????`??G???????@A??P???????@A??P????????`??G_???????GO?BG???????@????????????C???C????????G???G????????G???G????????C???c????????@???O?????????G??AG?????????_??G_????????@???P?????????@???X??????????_??G??????????G??AG?????????@???P??????????C??@C??????????G??BG??????????G??A???????????C??@C??????????@???P???????????G??AG???????????_??K_??????????@A??O???????????@A??P????????????`??G_???????????GO?AG???????????@A??X_???????????C???@????????????G???H????????????G???G_???????????C???CG???????????@???H@????????????G??A?C????????????_??G_G???????????@???P?G???????????@???P?C????????????_??K_@????????????G??A??G???????????@???P??_???????????C??@C?@????????????G??AG?@????????????G??BG??_???????????C??@???G???????????@???P??@????????????G??AG??C????????????_??G_??G???????????@???X???G???????????@A??O???C????????????`??G_??@????????????GO?AG???G???????????@A??P????_???????????CG?@c',
 'C05C05K2': 'qrh\\QmiT[?G@GAC@`@OGJ?ag@DW@TO?im?G?O@?H?C@A?GBA?GI@?CD_O@DOA?Gj?G?ig?O@T[?O@?A?G?_C_A?GAC?O@?WO@?CD?_A?GJ?_A?Gi?O@?CT_C?O@TO?_A?Ij_A?G?_@?C?O@?H?C?O@?O_A?G?_KG?_A?GI@?C?O@@WC?O@?CT?G?_A?Gj?G?_A?Ii?C?O@?DT_',
 'C05C05K3': '~?@J{S{aSfcaQcfccQQcc{??O?C_?W_?_O?SC?F?_C_A?Q_C?f?CCc?AAQ_?_cw?Ccc??QQS??cc{??_?A??O?C_?C?BC??_?_O?A?A__?C?F?_?C?c?O?A?Q_C??_Cw?_?CCc?A??OQS?C??_cw?C??cc_?A??QQS??_?Ccf_?C??_?A??O?A??c??_?C?BC??_?C?CA??O?A?A__?C??_?wC??_?C?c?O?A??OAS?_?C??_Cw?_?C??_c_?O?A??OQS?C??_?CCf??_?C??cc_?A??O?AQQ_?C??_?Ccf_?C??_?C??O?A??O?A??c??_?C??_?W_?C??_?C?CA??O?A??O?SC??_?C??_?wC??_?C??_C_A??O?A??OAS?_?C??_?C?f?C??_?C??_c_?O?A??O?AAQ_?_?C??_?CCf??_?C??_?Ccc??O?A??O?AQQ_?C??_?C??ccw',
 'C05C05K4': '~?@c~`HW}GPHDaNaGPCcPWaNaG`CPHCPWaG}???O??H??@a??FA??G@??C_O?@WA??N?G?G_?O?PG?O?PW?G?G{?A?aG??OCPG?@?PD_?A?aN??AGaG??@CPC_??PCPW??AGaN_??G??@???O??H???O??W_??G??[G??A??G@???O?@GC??@??D_G??A??N?G??A?AG?C??@?@C_@???O?PW?G??A?AN??_??GAG_?@???OCPG?@???OCPW??_??GAG{??G??AGaG??@???PCPG??C??@CPD_??G??AGaN_??G??A???O??C??@???c??@???O??W_??G??A??FA???_??G??_C??@???O?@GC??@???O?@WA???_??G??{?_??G??A?AG?C??@???O?PG?O??C??@?@D_?_??G??A?AN??_??G??A?aG??O??C??@?PC_?C??@???OCPW??_??G??A?aN??A???_??GaG_??C??@???PCPG??C??@???PCPW??A???_??GaG}???_??G??A???O??C??@???O??H???O??C??@??@a???_??G??A??FA???_??G??A??G@???O??C??@??C_O??C??@???O?@WA???_??G??A??N?G??A???_??G?G_?O??C??@???O?PG?O??C??@???O?PW?G??A???_??G?G{?A???_??G??A?aG??O??C??@???OCPG?@???O??C??@?PD_?A???_??G??A?aN??A???_??G??AGaG??@???O??C??@CPC_??O??C??@???PCPW??A???_??G??AGaN',
 'C05C05Q2': '~?@cr`HOmGPHDAJaGPCcPOaJaG`CPHCPOaGm???O??H??@A??BA??G@??C_O?@OA??J?G?G_?O?PG?O?PO?G?Gk?A?aG??OCPG?@?PD??A?aJ??AGaG??@CPC_??PCPO??AGaJ_??G??@???O??H???O??O_??G??KG??A??G@???O?@GC??@??D?G??A??J?G??A?AG?C??@?@C_@???O?PO?G??A?AJ??_??GAG_?@???OCPG?@???OCPO??_??GAGk??G??AGaG??@???PCPG??C??@CPD???G??AGaJ_??G??A???O??C??@???c??@???O??O_??G??A??BA???_??G??_C??@???O?@GC??@???O?@OA???_??G??k?_??G??A?AG?C??@???O?PG?O??C??@?@D??_??G??A?AJ??_??G??A?aG??O??C??@?PC_?C??@???OCPO??_??G??A?aJ??A???_??GaG_??C??@???PCPG??C??@???PCPO??A???_??GaGm???_??G??A???O??C??@???O??H???O??C??@??@A???_??G??A??BA???_??G??A??G@???O??C??@??C_O??C??@???O?@OA???_??G??A??J?G??A???_??G?G_?O??C??@???O?PG?O??C??@???O?PO?G??A???_??G?Gk?A???_??G??A?aG??O??C??@???OCPG?@???O??C??@?PD??A???_??G??A?aJ??A???_??G??AGaG??@???O??C??@CPC_??O??C??@???PCPO??A???_??G??AGaJ',
 'C05K02': 'IrGWOMAOW',
 'C05K03': 'N{Sw_SF?_A_F_COAc?w',
 'C05K04': 'S~`HW{G@GD_N?G?C_@W?N_?`?@H?@W_?{',
 'C05K05': 'X~}AHKVBwG?P?R?J_Bw?O?@C?AW?Aw?@}??OO?AH??Ha??VA??^',
 'C05K06': ']~~{ACbCwV_~?_?O_CW?f?A{?Fw?C??AC??b??Cw??V_??~_??_O??Oc??CW_??fA??A{C??Fw',
 'C05K07': 'b~~~{@@GWb`N@^?~_G?@@?CK?Gw?Hw?D{?@~??G???__?@B??@F???f_??Jw??@~_??C@???GH???GW_??C[G??@N@???JwC???~_',
 'C05K08': 'g~~~~}?OH@aFAN@N_VwB~?G??OG?OW?G[?AN??Rw?@^_?B~??A???@?_??OW??AF???G{???Rw???Vw???N}???A?O???OH???@@a???AFA???AN@???@N_O???VwA???B~',
 'C05K09': 'l~~~~~~_A?cBCFAF_bwC~?V{?~w?_??OC?CB??_w?AF_?C^??C~??A~_??~w??C????OC???_W???_w???O{???C^????fw???A~_???F~_???C?O???A?c????_W_???CFA????O{C????bwC????fwA????V{?_???F~',
 'C05K10': 'q~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~{?G??@?G?C@_?GF??GN??CN_?@Fw??H~???n{??@~w??@?????_C???GB???@?w???CF_???G^????G~????C~_???@^w????N~_????_@????@?H????@?W_????_[G????GN@????@BwC????C^_G????H~?G????J~?C????F~_',
 'C05K11': 'v~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~w?G???O@??OB??GB_?A@w??O^??@B{??ANw??A^w??@^{???^~???A?????G?_???OB????OF????GF_???ABw????O~????@F{????A^w????A~w????@~}?????O?O????A?H?????G@a?????OFA?????ON@?????GN_O????AFwA?????P~?G????@N{?O????A~w?O????B~w',
 'C05K12': '{~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~??_???O?_?C?W??_F??A?{??CBw??CFw??AF{???b~???C~w???V~_???~~????_?????O?_???C?W????_F????A?{????CBw????CFw????AF{?????b~?????C~w?????V~_?????~~_?????_?O?????O?c?????C?W_?????_FA?????A?{C?????CBwC?????CFwA?????AF{?_?????b~?C?????C~w?O?????V~_?_?????~~',
 'C05K13': '~?@@~~~~~~~~~~~~~_?G?H?BC?[G@wGBwCB{@@~?G^w?b~_@N~?@^~??~~_?G???@?@??C?K??G?w??G@w??C@{??@?~???GNw???`~_??@F~???@N~????n~_???N~w???@??????C?C????G?W????G?w????C?{????@?^?????GFw?????_~_????@B~?????@F~??????f~_?????J~w?????@~~_?????C?@??????G?H??????G?W_?????C?[G?????@?N@??????GBwC??????_^_G?????@@~?G?????@B~?C??????b~_@??????H~w?G?????@^~??_?????F~{',
 'C05K14': '~?@E~~~~~~~~~~~~~~~o?A?@G?KO?wO@wG@{A?~?ONw@@~_AF~?AN~?@N~_?V~w?B~~??G????O?G??O?W??G?[??A?N???OBw??@?^_??A@~???AB~???@B~_???P~w???A^~????J~{????^~w????O??????G?C????A?B?????O?w????@?F_????A?^?????A?~?????@?~_?????O^w?????AF~??????G~{??????R~w??????V~w??????N~}??????A??O??????O?H??????@?@a??????A?FA??????A?N@??????@?N_O??????OFwA??????A@~?G??????GN{?O??????O~w?O??????P~w?G??????H~{?A??????A~~??O??????^~w',
 'C05K15': '~?@J~~~~~~~~~~~~~~~~~{??O?C_?W_?wO?{C?^?_FwA?~_CB~?CF~?AF~_?b~w?C~~??V~{??~~w??_????O?C??C?B???_?w??A?F_??C?^???C?~???A?~_???_^w???CF~????O~{????b~w????f~w????V~{????F~~?????_??????A??_????C?B?????C?F?????A?F_?????_Bw?????C?~??????OF{??????_^w??????_~w??????O~{??????C^~???????f~w??????A~~_??????F~~_??????C??O??????A??c???????_?W_??????C?FA???????O?{C???????_BwC???????_FwA???????OF{?_??????CB~?C???????_~w?O??????AF~_?_??????C^~??_??????C~~??O??????A~~_?C???????~~w',
 'C05K16': '~?@O~~~~~~~~~~~~~~~~~~~~_?@??H??W_?[G?N@?BwC?^_G@~?GB~?CB~_@@~w?G^~??b~{?@N~w?@^~w??~~{??G????@??G??C?@_??G?F???G?N???C?N_??@?Fw???G@~????_N{???@?~w???@@~w????`~{????G~~????@N~w????D~~_????N~~?????G???????C??_????@??W?????G?F??????_?{?????@?Bw?????@?Fw??????_F{??????GB~??????@?~w??????CF~_??????G^~???????G~~???????C~~_??????@^~w???????N~~_???????_?@???????@??H???????@??W_???????_?[G???????G?N@???????@?BwC???????C?^_G???????G@~?G???????GB~?C???????CB~_@???????@@~w?G???????G^~??_???????b~{?@???????@N~w?@???????@^~w??_???????~~{',
 'C05K17': '~?@T~~~~~~~~~~~~~~~~~~~~~~}??A??H??KO?FA?@wG?N_O?~?O@~?G@~_A?~w?ON~?@@~{?AF~w?AN~w?@N~{??V~~??B~~w??G?????O?@???O?B???G?B_??A?@w???O?^???@?B{???A?Nw???A?^w???@?^{????ON~????AB~w????G^~_????P~~?????R~~?????J~~_????B~~w?????O???????@??C?????A??W?????A??w?????@??{??????O?^??????A?Fw??????G?~_??????OB~???????OF~???????GF~_??????AB~w???????O~~???????@F~{???????A^~w???????A~~w???????@~~}????????O??O???????A??H????????G?@a????????O?FA????????O?N@????????G?N_O???????A?FwA????????O@~?G???????@?N{?O???????A?~w?O???????A@~w?G???????@@~{?A????????O~~??O???????AN~w?@????????H~~_?A????????V~~??A????????^~~',
 'C05K18': '~?@Y~~~~~~~~~~~~~~~~~~~~~~~~~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_F~?A?~{?CB~w?CF~w?AF~{??b~~??C~~w??V~~_??~~~???_?????O??_??C??W???_?F???A??{???C?Bw???C?Fw???A?F{????_B~????C?~w????OF~_????_^~?????_~~?????O~~_????C^~w?????f~~?????A~~{?????F~~w?????C????????A??C??????_?B??????C??w??????O?F_??????_?^???????_?~???????O?~_??????C?^w???????_F~???????A?~{???????CB~w???????CF~w???????AF~{????????b~~????????C~~w????????V~~_????????~~~_????????_??O????????O??c????????C??W_????????_?FA????????A??{C????????C?BwC????????C?FwA????????A?F{?_????????_B~?C????????C?~w?O????????OF~_?_????????_^~??_????????_~~??O????????O~~_?C????????C^~w??_????????f~~??A????????A~~{??C????????F~~w',
 'C05K19': '~?@^~~~~~~~~~~~~~~~~~~~~~~~~~~~~{??@??@G??W_?B`??N@??^?_?^_G?Nw@?B~?C?^{?G@~w?GB~w?CB~{?@@~~??G^~w??b~~_?@N~~??@^~~???~~~_??G?????@??@???C??K???G??w???G?@w???C?@{???@??~????G?Nw????_@~_???@?F~????@?N~?????_N~_????GF~w????@@~~?????CN~{?????G~~w?????H~~w?????D~~{?????@~~~??????G?????????_??_?????@??B??????@??F???????_?F_??????G?Bw??????@??~???????C?F{???????G?^w???????G?~w???????C?~{???????@?^~????????GF~w????????_~~_???????@B~~????????@F~~?????????f~~_????????J~~w????????@~~~_????????C??@?????????G??H?????????G??W_????????C??[G????????@??N@?????????G?BwC?????????_?^_G????????@?@~?G????????@?B~?C?????????_B~_@?????????G@~w?G????????@?^~??_????????CB~{?@?????????GN~w?@?????????G^~w??_????????C^~{??G????????@N~~??@?????????J~~w??C?????????~~~_',
 'C05K20': '~?@c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O@~w?G@~{?A?~~??ON~w?@@~~_?AF~~??AN~~??@N~~_??V~~w??B~~~???G??????O??G???O??W???G??[???A??N????O?Bw???@??^_???A?@~????A?B~????@?B~_????O@~w????A?^~?????GB~{?????ON~w?????O^~w?????G^~{?????AN~~??????R~~w?????@^~~_?????B~~~??????A?????????@???_??????O??W??????A??F???????G??{???????O?Bw???????O?Fw???????G?F{???????A?B~????????O?~w???????@?F~_???????A?^~????????A?~~????????@?~~_????????O^~w????????AF~~?????????G~~{?????????R~~w?????????V~~w?????????N~~}?????????A???O?????????O??H?????????@??@a?????????A??FA?????????A??N@?????????@??N_O?????????O?FwA?????????A?@~?G?????????G?N{?O?????????O?~w?O?????????O@~w?G?????????G@~{?A?????????A?~~??O?????????ON~w?@?????????@@~~_?A?????????AF~~??A?????????AN~~??@?????????@N~~_??O?????????V~~w??A?????????B~~~',
 'C05Q2': 'Sr`HOkG@GD?J?G?C_@O?J_?`?@H?@O_?k',
 'C05Q3': 'gr`HOm?OH@ABAG@C_POAJ?G??OG?OO?GK?AG??PG?@D??AJ??A???@?_??OO??AB???G_???PG???PO???Gm???A?O???OH???@@A???ABA???AG@???@C_O???POA???AJ',
 'C05Q4': '~?@Or`HOm?OH@ABAG@C_POAJ_?@??H??O_?KG?G@?@GC?D?G?J?GA??C@?_@?OO?GAB??_G_?@?PG?@?PO??_Gk??G????@??G??C?@???G?B???G?G???C?C_??@?@O???G?J????_G????@?OG???@?OO????_GK????GAG????@?PG????C@D?????GAJ?????G???????C??_????@??O?????G?B??????_?_?????@?@G?????@?@O??????_?k??????GA???????@?OG??????C@@???????GAB???????GAG???????C@C_??????@?PO???????GAJ_???????_?@???????@??H???????@??O_???????_?KG???????G?G@???????@?@GC???????C?D?G???????G?J?G???????GA??C???????C@?_@???????@?OO?G???????GAB??_???????_G_?@???????@?PG?@???????@?PO??_???????_Gk',
 'C06Pow02': 'EznW',
 'C07Pow02': 'FzM]W',
 'C08Pow02': 'GzK[]K',
 'C09Pow02': 'HzKW[NB',
 'C10Pow04': 'I~||}~n|w',
 'C11Pow04': 'J~|x{~Nx~f_',
 'C12Pow04': 'K~|xw}Np~F}N',
 'C12Pow05': 'K~~z|~^z~n~^',
 'C13Pow04': 'L~|xw{N`}F{N{N',
 'C14Pow04': 'M~|xw{N@{FwNwN{F_',
 'C15Pow04': 'N~|xw{N@wFoNoNwF}@w',
 'C16Pow04': 'O~|xw{N@wF_N_NoF{@~_N',
 'C17Pow04': 'P~|xw{N@wF_N?N_Fw@~?N{?{',
 'C18Pow04': 'Q~|xw{N@wF_N?N?Fo@}?Nw?~o@w',
 'C19Pow04': 'R~|xw{N@wF_N?N?F_@{?No?~_@~_@w',
 'C20Pow04': 'S~|xw{N@wF_N?N?F_@w?N_?~?@~?@~_?{',
 'C21Pow04': 'T~|xw{N@wF_N?N?F_@w?N??}?@}?@~??~o?N',
 'C22Pow04': 'U~|xw{N@wF_N?N?F_@w?N??{?@{?@}??~_?N{?@w',
 'C23Pow04': 'V~|xw{N@wF_N?N?F_@w?N??{?@w?@{??~??Nw?@~_?F_',
 'C24Pow08': 'W~~~~~~^x~b~B~@~_^wB~_N~?^~?^~_N~wB~~?^~{@~~wB~',
 'C25Pow08': 'X~~~~~~^x~b~B~@~_^wB~?N}?^}?^~?N~oB~}?^~w@~~oB~~oB~',
 'C26Pow08': 'Y~~~~~~^x~b~B~@~_^wB~?N{?^{?^}?N~_B~{?^~o@~~_B~~_B~~o@~_',
 'C27Pow08': 'Z~~~~~~^x~b~B~@~_^wB~?N{?^w?^{?N~?B~w?^~_@~~?B~~?B~~_@~~w?^w',
 'C28Pow08': '[~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N}?B~o?^~?@~}?B~}?B~~?@~~o?^~}?B~',
 'C29Pow08': '\\~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~_?^}?@~{?B~{?B~}?@~~_?^~{?B~~o?N{',
 'C30Pow08': ']~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^{?@~w?B~w?B~{?@~~??^~w?B~~_?N~~??^w',
 'C31Pow08': '^~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~o?B~o?B~w?@~}??^~o?B~~??N~}??^~}??^w',
 'C32Pow08': '_~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~_?B~o?@~{??^~_?B~}??N~{??^~{??^~}??N{',
 'C33Pow08': '`~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~_?@~w??^~??B~{??N~w??^~w??^~{??N~~??B~',
 'C34Pow08': 'a~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~o??^}??B~w??N~o??^~o??^~w??N~}??B~~o??^w',
 'C35Pow08': 'b~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^{??B~o??N~_??^~_??^~o??N~{??B~~_??^~}??@~_',
 'C36Pow08': 'c~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~_??N~???^~???^~_??N~w??B~~???^~{??@~~w??B~',
 'C37Pow08': 'd~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N}???^}???^~???N~o??B~}???^~w??@~~o??B~~o??B~',
 'C38Pow08': 'e~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^{???^}???N~_??B~{???^~o??@~~_??B~~_??B~~o??@~_',
 'C39Pow08': 'f~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^{???N~???B~w???^~_??@~~???B~~???B~~_??@~~w???^w',
 'C40Pow08': 'g~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N}???B~o???^~???@~}???B~}???B~~???@~~o???^~}???B~',
 'C41Pow08': 'h~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~_???^}???@~{???B~{???B~}???@~~_???^~{???B~~o???N{',
 'C42Pow08': 'i~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^{???@~w???B~w???B~{???@~~????^~w???B~~_???N~~????^w',
 'C43Pow08': 'j~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~o???B~o???B~w???@~}????^~o???B~~????N~}????^~}????^w',
 'C44Pow08': 'k~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~_???B~o???@~{????^~_???B~}????N~{????^~{????^~}????N{',
 'C45Pow08': 'l~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~_???@~w????^~????B~{????N~w????^~w????^~{????N~~????B~',
 'C46Pow08': 'm~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~o????^}????B~w????N~o????^~o????^~w????N~}????B~~o????^w',
 'C47Pow08': 'n~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^{????B~o????N~_????^~_????^~o????N~{????B~~_????^~}????@~_',
 'C48Pow08': 'o~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~_????N~?????^~?????^~_????N~w????B~~?????^~{????@~~w????B~',
 'C49Pow08': 'p~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N}?????^}?????^~?????N~o????B~}?????^~w????@~~o????B~~o????B~',
 'C50Pow08': 'q~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^{?????^}?????N~_????B~{?????^~o????@~~_????B~~_????B~~o????@~_',
 'C51Pow08': 'r~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^{?????N~?????B~w?????^~_????@~~?????B~~?????B~~_????@~~w?????^w',
 'C52Pow08': 's~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^w?????N}?????B~o?????^~?????@~}?????B~}?????B~~?????@~~o?????^~}?????B~',
 'C53Pow08': 't~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^w?????N{?????B~_?????^}?????@~{?????B~{?????B~}?????@~~_?????^~{?????B~~o?????N{',
 'C54Pow08': 'u~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^w?????N{?????B~??????^{?????@~w?????B~w?????B~{?????@~~??????^~w?????B~~_?????N~~??????^w',
 'C55Pow08': 'v~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^w?????N{?????B~??????^w?????@~o?????B~o?????B~w?????@~}??????^~o?????B~~??????N~}??????^~}??????^w',
 'C56Pow08': 'w~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^w?????N{?????B~??????^w?????@~_?????B~_?????B~o?????@~{??????^~_?????B~}??????N~{??????^~{??????^~}??????N{',
 'C57Pow08': 'x~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^w?????N{?????B~??????^w?????@~_?????B~??????B~_?????@~w??????^~??????B~{??????N~w??????^~w??????^~{??????N~~??????B~',
 'C58Pow08': 'y~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^w?????N{?????B~??????^w?????@~_?????B~??????B~??????@~o??????^}??????B~w??????N~o??????^~o??????^~w??????N~}??????B~~o??????^w',
 'C59Pow08': 'z~~~~~~^x~b~B~@~_^wB~?N{?^w?^w?N{?B~??^w?@~_?B~??B~??@~_??^w??B~???N{???^w???^w???N{???B~????^w???@~_???B~????B~????@~_????^w????B~?????N{?????^w?????^w?????N{?????B~??????^w?????@~_?????B~??????B~??????@~_??????^{??????B~o??????N~_??????^~_??????^~o??????N~{??????B~~_??????^~}??????@~_',
 'C60Pow16': '{~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~}????N~~o???@~~~????F~~}????N~~}????N~~~????F~~~o???@~~~}????N~~~w????~~~~o???@~~~~o???@~~~~w????~~~~}????N~~~~o???@~~~~~????F~~~~}????N~~',
 'C61Pow16': '|~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~_???@~~}????F~~{????N~~{????N~~}????F~~~_???@~~~{????N~~~o????~~~~_???@~~~~_???@~~~~o????~~~~{????N~~~~_???@~~~~}????F~~~~{????N~~~~{????N~~',
 'C62Pow16': '}~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~{????F~~w????N~~w????N~~{????F~~~????@~~~w????N~~~_????~~~~????@~~~~????@~~~~_????~~~~w????N~~~~????@~~~~{????F~~~~w????N~~~~w????N~~~~{????F~~_',
 'C63Pow16': '~??~~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~o????N~~o????N~~w????F~~}????@~~~o????N~~~?????~~~}????@~~~}????@~~~~?????~~~~o????N~~~}????@~~~~w????F~~~~o????N~~~~o????N~~~~w????F~~~~}????@~~w',
 'C64Pow16': '~?@?~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~_????N~~o????F~~{????@~~~_????N~~}?????~~~{????@~~~{????@~~~}?????~~~~_????N~~~{????@~~~~o????F~~~~_????N~~~~_????N~~~~o????F~~~~{????@~~~~~_????N~~',
 'C65Pow16': '~?@@~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~_????F~~w????@~~~?????N~~{?????~~~w????@~~~w????@~~~{?????~~~~?????N~~~w????@~~~~_????F~~~~?????N~~~~?????N~~~~_????F~~~~w????@~~~~~?????N~~~~{?????~~{',
 'C66Pow16': '~?@A~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~o????@~~}?????N~~w?????~~~o????@~~~o????@~~~w?????~~~}?????N~~~o????@~~~~?????F~~~}?????N~~~}?????N~~~~?????F~~~~o????@~~~~}?????N~~~~w?????~~~~~o????@~~w',
 'C67Pow16': '~?@B~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~{?????N~~o?????~~~_????@~~~_????@~~~o?????~~~{?????N~~~_????@~~~}?????F~~~{?????N~~~{?????N~~~}?????F~~~~_????@~~~~{?????N~~~~o?????~~~~~_????@~~~~~_????@~~w',
 'C68Pow16': '~?@C~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~_?????~~~?????@~~~?????@~~~_?????~~~w?????N~~~?????@~~~{?????F~~~w?????N~~~w?????N~~~{?????F~~~~?????@~~~~w?????N~~~~_?????~~~~~?????@~~~~~?????@~~~~~_?????~~{',
 'C69Pow16': '~?@D~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~}?????@~~}?????@~~~??????~~~o?????N~~}?????@~~~w?????F~~~o?????N~~~o?????N~~~w?????F~~~}?????@~~~~o?????N~~~~??????~~~~}?????@~~~~}?????@~~~~~??????~~~~~o?????N~~',
 'C70Pow16': '~?@E~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~{?????@~~}??????~~~_?????N~~{?????@~~~o?????F~~~_?????N~~~_?????N~~~o?????F~~~{?????@~~~~_?????N~~~}??????~~~~{?????@~~~~{?????@~~~~}??????~~~~~_?????N~~~~{?????@~~w',
 'C71Pow16': '~?@F~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~{??????~~~??????N~~w?????@~~~_?????F~~~??????N~~~??????N~~~_?????F~~~w?????@~~~~??????N~~~{??????~~~~w?????@~~~~w?????@~~~~{??????~~~~~??????N~~~~w?????@~~~~~_?????F~~_',
 'C72Pow16': '~?@G~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~}??????N~~o?????@~~~??????F~~}??????N~~}??????N~~~??????F~~~o?????@~~~}??????N~~~w??????~~~~o?????@~~~~o?????@~~~~w??????~~~~}??????N~~~~o?????@~~~~~??????F~~~~}??????N~~',
 'C73Pow16': '~?@H~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~_?????@~~}??????F~~{??????N~~{??????N~~}??????F~~~_?????@~~~{??????N~~~o??????~~~~_?????@~~~~_?????@~~~~o??????~~~~{??????N~~~~_?????@~~~~}??????F~~~~{??????N~~~~{??????N~~',
 'C74Pow16': '~?@I~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~{??????F~~w??????N~~w??????N~~{??????F~~~??????@~~~w??????N~~~_??????~~~~??????@~~~~??????@~~~~_??????~~~~w??????N~~~~??????@~~~~{??????F~~~~w??????N~~~~w??????N~~~~{??????F~~_',
 'C75Pow16': '~?@J~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~o??????N~~o??????N~~w??????F~~}??????@~~~o??????N~~~???????~~~}??????@~~~}??????@~~~~???????~~~~o??????N~~~}??????@~~~~w??????F~~~~o??????N~~~~o??????N~~~~w??????F~~~~}??????@~~w',
 'C76Pow16': '~?@K~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~_??????N~~o??????F~~{??????@~~~_??????N~~}???????~~~{??????@~~~{??????@~~~}???????~~~~_??????N~~~{??????@~~~~o??????F~~~~_??????N~~~~_??????N~~~~o??????F~~~~{??????@~~~~~_??????N~~',
 'C77Pow16': '~?@L~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~_??????F~~w??????@~~~???????N~~{???????~~~w??????@~~~w??????@~~~{???????~~~~???????N~~~w??????@~~~~_??????F~~~~???????N~~~~???????N~~~~_??????F~~~~w??????@~~~~~???????N~~~~{???????~~{',
 'C78Pow16': '~?@M~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~o??????@~~}???????N~~w???????~~~o??????@~~~o??????@~~~w???????~~~}???????N~~~o??????@~~~~???????F~~~}???????N~~~}???????N~~~~???????F~~~~o??????@~~~~}???????N~~~~w???????~~~~~o??????@~~w',
 'C79Pow16': '~?@N~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~{???????N~~o???????~~~_??????@~~~_??????@~~~o???????~~~{???????N~~~_??????@~~~}???????F~~~{???????N~~~{???????N~~~}???????F~~~~_??????@~~~~{???????N~~~~o???????~~~~~_??????@~~~~~_??????@~~w',
 'C80Pow16': '~?@O~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~_???????~~~???????@~~~???????@~~~_???????~~~w???????N~~~???????@~~~{???????F~~~w???????N~~~w???????N~~~{???????F~~~~???????@~~~~w???????N~~~~_???????~~~~~???????@~~~~~???????@~~~~~_???????~~{',
 'C81Pow16': '~?@P~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~}???????@~~}???????@~~~????????~~~o???????N~~}???????@~~~w???????F~~~o???????N~~~o???????N~~~w???????F~~~}???????@~~~~o???????N~~~~????????~~~~}???????@~~~~}???????@~~~~~????????~~~~~o???????N~~',
 'C82Pow16': '~?@Q~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~{???????@~~}????????~~~_???????N~~{???????@~~~o???????F~~~_???????N~~~_???????N~~~o???????F~~~{???????@~~~~_???????N~~~}????????~~~~{???????@~~~~{???????@~~~~}????????~~~~~_???????N~~~~{???????@~~w',
 'C83Pow16': '~?@R~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~{????????~~~????????N~~w???????@~~~_???????F~~~????????N~~~????????N~~~_???????F~~~w???????@~~~~????????N~~~{????????~~~~w???????@~~~~w???????@~~~~{????????~~~~~????????N~~~~w???????@~~~~~_???????F~~_',
 'C84Pow16': '~?@S~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~}????????N~~o???????@~~~????????F~~}????????N~~}????????N~~~????????F~~~o???????@~~~}????????N~~~w????????~~~~o???????@~~~~o???????@~~~~w????????~~~~}????????N~~~~o???????@~~~~~????????F~~~~}????????N~~',
 'C85Pow16': '~?@T~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~_???????@~~}????????F~~{????????N~~{????????N~~}????????F~~~_???????@~~~{????????N~~~o????????~~~~_???????@~~~~_???????@~~~~o????????~~~~{????????N~~~~_???????@~~~~}????????F~~~~{????????N~~~~{????????N~~',
 'C86Pow16': '~?@U~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~{????????F~~w????????N~~w????????N~~{????????F~~~????????@~~~w????????N~~~_????????~~~~????????@~~~~????????@~~~~_????????~~~~w????????N~~~~????????@~~~~{????????F~~~~w????????N~~~~w????????N~~~~{????????F~~_',
 'C87Pow16': '~?@V~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~o????????N~~o????????N~~w????????F~~}????????@~~~o????????N~~~?????????~~~}????????@~~~}????????@~~~~?????????~~~~o????????N~~~}????????@~~~~w????????F~~~~o????????N~~~~o????????N~~~~w????????F~~~~}????????@~~w',
 'C88Pow16': '~?@W~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~_????????N~~o????????F~~{????????@~~~_????????N~~}?????????~~~{????????@~~~{????????@~~~}?????????~~~~_????????N~~~{????????@~~~~o????????F~~~~_????????N~~~~_????????N~~~~o????????F~~~~{????????@~~~~~_????????N~~',
 'C89Pow16': '~?@X~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~_????????F~~w????????@~~~?????????N~~{?????????~~~w????????@~~~w????????@~~~{?????????~~~~?????????N~~~w????????@~~~~_????????F~~~~?????????N~~~~?????????N~~~~_????????F~~~~w????????@~~~~~?????????N~~~~{?????????~~{',
 'C90Pow16': '~?@Y~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~o????????@~~}?????????N~~w?????????~~~o????????@~~~o????????@~~~w?????????~~~}?????????N~~~o????????@~~~~?????????F~~~}?????????N~~~}?????????N~~~~?????????F~~~~o????????@~~~~}?????????N~~~~w?????????~~~~~o????????@~~w',
 'C91Pow16': '~?@Z~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~{?????????N~~o?????????~~~_????????@~~~_????????@~~~o?????????~~~{?????????N~~~_????????@~~~}?????????F~~~{?????????N~~~{?????????N~~~}?????????F~~~~_????????@~~~~{?????????N~~~~o?????????~~~~~_????????@~~~~~_????????@~~w',
 'C92Pow16': '~?@[~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~w?????????N~~_?????????~~~?????????@~~~?????????@~~~_?????????~~~w?????????N~~~?????????@~~~{?????????F~~~w?????????N~~~w?????????N~~~{?????????F~~~~?????????@~~~~w?????????N~~~~_?????????~~~~~?????????@~~~~~?????????@~~~~~_?????????~~{',
 'C93Pow16': '~?@\\~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~w?????????N~~??????????~~}?????????@~~}?????????@~~~??????????~~~o?????????N~~}?????????@~~~w?????????F~~~o?????????N~~~o?????????N~~~w?????????F~~~}?????????@~~~~o?????????N~~~~??????????~~~~}?????????@~~~~}?????????@~~~~~??????????~~~~~o?????????N~~',
 'C94Pow16': '~?@]~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~w?????????N~~??????????~~{?????????@~~{?????????@~~}??????????~~~_?????????N~~{?????????@~~~o?????????F~~~_?????????N~~~_?????????N~~~o?????????F~~~{?????????@~~~~_?????????N~~~}??????????~~~~{?????????@~~~~{?????????@~~~~}??????????~~~~~_?????????N~~~~{?????????@~~w',
 'C95Pow16': '~?@^~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~w?????????N~~??????????~~{?????????@~~w?????????@~~{??????????~~~??????????N~~w?????????@~~~_?????????F~~~??????????N~~~??????????N~~~_?????????F~~~w?????????@~~~~??????????N~~~{??????????~~~~w?????????@~~~~w?????????@~~~~{??????????~~~~~??????????N~~~~w?????????@~~~~~_?????????F~~_',
 'C96Pow16': '~?@_~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~w?????????N~~??????????~~{?????????@~~w?????????@~~w??????????~~}??????????N~~o?????????@~~~??????????F~~}??????????N~~}??????????N~~~??????????F~~~o?????????@~~~}??????????N~~~w??????????~~~~o?????????@~~~~o?????????@~~~~w??????????~~~~}??????????N~~~~o?????????@~~~~~??????????F~~~~}??????????N~~',
 'C97Pow16': '~?@`~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~w?????????N~~??????????~~{?????????@~~w?????????@~~w??????????~~{??????????N~~_?????????@~~}??????????F~~{??????????N~~{??????????N~~}??????????F~~~_?????????@~~~{??????????N~~~o??????????~~~~_?????????@~~~~_?????????@~~~~o??????????~~~~{??????????N~~~~_?????????@~~~~}??????????F~~~~{??????????N~~~~{??????????N~~',
 'C98Pow16': '~?@a~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~w?????????N~~??????????~~{?????????@~~w?????????@~~w??????????~~{??????????N~~??????????@~~{??????????F~~w??????????N~~w??????????N~~{??????????F~~~??????????@~~~w??????????N~~~_??????????~~~~??????????@~~~~??????????@~~~~_??????????~~~~w??????????N~~~~??????????@~~~~{??????????F~~~~w??????????N~~~~w??????????N~~~~{??????????F~~_',
 'C99Pow16': '~?@b~~~~~~~~~~~~~~~~~~~~~~|~~x~~w~~{N~~@~~wF~~_N~~?N~~?F~~_@~~w?N~~??~~{?@~~w?@~~w??~~{??N~~??@~~w??F~~_??N~~???N~~???F~~_??@~~w???N~~????~~{???@~~w???@~~w????~~{????N~~????@~~w????F~~_????N~~?????N~~?????F~~_????@~~w?????N~~??????~~{?????@~~w?????@~~w??????~~{??????N~~??????@~~w??????F~~_??????N~~???????N~~???????F~~_??????@~~w???????N~~????????~~{???????@~~w???????@~~w????????~~{????????N~~????????@~~w????????F~~_????????N~~?????????N~~?????????F~~_????????@~~w?????????N~~??????????~~{?????????@~~w?????????@~~w??????????~~{??????????N~~??????????@~~w??????????F~~o??????????N~~o??????????N~~w??????????F~~}??????????@~~~o??????????N~~~???????????~~~}??????????@~~~}??????????@~~~~???????????~~~~o??????????N~~~}??????????@~~~~w??????????F~~~~o??????????N~~~~o??????????N~~~~w??????????F~~~~}??????????@~~w',
 'DenBip04': 'G?vtb_',
 'DenBip05': 'I?B^fPwm?',
 'DenBip06': 'K??BjzgnFw]?',
 'DenBip07': 'M???FfqNf{\\of_~??',
 'DenBip08': 'O????Bl~BM]Ohou_ZGC}?',
 'DenBip09': 'Q??????~m}TknozwVKBf?]gBe_?',
 'DenBip10': 'S???????F}{[v_rKFwDJ_mKBPo@^_Bl??',
 'DenBip11': 'U?????????H}v][u^rA^OjeBMgFf?Dz_@sw?m[??',
 'DenBip12': 'W???????????}mh]UReyGJZBG{FuGBiW@fo?fv?E~o?E}??',
 'DenBip13': 'Y?????????????\\{u{q^gznb[uDw{FYS@V[?I~?Fqc?]XO?}J_?bn???',
 'DenBip14': '[???????????????\\l}Lk^sOt]DW{@\\iBVL?YVoE|C?J\\G?kho?k}??SZg?Er]??',
 'DenBip15': ']?????????????????@bv{Hzvgdy~E\\mBJr_JZgBx|?P|o?xUo?Rv_?Uww?A}~??mnW?BY{???',
 'DenBip16': '_????????????????????s]V\\ndXs`rR`YmO}fOC}T?Jy]?wnC?jHw?VmG?Am|??{|{?Bng_?FM~_?F@^_??',
 'DenBip17': 'a??????????????????????@}k~^JtUdoTzW|hKEp^?E}Y?zRy?F\\q?^~N?Drp_?Hj{?BiVG?EUko?Apz_?BL^G??S~e???',
 'DenBip18': 'c?????????????????????????FZ{^dqQ^foW}iDkTgU|__]z]?om]?PP|_Ahuo?LMm?B|Vo?DYmG?EyzW?BkBk??Ufd??DFhg??H]F_??',
 'DenBip19': 'e????????????????????????????B_v|DlmlRsfF\\cFNx?y\\F_va~?RZkODWNk?ulh??vsk?D^_k?@uFw?@unE??T}c_?FJbo??X~No??vlR_??nIf_???',
 'DenBip20': 'g???????????????????????????????Bw[s}Y`ufbYUt\\oUF{_glyOTwsWAjTq?EVfOAYZe?FuLm??^S}?Bv|Q??plx??FXyc??@uZg??Z^R???lLN_??Kw\\W??@Avy???',
 'DenBip21': 'i???????????????????????????????????bw]ihi|]{y?wm~OrRdWLIvkDdvS?M\\Tw?|Kn_EuX]?Byei?B]p~_?dfcw?Eu|N??Y}hC??jiJg??}YqO??V\\XC??@itV???Zzk???@N\\u_???',
 'DenBip22': 'k??????????????????????????????????????DZ`{k`\\]x}HCa^tCMqB{AAN|_LFUw?xLto?\\~L_AF|d?AYm}O?zhps?FjaR??QVwq??V}ig??szBW??^q]{??F\\Xz_??~bQc???zP|???DZsb???BesU_???',
 'DenBip23': 'm??????????????????????????????????????????N{wVWe~MTt\\a[{xHDte{?L}dIBXXf_BUJqoCglzO@]ikw?vfm[?@VW}o?Eij]??NIza??p}TE??WxH}??CrZj???^Bbs??Ae}qW??EPxr_??FP\\\\???APVzG???~[~}????',
 'DenBip24': 'o??????????????????????????????????????????????fmo^|cvGJ[wwaFFMw^rJu@z|C_@zITWEIY~?AQyLw?zUf|?@itf_?\\?|v??O|MZ??rJxv??\\Smh??Cht}g??meKt??@aNXs??BJ`bw??@rroo??An^Jk???fvfF???E|r_O???]gvo_???',
 'DenBip25': 'q??????????????????????????????????????????????????VyFWdNXVU_A~{M~eqa}UXeDX]s{F~@ng@VvQW?oxZT_@I|Z[?NR]K_?XrjM??MLZz_?Vuyo??AUyk{??VR{p??Bqmnw??Du[Mg??A{jLc??B\\b`q???t[[l???FirH{???THnhO???xmun????_m}b_????',
 'DenBip26': 's??????????????????????????????????????????????????????YC^ZVd|jqjzOSpYzNCF{Z}yBEFnc@U^gM?VBfr_FdrFO?S{yf_?[p`lo?aoN|_?Czvyg?DqzAY??HE]mo?@kn{V??CRg^k??EnwXE??AoZ{r???B[tj_??F~CNI???Xkp{G???NF[MO???M}WqO???JMbJW???CY{c}????',
 'DenBip27': 'u??????????????????????????????????????????????????????????CvoFy\\|m]rvHdQdIvVcEX~GXBjjFP?mLVdo@}OzZ?Fn\\tS?ZC~hO?oukvG?PYkN[?CnBy[??wL{jG?@xftU_?A|Xbt??FhMcu??Am^yk_??FzNGw??C~k?z???TMtbg???Tjm[g???RMUzO???OfXs{???B}l~v????{B~ro???BJTEr_????',
 'DenBip28': 'w???????????????????????????????????????????????????????????????mXyXEvO\\JUYLy^bYEJz`MR}ioP~YNWAhfVQ_ANi~e?khtkg?NbT~C?KVm]O?DT\\S^??csnjS?Aieqso?BXZYh??ApL~E??AeyP\\_??NyhNo??Fzcct???Ujz^M???Tu[P[???ymDpK???J~@IY???Bwxw^????mRqko???BZ~?UO???ELRX\\_???FQjme_????',
 'DenBip29': 'y???????????????????????????????????????????????????????????????????@IMztgx}zdFy?lLorZyR_{oh~UA}pI]O[m~n|?W}qqY?jfONM?Bm~[u?FYKr\\??HUd}k?B_}uPW?@dTMz_?F|BL~o?AceunG??s@}zc??DvyWa_??EYNj^???fuakM???ztotC???DNgU|???E~[^eo???mZmFM????Mj}NG???F|[rS_???Efvjmo???BrXgLg????tnZoA?????',
 'DenBip30': '{????????????????????????????????????????????????????????????????????????@M~gDWVnRFRIj]p[kFmXhAxUNx_H^MlK?~yJld?^P[{M?RqA|x?ENJq}??~]wej?@mRjS[?E@s|io?DIiUZW?@vWzWs??vn]]M??BuU[t???W\\yEL_??JbEns???k~`Gt???Oktk{_??BfMXWo???ZBXvT???AjuPvk???DwQ}}W???C~ckBo???@`uzN[????UtHil????Da^I[w????]Ybz_?????',
 'DenBip31': '}?????????????????????????????????????????????????????????????????????????????D~Zo\\TmRxXWs|s~]fb]HMc?b|vV?JSyo^_~xvup?QB[rvOBJOZ\\k?bPJw~?AHmsva?CykJn_?B|Xeps?Bz}zz[??z~ZPm_?A{~LCW??YzIZ`_??l]\\Zx_??WI^|X_??Kibe|o??@dUUyk???Pueg}_??BruA|a???Btte^[???CslJg{????Yf}qg????q{WVu????@xYyak????^bb}K_????cxirR_????xiuj`??????',
 'DenBip32': '~?@???????????????????????????????????????????????????????????????????????????????????Bq^AaZYkUrZ`QMie}Ufcquo}Sh^n_Dq[^aoR}[IwGFnjBw{?jbu^Q?@EhmmU?F]wkLq??nMuRa?BDd{Zg??H^Jlt_??KE|\\]??ZjTZlg??U{Yrq_??|iuaY???Ni]NMG??Eane`e???|ZZhko??@R^XgF???A|wmiu???C}T|}Y???Agz[LT????CXnyX_???@pyjci????^KOffO????D|}{|o????iFzO^_????Lp_Utw????EY[\\qa?????',
 'DenBip33': '~?@A????????????????????????????????????????????????????????????????????????????????????????qHWw~jKt{^YRwTytOU}VP{gvstuK_VpzQQoDzTZm_?ZTzKwG?E|zI~?BCB}t~?EA^V}A?AmS`~V_?FmqBMw?Aest|B??Cb|vPc??^\\V@UW??}z|jPw??OKjmNw??Bc}ZNZ???|LH}rG??AZdShy_??F|\\FRS???EzoVxn???Auhm?^_???iKujt_???@Nl`lZ????^MafBc????rut_Z_????Vij|`?????AzApx{????ApmQ]u?????hZLT|O????ApVxpZ??????',
 'DenBip34': '~?@C?????????????????????????????????????????????????????????????????????????????????????????????Elof_{s{v`\\g[}R}}WcftkSw\\HnepcFMI\\to_XZvils?ncbfUODbsEbu_EzoUJt?Bw@vygo?fMZSEk?A[NtPM_?TFmmDe??vUaht_??EX}\\ww??^W]HEe???wK}fN???Z_uNck??@J{K\\Yo??B^hOW^???@h|y\\A????iE}K^_???c}VNqC???ErHXFe_???SCgzvk????\\QSftS????zm}pI{????]RSy}o????CtcVYJ_????|}gNyO????AEm`^LO????@mnRbR?????BP}mML??????',
 'DenBip35': '~?@E???????????????????????????????????????????????????????????????????????????????????????????????????@~?{ytjoqK{y^tWY|G^tXATpAuVQ~v_`~dvwG@S{AJ^wDUPVUpoFYrlGroAFFHrLw?c]mvhG?FBljXf_?JNLoNL??`J[nxa??MhDvLe??Vu}dVW??DxUVzgO??Dl|_pm??Bq|NudW??DZfzbu???ErFgp^_??BNVXXIG???vt|kv}???Bcs{[z????MDjlta????X^Ioim????JbflUE????WN^VAq????F}cV]Y_????H^ZPa]????@pW}bRw????AtF}~No????E|ZygQo????BXce{~O?????IbbZ\\i??????',
 'DenBip36': '~?@G?????????????????????????????????????????????????????????????????????????????????????????????????????????S|ip|PoRN[[mHRhwvyD{TepAwL{Wyx`AzgjxxoCrKPivwB[mb][?@F}kSrk?LdVga}?Aqd^cxO?^]ssgf_?tT^knb??{NeJ@l??Vc~R``??@{vM{v???_pkb|r??BkwDd}c??FPJNfT_??BQM}Edg??A~@^DhO???Yi^f]^????j}c^KG???AcJVyZ_???`YYuNY????tMZMQu?????vqJqf_???FzyhR}W????MUw]j\\????@uvov[W????CMKJtew????F^f]|\\G?????in[VwG?????qrP[|K?????AAXyq^o?????ZzBAQm_?????',
 'DenBip37': '~?@I???????????????????????????????????????????????????????????????????????????????????????????????????????????????ytfFeq]Jp[pbdpVMZx?kaam]ybp||^r}Bnuph|wEAE}tMsBuvM[|a?SSuJ\\y_E|Ir}J[??xv{\\c_?J~}x}v??mPtmIw_?NxCuDtO?D{}Jw@g??B^y}b@_?BR}QOq{??D[g|Fc[??B\\xA]mw???]Hpl^S???\\]N}qF_??AZ^NrOC???TT^pEUO???xRbN_z????sb[|hz_???PVelKzo???@kzKTro????][Uf\\C_???AjXvDsE????EMLcMxw????EzMS|Us?????gzf^Fo?????Y{Qkrr?????FulG[qc?????Jc~jJM_?????FILX{m_?????z[Kx|L???????',
 'DenBip38': '~?@K?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????]pmC]lAbMh\\{ETL{vJg`|OC\\mtE{yXJQcBPur[|w?LY^d]E?]g}zTv_CjDuhbs?NMwH]mw?zyZLWGO?w`vwHJo?V}[qB}_?CPNlTtI??OnjUe{O?@|Ao`{n??DBzLGmi??C{}RkaK??@JCle}x???i|faxuO??BHtv^NU???Q]TeXQw???PZNraRo???o}C~O}_???^RcxTxg???FfIKkP{????fzRkPF????@F{gZOv????@\\RFuPe????CQ\\ZgzS?????]u\\ZiC?????mG[B|VO????B|Qz|zO?????TAmY~pW?????h~Lae}_?????d}Hm}}_?????Z_~YGhg?????BL]Hb]E??????',
 'DenBip39': '~?@M????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????\\z{uF`ZfBQJRzG\\kldU`drkY]iE|?\\suJBsXdyq]?e{fjPhwDVhsS`|?Rxu{Keg?[_Es}vo?bmv]VjO?M[ID]Vs?Awpk^uF??NrPVuIG?BA~lv~v_?CE|sclV??DjFya{m???~u?ZoZ_??r^LdjQO??@VbxGW~???J}\\EcFK???h[v|KoG???~RvBK^G???\\TO~XKg???Bt^fLiW????{RwKv}w????CnJ]Kz_???DQk}epd????@Y~FcMh????@jeb{~e?????unrx@@o????Eg\\NXRv?????NoPI^|C?????TP]^lIG?????Qvuc~z??????QCepfnw?????AJbRZuu??????lQI^v{_?????ByExvah???????',
 'DenBip40': '~?@O??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????HfOfxuz}oR~sesr`\\rfhcMiojxpa~br?rXoUHnfRWSCDey}DY_Gb\\[wjq?NWnG{TS?L[bwn@k?Tov`FVS?B{TzkxM??{V]WiFO??KTsl\\NO?F~RHJIa_?Anx_}`d??@ZRZjj\\o??Fnp}M}s??Du~kCYI???]hj]xRW???nq`YY}g???ewBPxs{???LMHPY|U???FU|]lL^_???pIltU^g???@Qd`e^to???B|~Wxw]????@b]Xk]S_???ABlzijEo????uJYlti_????@vReS\\p?????AJnVpdo?????PDi]zxO?????aicuSx{?????W|orEXY?????F]U\\LGh??????|HdvTkw?????BKouh{UO?????BQj`yzD??????DA{]Hfb_??????',
 'DenBip41': '~?@Q?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????|c[lz^~VNspxGCcz~LEb_kY`tF|W|prEkecBZhNo\\Y?\\e]e\\DV?y^U{pJ}?K\\~txUk?Y]UONTr?ENEJLL|o?fYajNsW?@rMbVm~w?CMWnWZf_?E^|ZyQ\\O??]ehRXxo??fdVLuaE??AMzMVrDo??X~]EoEb???d{{eYge???tFwa^Sq???LSANvkt???BWmRiXm_???KMzWs~u???BxO^heeg???@~~sYv_????Ex]bKmZ_???Bxq{~o@?????Lo~elTo????DmykZu^?????LpIN~~k?????JIFUK~e?????{`FncT[?????^pWOi|L?????BN`^PmPO?????\\eNUoDu?????AtKNwMxO?????ARVTRjlO?????ConKK}}??????AhMPusYw??????b^Q]zzI???????',
 'DenBip42': '~?@S???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????@sY~wPwMHZLJpkWnzKysJWbsD~owk@JHBlnaw^Q^q?ro_x[wz`Q[?~y_er[m?YxipIh^_@wp~tmi_?y`x[Yra?@dUwyw~{??x\\VbjX_?EbSr[zGg?AR[}v_r???~LmVYuc??Bg_yNygw??^dxljEl_??Va}F|iR???JzF{YbO???GfXQ\\te_??FY~aJu]G???MnxxDVA???B[xtAMXc????BJQ|Fyw???CTj~[DfO????^oYw}A{????\\k{gZO{????@`Daz\\vo????^OYxztu?????BvA{rBm??????^]UMMl?????UYJprYB_????AnxwMB]W?????yvC`mwL?????AzntLATk?????DiDzWnBG??????@l[Kx}w?????BRAEZpVs??????~yS{`PX??????EcY\\l^zO??????WMO{mY|???????',
 'DenBip43': '~?@U??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Ea[yJ_~Y^IJ{IT[_a^jpp]fpqcartoN}LrTXk?FOJld^i_`xymraK_AEz[t[boFW\\XUyTk?nzMgEwt?Ac~bNadW?@~mURIzk?@^hX[XQk?AqfXmHq[??QL{F^xO_?E`ZfJkdW??^bIgE}F_??l~~PXDM???\\y`Jftn???[YWN^}oo??F`FzZ@}G???RrVwwjx_??@c]]UP^E???FexM|Tas???F]N]~lR_????zUVe|]s????DNn_y]r_???EV?lwle[????E_~NKjkO????n{kdmIH?????YnBewJq_????UzwPRjko????CqvnlfEo?????sAe^Q{n?????@xf`xiQq?????AHJPbv^o?????B@ZI{~TS?????AnQ@W}Y{??????Bl|[\\@[_?????BcxmiDe[??????^~QHRcpO??????UC`Pv}f_??????r]YmRRO_???????',
 'DenBip44': '~?@W?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????BXUVkYxN\\b`FwYV``xm]U|]JynkLYx?S[]krVt?nmTNdAMoSxkffYq?BHn{Cc]s?icyD\\sqo@{z{mQ\\p?C{~EF`Xg?@y|aUqNG?BMn{ynaB??SiKS]zV_?DbtvmG@U??K]uy|iSG??c\\nDf]`???ofZ_Fm^???Hj\\nTUwo??@yLUn|la???|mTfKbqo??@N_RIvbm???CCku|Hte???DWfPo|cm????{fav@za????xXfN\\\\Co????BJjrWq}????VagMdhFw????Dyv~kYb?????VtGpwqwo????ZYD\\[yFW????CdIrR}rA?????wZv?pjHo????A@aPd}Nz?????EzSZaxHY?????D~vCJtyq?????BbjjWyvl??????m`B}hwQo?????BV{L|MXg??????WzH`jZh_??????}a@hON~_??????iF[Wep^O??????NZXpqnu_???????Isf]jie???????',
 'DenBip45': '~?@Y?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????TpwUmJmH[U|rtk@?Nl~B\\[CzXWKsjio|FUWUswWCe}JrJqcCbc||\\wZ?~Z?RnmMwBRp}^IJJ?EuyRjGN]?EWR]eWzp?AJzRefEV??LU^tgdKw?@H\\ai~qM??Ib~Lynns??~hdvzYDg??vm{A~E@O??TqXVHY[w??A|dq^Iio???gjaby{qW??BrX\\C]fV???EI\\tEawn???AAvk|iv_???AZ}wLVOa_???wPW}A~z????F\\JJSMYT????FvKS}^~W????JIvdzw`w????zXUNqYF?????VJbu@l^K????B]|mPHl|?????{xZ\\Kb|g????A\\uscQZF_?????XhFx|YU?????FZtZqIHa??????rQMg~NV??????U{b\\eWNG?????Fo{mBHmr??????AzdRjLTW??????PzpAxR~???????SyFkhypW??????^[d~nIt{???????vkNBVmk???????morxNCng???????gfo]utk_???????',
 'DenBip46': '~?@[????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Ff|JcQhNqs^iBpm{rW~jsQEGVX[[{hCkFBv|lkM]@f^QgrVv?kHTnFWB{Ah}lNumh_ECoEl~E\\_@v\\ScDLz?AtA^nELL??dnFwnfUs?AFw|sjmO??^sErIH[k??o}Vmwdrc??q^WDhSV[??IQEF{}fS???}qoI}ez???RWXx[}T_???uVTxwlGO??F~_sUtjw???BoNHnSVQ_??AmEX]Dz]o???^_ai{vlk???F}Zo@\\VH_???EG|\\}rB{????v|GPVlgG????LI|Q{Jbc????J^TlIAnC????FFJLYzgc?????KZjnn`K??????w^J^hwaO?????Rf]@U\\m_????EL~AJVFW_????@HCFt^]r_?????rJVkaO[{?????CIplZnm}??????M_]VIlz_??????anCKaN~S??????r?teX]es??????@bwgv}Ay??????FnrtN\\S@_??????}{u\\^K{[??????@AY[Y^[j_??????DJ}}rmcZ???????Fwo}KTv`_???????',
 'DenBip47': '~?@]????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????FmQbhp{qWV@jyD~ueR`rsUfUT[~{[fHq@xPIzhfF_vdMn{miG@QrItJ[jgCiBg{^ZboDtmCW}}io?Yk~ong`g?Q`Ppnf^S?EIRi~sAlO?Z}GSd}Lw??hQY]Dxui??NZm{Vad_??Tf]RdsD[??BuV~Mhcro??CjuZnw]m??B@[mYdvFo???cg]~scfo??@}bwcJVr???BSTx_Z[n_???}oay[]ZE???BskrnaKdO???HzuFRY[c????wVPvmym?????ZXVUzh@Y????ZvamlBZl????FUtdQdPl_????~uaMXLQK????BmXvPdMxO????@Bedxiimo????BkgZVRb[O????BCFn@^i}o?????Umz`iWtU?????DnQGmmm{??????MdzSeVso??????j[sR}D{U??????mWYKR~rm??????ItrE^Y{C??????CJkoYX{yo??????JqJ\\eZ[K??????BA~ncSX`W??????CJ^fs^YuO??????FVnz?BY\\o???????tpt]sClW???????u~g{qRnm????????',
 'DenBip48': '~?@_????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Im^xtIcWkPV}o}ooP[sZpINJepbxTtyW_IB|_JzDn?GF]ymRrKA^D}{i]kOAFx^G@flgB|j||Z_]c?|mf?Ysy`?CxrmpJPJW?AqmyJ}Xo??H^yBasxT??YBMttfTo??OUaev\\jR??EVVg`bKZo??vHsITX[]??@}^EkQzes??FnlVzSGzo??A]q}biIeO???b]dz}ArK???nmuVMViK???@t[\\N|]{g???U[pHuM}c_???tPHvTF]W????qH|Khm\\z????IwCTzqn^????A|vHnwsWw????}XWlQ^yu????BzLYgden_????Dy}GQ~FQ?????FCZ~_VKlg????Bt~RV`y\\g?????HmIIzSnU?????FCTnH^l?g?????HJRG|HB~_?????|in{_KWk??????JMzQZJV@??????S^H\\LRQf_?????BhgP~lP^w???????\\QxK~uF??????@^YBRQTlc??????C\\ef{Hv@_??????FmHh_MleW??????A~LsZmLH{???????{xE`tTBy????????A`bu|Zfg???????AyRC~raR_???????',
 'DenBip49': '~?@a????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????id{X}]FRGzdQpT}teWJZbwwp{dw~fiKKQ`Qyl\\az]CFcpfQDT^c@hoxHbZ|c@}vbbvl_k?D~cku{LN?B~Kqvmr_g?If]azRXCo?]X^JXtue??rdK~exUO??JOhph~YJ_?C]ztbBH~c??_u}Oknpt??Blk|iJWYS???yfFV_jiw??EChpiXfxw??@@qQ~lUvC???lpjf`{gI_??FMxpv~\\[????QLqZol{JO???]LtSBLTv_???}WxTL_yi_???]^bvKCY^_???CWq~[Wvx?????[i|wxTHm_???ATvtduV?Q?????x^||~^HG????FSb[rtLIc????BMFMpUSzk?????VQ|?p^VQ_????AFsEEzqV{?????EPx@drxmo?????Nyfw~UJI??????Jx@vFbKx_?????DFmMhygfO?????FXAyJct|{??????xJfhfUb|_?????APyLwJknE??????Dly_ZrDE[??????FRyN\\oBdc???????oDnkx~}q???????z{c^Dhaw???????FUwvckC]c???????DxYET[jl_???????lyXuuo]r????????~SIFxzou_????????',
 'DenBip50': '~?@c????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????QveUtG}auj_t`{bQ}NT`R^fh?rV@s]OC||FKgYFHtLyB~utLO{Vi?F^~KF{[~?yrQql{HEO@l]E}}_Ec?WIdnXk~Ag?zkjIZ@yy_?PK`Xf{vMO?TJZvHPNQw?BdRFnlV]_??Q|y[XWbl??BXyjcel^Y??DdTUQbqVM??ENy}rQh@A??BWAm~_Vup???VHNm[bw|O??FGzuZscXG????Li@^|~]G???ZnhZaWTq_???iq[f?rXz_???JNjQmhWLO????L{[h{kpM????]pWzPrFB_????oUVxuX~H????C\\Tg|R{`Q????EWnhYPGxu????@yvnSFbw[?????nIs\\P}CBo????D^Z_K~reM?????AMRkP~Kn_?????fRVBu{cxo?????c}HukeGto?????Hhd^XYj}_?????ButRaxX\\???????ftC`|]yf_?????@^A|M`jMq??????DwcnAf~][??????@Jv[kwc{K??????Aa?Vqxv^K???????~kUh[d?ZO??????@P^XVXJPq???????]cI@~dy}G???????spxV}FL~????????LI~L_x^Z_???????LW]OQZVnW???????EiLlk|S_[????????',
 'K02': 'A_',
 'K02K03': 'E{Sw',
 'K02K04': 'G~`HW{',
 'K02K05': 'I~}AHKVBw',
 'K02K06': 'K~~{ACbCwV_~',
 'K02K07': 'M~~~{@@GWb`N@^?~_',
 'K02K08': 'O~~~~}?OH@aFAN@N_VwB~',
 'K02K09': 'Q~~~~~~_A?cBCFAF_bwC~?V{?~w',
 'K02K10': 'S~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~{',
 'K02K11': 'U~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~w',
 'K02K12': 'W~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~',
 'K02K13': 'Y~~~~~~~~~~~~~_?G?H?BC?[G@wGBwCB{@@~?G^w?b~_@N~?@^~??~~_',
 'K02K14': '[~~~~~~~~~~~~~~~o?A?@G?KO?wO@wG@{A?~?ONw@@~_AF~?AN~?@N~_?V~w?B~~',
 'K02K15': ']~~~~~~~~~~~~~~~~~{??O?C_?W_?wO?{C?^?_FwA?~_CB~?CF~?AF~_?b~w?C~~??V~{??~~w',
 'K02K16': '_~~~~~~~~~~~~~~~~~~~~_?@??H??W_?[G?N@?BwC?^_G@~?GB~?CB~_@@~w?G^~??b~{?@N~w?@^~w??~~{',
 'K02K17': 'a~~~~~~~~~~~~~~~~~~~~~~}??A??H??KO?FA?@wG?N_O?~?O@~?G@~_A?~w?ON~?@@~{?AF~w?AN~w?@N~{??V~~??B~~w',
 'K02K18': 'c~~~~~~~~~~~~~~~~~~~~~~~~~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_F~?A?~{?CB~w?CF~w?AF~{??b~~??C~~w??V~~_??~~~',
 'K02K19': 'e~~~~~~~~~~~~~~~~~~~~~~~~~~~~{??@??@G??W_?B`??N@??^?_?^_G?Nw@?B~?C?^{?G@~w?GB~w?CB~{?@@~~??G^~w??b~~_?@N~~??@^~~???~~~_',
 'K02K20': 'g~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O@~w?G@~{?A?~~??ON~w?@@~~_?AF~~??AN~~??@N~~_??V~~w??B~~~',
 'K03': 'Bw',
 'K03K03': 'H{S{aSf',
 'K03K03K03': 'Z{S{aSf_A?cBCCAA__wCc?QS?c{?_A?OC_CBC?__OAA__CF?_Cc?OAQ_C?cw',
 'K03K03K04': 'c~`HW}GPHDaN_?O?c?W_FA?_C@GC@WA?{?aG?CPG?PD_?aN_?_?O?O?c?C?W_?_FA?A?_C?C@GC?C@WA?A?{?_?aG?C?CPG?O?PD_?_?aN',
 'K03K03K05': 'l~}AHKVB{GGPGRCJ`B{??O?C_?W_?wO?{C?O?_AGA?H_C?V?C?^?ACG??`AG?CGR??O`[??`B{??_?A??O?C_?C?BC??_?wO?A?F__?C?O?_?C?P?O?A?H_C??_Aw?_?C?^?A??O`??C??`AG?C??`AW?A??O`[??_?CG^',
 'K03K03K06': 'u~~{ACbCwV_~__OOcCW_fAA{CF{??A??C_?BC??wO?F__?^?_?_?O?O_C?CW?_?f?A?A{?C?Fw?CCC??AAAC??__b??CCCw??OOV_??__~_??_??O??O??c??C??W_??_?FA??A??{C??C?BwC??C?C?A??A?AC?_??_?b?C??C?Cw?O??O?V_?_??_?~??_??___??O??OOO_?C??CCCW??_??__f??A??AAA{??C??CCFw',
 'K03K03K07': '~??~~~~{@@GWb`N@^?~oGA@@GCKOGwOHwGD{A@~_??A???c??BC??FA??F__?BwC??~?O?C??_?GG?_?GW?O?C[?C?@N??_?Jw?A??~_?CA@???CA@@??A@?`_??_OGw??CA@N???OGD{???_ON{???_??A???O??C_??C??BC???_??wO??A??F__??C??^?_??C??~?O??A??_?C???_?GG?_??C?@B?A???O?C[?C???_?Hw?C???_?Jw?A???O?F{??_??CA@???C???_OGG??O??A@?`_??_??CA@F???_??CA@N???O??A@?n_??C???_ONw',
 'K03K03K08': '~?@G~~~~}?OH@aFAN@N_VwB~_G@?OH?OW_G[GAN@?RwC@^_GB~_???O???c???W_??FA???{C??BwC??FwA??F{?_?A??C??OG?O?@@_?_?AF??_?AN??O?@N_?C??Vw??_?B~??A?_G???C@?OG??C@?OW??A?_G[???_GAN???C@?Rw???OC@^_???_GB~_???_???O???O???c???C???W_???_??FA???A???{C???C??BwC???C??FwA???A??F{?_???_?A??C???C??OG?O???O?@@_?_???_?AF??_???_?AN??O???O?@N_?C???C??Vw??_???_?B~??A???A?_G???C???C@?OG??C???C@?OW??A???A?_G[???_???_GAN???C???C@?Rw???O???OC@^_???_???_GB~',
 'K03K03K09': '~?@P~~~~~~_A?cBCFAF_bwC~?V{?~{?_A?OC_CBC?_wOAF__C^?_C~?OA~_C?~{????O???C_???W_???wO???{C???^?_??FwA???~_C??B~?C??C??A??A?_?_??_W?C??CF??O??O{??_??bw??_??fw??O??V{??C??F~???_C?_???A?OA?_??C?_CB???C?_CF???A?OAF_???_C?bw???C?_C~????OA?V{????_C?~{????_???A????O???C_???C???BC????_???wO???A???F__???C???^?_???C???~?O???A???~_C????_??^w?_???C??C??A????O??OC?C????_??_W?C????_??_w?A????O??O{??_???C??C^??C????_??fw??O???A??A~_??_???C??F~???_???C?_C????O???A?OA?_??C????_C?_W???_???C?_CF???A????OA?O{???C????_C?bw???C????_C?fw???A????OA?V{????_???C?_F~',
 'K03K03K10': '~?@Y~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~{????A????C_???BC????wO???F__???^?_???~?O???~_C???^w?_??F~?A???_??C??@?G?C??@?W?A???_[??_??GN??C??@Bw??O??C^_??_??H~???_??J~???O??F~_??C?O@?????_A?G@???A?G?_K???C?O@?w???C?O@@w???A?G?`{????_A?G~????C?O@Nw????O@?D~_????_A?N~_????_????O????O????c????C????W_????_???FA????A????{C????C???BwC????C???FwA????A???F{?_????_??B~?C????C???~w?O????O??C???_????_??G@??_????_??GB??O????O??CB_?C????C??@@w??_????_??G^??A????A???b{??C????C??@Nw??C????C??@^w??A????A???~{???_????_A?G????C????C?O@?G???O????O@?C@_???_????_A?GF????_????_A?GN????O????O@?CN_???C????C?O@Fw????_????_A?H~????A????A?G?n{????C????C?O@~w',
 'K03K03K11': '~?@b~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{?G?G?O@G?OBC?GB`?A@wG?O^?_@B{@?ANw@?A^w?_@^{?G?^~_????A?????c????BC????FA????F__???BwC????~?O???F{?_???^w?_???~w?O???~{?C???O???_??A?G?A???G@_?C???OF??C???ON??A???GN_??_??AFw??C???P~???O??@N{???_??A~w???_??B~w???O?_@?????C?G?O@????_@?A?W???A?C?GB_???C?G?ON????C?G?O^????A?C?G^_????_@?ANw????C?G?R~?????O?_@^{?????_@?B~{?????_????A?????O????C_????C????BC?????_????wO????A????F__????C????^?_????C????~?O????A????~_C?????_???^w?_????C???F~?A?????O???~{?C?????_??A???C?????_??A?G?A?????O??@?K??_????C???OF??C?????_??A@w??O????A???GN_??_????C???O~???_????C???P~???O????A???H~_??C?????_??A~w???_????C???^~???A?????O?_@?????C?????_@?A?G???C?????_@?A?W???A?????O?_@?[????_????C?G?ON????C?????_@?ABw????O????A?C?G^_????_????C?G?P~?????_????C?G?R~?????O????A?C?J~_????C?????_@?B~w',
 'K03K04': 'K~`HW}GPHDaN',
 'K03K04K04': 'o~`HW}GPHDaNaGPCcPWaN_?@??H??W_?[G?G@?@GC?D_G?N?GAG?C@C_@?PW?GAN??aG_?@CPG?@CPW??aG}??G??O?@??H??C?@a??G?FA??G?G@??C?C_O?@?@WA??G?N?G??_G_?O?@?PG?O?@?PW?G??_G{?A??GaG??O?@CPG?@??CPD_?A??GaN',
 'K03K04K05': '{~}AHKVB{GGPGRCJ`B{GOO`C`AW`AwO`}???O??H??@a??FA??N@??G?O?AGA??R?G?@[?O?Bw?O@A??G?`C?A?GR??O@Aw?@?CN_?ACGO??ACGP??@ACH_??O`Aw??ACG^_??G??@???O??H???O??W_??G??[G??A??N@???O?A?C??@??G_G??A??R?G??A??V?C??@??N_@???O@A??G??A?GP??_??G?`K?@???O@Aw?@???O@Bw??_??GO`???G??ACGP??@???O`AW??C??@ACJ_??G??ACG^',
 'K03K04K06': '~?@G~~{ACbCwV_~__OOcCW_fAA{CF{CCAAAC__bCCCwOOV___~_???O???c???W_??FA???{C??BwC??C?A??AC?_??b?C??Cw?O??V_?_??~??_?__??O?OO_?C?CCW??_?_f??A?AA{??C?CFw??CCCC???AAAAC???___b???CCCCw???OOOV_???___~_???_???O???O???c???C???W_???_??FA???A???{C???C??BwC???C??C?A???A??AC?_???_??b?C???C??Cw?O???O??V_?_???_??~??_???_?__??O???O?OO_?C???C?CCW??_???_?_f??A???A?AA{??C???C?CFw??C???CCCC???A???AAAAC???_???___b???C???CCCCw???O???OOOV_???_???___~',
 'K03K04K07': '~?@S~~~{@@GWb`N@^?~oGA@@GCKOGwOHwGD{A@~_OGA@?_cA@BCA@FA@?f__OJwCA@~_???@????H????W_???[G???N@???BwC???^_G??@??G??@@?C???`_@???Gw?G??@N??_??D{?@???Nw?@??OG???_?GCC??G?A@B??@??OGw??C?@?f_??G?A@^???G?A@~???CA@?_???@?_OGG???GCA@B????_OGC[???@?_OHw???@?_OJw????_OGF}????G????O???@????H????C???@a????G???FA????G???N@????C???N_O???@???FwA????G??@??G????_??CC?O???@???GW?O???@???Gw?G????_??C{?A????G??@^??O???@???Nw?@????C?@?_??A????G?A@@??A????G?A@B??@????C?@?b_??O???@??OHw??A????G?A@^???G????_?GF{???O???@?_OG????O???@?_OGG???G????_OGCK???A????GCA@F????O???@?_OHw???@????CA@?n_???A????GCA@~',
 'K03K04K08': '~?@_~~~~}?OH@aFAN@N_VwB~_G@?OH?OW_G[GAN@?RwC@^_GB~_GA?OC@?c@?OW_GAFA?_G{C@?RwC@?VwA?_N}?????O????H????@a????FA????N@????N_O???FwA???@~?G???G??O???OG?O???OW?G???G[?A???AN??O???Rw?@???@^_?A???B~??A??GA???@??C@?_??O?@?OW??A??GAF???G??_G{???O?@?Rw???O?@?Vw???G??_N{???A?_GA?????OC@?OG???@?OC@@_???A?_GAF????A?_GAN????@?OC@N_????OC@?Vw????A?_GB~_????G????@?????O????H?????O????W_????G????[G????A????N@?????O???BwC????@????^_G????A???@~?G????A???A??C????@???@?_@?????O???OW?G????A???AF??_????G???G{?@?????O???Rw?@?????O???Vw??_????G???N{??G????A??GA???@?????O?@?OG??C????@??C@@_??G????A??GAF???G????A??GAN???C????@??C@N_??@?????O?@?Vw???G????A??GB~????_????GA?_G????@?????OC@?OG???@?????OC@?OW????_????GA?_G[????G????A?_GAN????@?????OC@?Rw????C????@?OC@^_????G????A?_GB~',
 'K03K05': 'N~}AHKVB{GGPGRCJ`Bw',
 'K03K05K05': '~?@J~}AHKVB{GGPGRCJ`B{GOO`C`AW`AwO`}CGOO`AHACHaCGVACG^_???G???H???BC???[G??@wG??A?C??@C@???R?G??Aw?_??N_@??GO?@??GP??_?CH_?G?@Aw?@??G^??C?O`???G?`AG??G?`AW??C?O`[??@?CG^???GO`A????`ACG_??@ACGR???@ACGV????`ACNo???G???A???@???@G???C???KO???G???wO???G??@wG???C??@?A???@???P?O???G??AW@????_??J_A???@???^?A???@??GO?@????_?CG_?O???G?@AW?A???@??GV??G???C??`{??O???G?`A???O???G?`AG??G???C?O`K??A???@?CGV???O???G?`Bw??@????`ACG???A???@ACGP???A???@ACGR???@????`ACJ_???O???GO`Bw',
 'K03K05K06': '~?@Y~~{ACbCwV_~__OOcCW_fAA{CF{CCAAAC__bCCCwOOV___~____OOOOcCCCW___fAAAA{CCCF{????A????C_???BC????wO???F__???^?_???_?O???O_C???CW?_???f?A???A{?C???Fw?C??CC??A??AAC??_??_b??C??CCw??O??OV_??_??_~???_?___???O?OOO_??C?CCCW???_?__f???A?AAA{???C?CCFw???CCCCC????AAAAAC????____b????CCCCCw????OOOOV_????____~_????_????O????O????c????C????W_????_???FA????A????{C????C???BwC????C???C?A????A???AC?_????_???b?C????C???Cw?O????O???V_?_????_???~??_????_??__??O????O??OO_?C????C??CCW??_????_??_f??A????A??AA{??C????C??CFw??C????C?CCC???A????A?AAAC???_????_?__b???C????C?CCCw???O????O?OOV_???_????_?__~????_????_____????O????OOOOO_???C????CCCCCW????_????____f????A????AAAAA{????C????CCCCFw',
 'K03K06': 'Q~~{ACbCwV_~__OOcCW_fAA{CFw',
 'K03K07': 'T~~~{@@GWb`N@^?~oGA@@GCKOGwOHwGD{A@~',
 'K03K08': 'W~~~~}?OH@aFAN@N_VwB~_G@?OH?OW_G[GAN@?RwC@^_GB~',
 'K03K09': 'Z~~~~~~_A?cBCFAF_bwC~?V{?~{?_A?OC_CBC?_wOAF__C^?_C~?OA~_C?~w',
 'K03K10': ']~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~w',
 'K03K11': '`~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{?G?G?O@G?OBC?GB`?A@wG?O^?_@B{@?ANw@?A^w?_@^{?G?^~',
 'K03K12': 'c~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_?_?O?O?c?C?W_?_FA?A?{C?CBwC?CFwA?AF{?_?b~?C?C~w?O?V~_?_?~~',
 'K03K13': 'f~~~~~~~~~~~~~_?G?H?BC?[G@wGBwCB{@@~?G^w?b~_@N~?@^~??~~o?G?A?@?@G?C?KO?G?wO?G@wG?C@{A?@?~?O?GNw@??`~_A?@F~?A?@N~?@??n~_?O?N~w',
 'K03K14': 'i~~~~~~~~~~~~~~~o?A?@G?KO?wO@wG@{A?~?ONw@@~_AF~?AN~?@N~_?V~w?B~~_?G?@??O?H??O?W_?G?[G?A?N@??OBwC?@?^_G?A@~?G?AB~?C?@B~_@??P~w?G?A^~??_?J~{?@??^~w',
 'K03K15': 'l~~~~~~~~~~~~~~~~~{??O?C_?W_?wO?{C?^?_FwA?~_CB~?CF~?AF~_?b~w?C~~??V~{??~~{??_?A??O?C_?C?BC??_?wO?A?F__?C?^?_?C?~?O?A?~_C??_^w?_?CF~?A??O~{?C??b~w?C??f~w?A??V~{??_?F~~',
 'K03K16': 'o~~~~~~~~~~~~~~~~~~~~_?@??H??W_?[G?N@?BwC?^_G@~?GB~?CB~_@@~w?G^~??b~{?@N~w?@^~w??~~}??G??O?@??H??C?@a??G?FA??G?N@??C?N_O?@?FwA??G@~?G??_N{?O?@?~w?O?@@~w?G??`~{?A??G~~??O?@N~w?@??D~~_?A??N~~',
 'K03K17': 'r~~~~~~~~~~~~~~~~~~~~~~}??A??H??KO?FA?@wG?N_O?~?O@~?G@~_A?~w?ON~?@@~{?AF~w?AN~w?@N~{??V~~??B~~{??G??G??O?@G??O?BC??G?B`??A?@wG??O?^?_?@?B{@??A?Nw@??A?^w?_?@?^{?G??ON~?@??AB~w?C??G^~_?G??P~~??G??R~~??C??J~~_?@??B~~w',
 'K03K18': 'u~~~~~~~~~~~~~~~~~~~~~~~~~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_F~?A?~{?CB~w?CF~w?AF~{??b~~??C~~w??V~~_??~~~_??_??O??O??c??C??W_??_?FA??A??{C??C?BwC??C?FwA??A?F{?_??_B~?C??C?~w?O??OF~_?_??_^~??_??_~~??O??O~~_?C??C^~w??_??f~~??A??A~~{??C??F~~w',
 'K03K19': 'x~~~~~~~~~~~~~~~~~~~~~~~~~~~~{??@??@G??W_?B`??N@??^?_?^_G?Nw@?B~?C?^{?G@~w?GB~w?CB~{?@@~~??G^~w??b~~_?@N~~??@^~~???~~~o??G??A??@??@G??C??KO??G??wO??G?@wG??C?@{A??@??~?O??G?Nw@???_@~_A??@?F~?A??@?N~?@???_N~_?O??GF~w?A??@@~~??G??CN~{??O??G~~w??O??H~~w??G??D~~{??A??@~~~',
 'K03K20': '{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O@~w?G@~{?A?~~??ON~w?@@~~_?AF~~??AN~~??@N~~_??V~~w??B~~~_??G??@???O??H???O??W_??G??[G??A??N@???O?BwC??@??^_G??A?@~?G??A?B~?C??@?B~_@???O@~w?G??A?^~??_??GB~{?@???ON~w?@???O^~w??_??G^~{??G??AN~~??@???R~~w??C??@^~~_??G??B~~~',
 'K04': 'C~',
 'K04K04': 'O~`HW}GPHDaNaGPCcPWaN',
 'K04K04K04': '~?@?~`HW}GPHDaNaGPCcPWaN_?@??H??W_?[G?G@?@GC?D_G?N?GAG?C@C_@?PW?GAN??aG_?@CPG?@CPW??aG}??G??O?@??H??C?@a??G?FA??G?G@??C?C_O?@?@WA??G?N?G??_G_?O?@?PG?O?@?PW?G??_G{?A??GaG??O?@CPG?@??CPD_?A??GaN_?A??G??O?@??C??c??O?@??W_?A??G?FA??G??_?_C??O?@?@GC??O?@?@WA??G??_?{?_?A??GAG?C??O?@?PG?O?@??C@D_?_?A??GAN??_?A??GaG??O?@??CPC_?C??O?@CPW??_?A??GaN',
 'K04K04K05': '~?@O~}AHKVB{GGPGRCJ`B{GOO`C`AW`AwO`}???O??H??@a??FA??N@??G?O?AGA??R?G?@[?O?Bw?O@A??G?`C?A?GR??O@Aw?@?CN_?ACGO??ACGP??@ACH_??O`Aw??ACG^_??G??@???O??H???O??W_??G??[G??A??N@???O?A?C??@??G_G??A??R?G??A??V?C??@??N_@???O@A??G??A?GP??_??G?`K?@???O@Aw?@???O@Bw??_??GO`???G??ACGP??@???O`AW??C??@ACJ_??G??ACG^_??G??A???O??C??@???c??@???O??W_??G??A??FA???_??G??{C??@???O?A?C??@???O?AGA???_??G?@K?_??G??A??V?C??@???O?Bw?O??C??@?CG??_??G??A?GP??_??G??A?GR??O??C??@?CJ_?C??@???O@Bw??_??G??ACGO??A???_??GO`C??C??@???O`AW??C??@???O`Aw??A???_??GO`{',
 'K04K04K06': '~?@_~~{ACbCwV_~__OOcCW_fAA{CF{CCAAAC__bCCCwOOV___~_???O???c???W_??FA???{C??BwC??C?A??AC?_??b?C??Cw?O??V_?_??~??_?__??O?OO_?C?CCW??_?_f??A?AA{??C?CFw??CCCC???AAAAC???___b???CCCCw???OOOV_???___~_???_???O???O???c???C???W_???_??FA???A???{C???C??BwC???C??C?A???A??AC?_???_??b?C???C??Cw?O???O??V_?_???_??~??_???_?__??O???O?OO_?C???C?CCW??_???_?_f??A???A?AA{??C???C?CFw??C???CCCC???A???AAAAC???_???___b???C???CCCCw???O???OOOV_???_???___~_???_???_???O???O???O???c???C???C???W_???_???_??FA???A???A???{C???C???C??BwC???C???C??C?A???A???A??AC?_???_???_??b?C???C???C??Cw?O???O???O??V_?_???_???_??~??_???_???_?__??O???O???O?OO_?C???C???C?CCW??_???_???_?_f??A???A???A?AA{??C???C???C?CFw??C???C???CCCC???A???A???AAAAC???_???_???___b???C???C???CCCCw???O???O???OOOV_???_???_???___~',
 'K04K05': 'S~}AHKVB{GGPGRCJ`B{GOO`C`AW`AwO`{',
 'K04K05K05': '~?@c~}AHKVB{GGPGRCJ`B{GOO`C`AW`AwO`}CGOO`AHACHaCGVACG^_???G???H???BC???[G??@wG??A?C??@C@???R?G??Aw?_??N_@??GO?@??GP??_?CH_?G?@Aw?@??G^??C?O`???G?`AG??G?`AW??C?O`[??@?CG^???GO`A????`ACG_??@ACGR???@ACGV????`ACNo???G???A???@???@G???C???KO???G???wO???G??@wG???C??@?A???@???P?O???G??AW@????_??J_A???@???^?A???@??GO?@????_?CG_?O???G?@AW?A???@??GV??G???C??`{??O???G?`A???O???G?`AG??G???C?O`K??A???@?CGV???O???G?`Bw??@????`ACG???A???@ACGP???A???@ACGR???@????`ACJ_???O???GO`B{???A???@????O???G???C???C_???O???G???W_???O???G???wO???G???C???{C???A???@???O?_???O???G??AGA???@????_??H_C???A???@???V?C???A???@???^?A???@????_?CG??_???O???G?@AG?C???A???@??GR??O???G???C??`[??_???O???G?@Bw??_???O???G?`A???O???G???C?O`C??C???A???@?CGR???_???O???G?`Aw??A???@????_ACN_??C???A???@ACGO???C???A???@ACGP???A???@????`ACH_???_???O???GO`Aw???C???A???@ACG^',
 'K04K06': 'W~~{ACbCwV_~__OOcCW_fAA{CF{CCAAAC__bCCCwOOV___~',
 'K04K07': '[~~~{@@GWb`N@^?~oGA@@GCKOGwOHwGD{A@~_OGA@?_cA@BCA@FA@?f__OJwCA@~',
 'K04K08': '_~~~~}?OH@aFAN@N_VwB~_G@?OH?OW_G[GAN@?RwC@^_GB~_GA?OC@?c@?OW_GAFA?_G{C@?RwC@?VwA?_N{',
 'K04K09': 'c~~~~~~_A?cBCFAF_bwC~?V{?~{?_A?OC_CBC?_wOAF__C^?_C~?OA~_C?~{?_C?OA?OC_C?_W_C?_wOA?O{C?_C^?_C?fwA?OA~_C?_F~',
 'K04K10': 'g~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~{?O@?A?G?_C_A?GBC?O@?wO@?CF__A?G^?_A?G~?O@?C~_C?O@^w?_A?N~',
 'K04K11': 'k~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{?G?G?O@G?OBC?GB`?A@wG?O^?_@B{@?ANw@?A^w?_@^{?G?^~_@?A?A?C?G?c?G?OBC?G?OFA?C?GF__@?ABwC?G?O~?O?_@F{?_@?A^w?_@?A~w?O?_@~{',
 'K04K12': 'o~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_?_?O?O?c?C?W_?_FA?A?{C?CBwC?CFwA?AF{?_?b~?C?C~w?O?V~_?_?~~_?_?_?O?O?O?c?C?C?W_?_?_FA?A?A?{C?C?CBwC?C?CFwA?A?AF{?_?_?b~?C?C?C~w?O?O?V~_?_?_?~~',
 'K04K13': 's~~~~~~~~~~~~~_?G?H?BC?[G@wGBwCB{@@~?G^w?b~_@N~?@^~??~~o?G?A?@?@G?C?KO?G?wO?G@wG?C@{A?@?~?O?GNw@??`~_A?@F~?A?@N~?@??n~_?O?N~{?A?@??O?G?C?C_?O?G?W_?O?G?wO?G?C?{C?A?@?^?_?O?GFwA?@??_~_C?A?@B~?C?A?@F~?A?@??f~_?_?O?J~w?C?A?@~~',
 'K04K14': 'w~~~~~~~~~~~~~~~o?A?@G?KO?wO@wG@{A?~?ONw@@~_AF~?AN~?@N~_?V~w?B~~_?G?@??O?H??O?W_?G?[G?A?N@??OBwC?@?^_G?A@~?G?AB~?C?@B~_@??P~w?G?A^~??_?J~{?@??^~{?@??O?A??_?G?C_?G?A?BC?@??O?wO?C?@?F__?G?A?^?_?G?A?~?O?C?@?~_C?@??O^w?_?G?AF~?A??_?G~{?C?@??R~w?C?@??V~w?A??_?N~{',
 'K04K15': '{~~~~~~~~~~~~~~~~~{??O?C_?W_?wO?{C?^?_FwA?~_CB~?CF~?AF~_?b~w?C~~??V~{??~~{??_?A??O?C_?C?BC??_?wO?A?F__?C?^?_?C?~?O?A?~_C??_^w?_?CF~?A??O~{?C??b~w?C??f~w?A??V~{??_?F~~_?C??_?A??O?A??c??_?C?BC??_?C?FA??O?A?F__?C??_BwC??_?C?~?O?A??OF{?_?C??_^w?_?C??_~w?O?A??O~{?C??_?C^~??_?C??f~w?A??O?A~~_?C??_?F~~',
 'K04K16': '~?@?~~~~~~~~~~~~~~~~~~~~_?@??H??W_?[G?N@?BwC?^_G@~?GB~?CB~_@@~w?G^~??b~{?@N~w?@^~w??~~}??G??O?@??H??C?@a??G?FA??G?N@??C?N_O?@?FwA??G@~?G??_N{?O?@?~w?O?@@~w?G??`~{?A??G~~??O?@N~w?@??D~~_?A??N~~_?A??G??O?@??C??c??O?@??W_?A??G?FA??G??_?{C??O?@?BwC??O?@?FwA??G??_F{?_?A??GB~?C??O?@?~w?O?@??CF~_?_?A??G^~??_?A??G~~??O?@??C~~_?C??O?@^~w??_?A??N~~',
 'K04K17': '~?@C~~~~~~~~~~~~~~~~~~~~~~}??A??H??KO?FA?@wG?N_O?~?O@~?G@~_A?~w?ON~?@@~{?AF~w?AN~w?@N~{??V~~??B~~{??G??G??O?@G??O?BC??G?B`??A?@wG??O?^?_?@?B{@??A?Nw@??A?^w?_?@?^{?G??ON~?@??AB~w?C??G^~_?G??P~~??G??R~~??C??J~~_?@??B~~{??G??O??O??_?@??C_?@??A??W_?@??A??wO??_?@??{C??G??O?^?_?@??A?FwA??C??G?~_C??G??OB~?C??G??OF~?A??C??GF~_?_?@??AB~w?C??G??O~~??O??_?@F~{??_?@??A^~w??_?@??A~~w??O??_?@~~{',
 'K04K18': '~?@G~~~~~~~~~~~~~~~~~~~~~~~~~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_F~?A?~{?CB~w?CF~w?AF~{??b~~??C~~w??V~~_??~~~_??_??O??O??c??C??W_??_?FA??A??{C??C?BwC??C?FwA??A?F{?_??_B~?C??C?~w?O??OF~_?_??_^~??_??_~~??O??O~~_?C??C^~w??_??f~~??A??A~~{??C??F~~{??C??C??A??A??A??C_??_??_?BC??C??C??wO??O??O?F__??_??_?^?_??_??_?~?O??O??O?~_C??C??C?^w?_??_??_F~?A??A??A?~{?C??C??CB~w?C??C??CF~w?A??A??AF~{??_??_??b~~??C??C??C~~w??O??O??V~~_??_??_??~~~',
 'K04K19': '~?@K~~~~~~~~~~~~~~~~~~~~~~~~~~~~{??@??@G??W_?B`??N@??^?_?^_G?Nw@?B~?C?^{?G@~w?GB~w?CB~{?@@~~??G^~w??b~~_?@N~~??@^~~???~~~o??G??A??@??@G??C??KO??G??wO??G?@wG??C?@{A??@??~?O??G?Nw@???_@~_A??@?F~?A??@?N~?@???_N~_?O??GF~w?A??@@~~??G??CN~{??O??G~~w??O??H~~w??G??D~~{??A??@~~~_??O??G??A??@???_??c??A??@??BC??A??@??FA??@???_?F__??O??G?BwC??A??@??~?O??G??C?F{?_??O??G?^w?_??O??G?~w?O??G??C?~{?C??A??@?^~??_??O??GF~w?A??@???_~~_?C??A??@B~~??C??A??@F~~??A??@???f~~_??_??O??J~~w??C??A??@~~~',
 'K04K20': '~?@O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O@~w?G@~{?A?~~??ON~w?@@~~_?AF~~??AN~~??@N~~_??V~~w??B~~~_??G??@???O??H???O??W_??G??[G??A??N@???O?BwC??@??^_G??A?@~?G??A?B~?C??@?B~_@???O@~w?G??A?^~??_??GB~{?@???ON~w?@???O^~w??_??G^~{??G??AN~~??@???R~~w??C??@^~~_??G??B~~~_??G??A???O??C??@???c??@???O??W_??G??A??FA???_??G??{C??@???O?BwC??@???O?FwA???_??G?F{?_??G??A?B~?C??@???O?~w?O??C??@?F~_?_??G??A?^~??_??G??A?~~??O??C??@?~~_?C??@???O^~w??_??G??AF~~??A???_??G~~{??C??@???R~~w??C??@???V~~w??A???_??N~~{',
 'K05': 'D~{',
 'K05K05': 'X~}AHKVB{GGPGRCJ`B{GOO`C`AW`AwO`}CGOO`AHACHaCGVACG^',
 'K05K05K05': '~?@|~}AHKVB{GGPGRCJ`B{GOO`C`AW`AwO`}CGOO`AHACHaCGVACG^_???G???H???BC???[G??@wG??A?C??@C@???R?G??Aw?_??N_@??GO?@??GP??_?CH_?G?@Aw?@??G^??C?O`???G?`AG??G?`AW??C?O`[??@?CG^???GO`A????`ACG_??@ACGR???@ACGV????`ACNo???G???A???@???@G???C???KO???G???wO???G??@wG???C??@?A???@???P?O???G??AW@????_??J_A???@???^?A???@??GO?@????_?CG_?O???G?@AW?A???@??GV??G???C??`{??O???G?`A???O???G?`AG??G???C?O`K??A???@?CGV???O???G?`Bw??@????`ACG???A???@ACGP???A???@ACGR???@????`ACJ_???O???GO`B{???A???@????O???G???C???C_???O???G???W_???O???G???wO???G???C???{C???A???@???O?_???O???G??AGA???@????_??H_C???A???@???V?C???A???@???^?A???@????_?CG??_???O???G?@AG?C???A???@??GR??O???G???C??`[??_???O???G?@Bw??_???O???G?`A???O???G???C?O`C??C???A???@?CGR???_???O???G?`Aw??A???@????_ACN_??C???A???@ACGO???C???A???@ACGP???A???@????`ACH_???_???O???GO`Aw???C???A???@ACG^_???O???G???C???@????_???O???G???H????_???O???G???W_???O???G???C???[G???C???A???@???N@????_???O???G??A?C???A???@????_??G_G???C???A???@???R?G???C???A???@???V?C???A???@????_??N_@????_???O???G?@A??G???C???A???@??GP??_???O???G???C??`K?@????_???O???G?@Aw?@????_???O???G?@Bw??_???O???G???C?O`???G???C???A???@?CGP??@????_???O???G?`AW??C???A???@????_ACJ_??G???C???A???@?CG^???G???C???A???@ACGO???C???A???@????`ACG_??@????_???O???GO`AW???G???C???A???@ACGV????_???O???G???CGO`{',
 'K05K06': ']~~{ACbCwV_~__OOcCW_fAA{CF{CCAAAC__bCCCwOOV___~____OOOOcCCCW___fAAAA{CCCFw',
 'K05K07': 'b~~~{@@GWb`N@^?~oGA@@GCKOGwOHwGD{A@~_OGA@?_cA@BCA@FA@?f__OJwCA@~_OGC@?_OGH?_OGW_OGC[GCA@N@?_OJwCA@?~_',
 'K05K08': 'g~~~~}?OH@aFAN@N_VwB~_G@?OH?OW_G[GAN@?RwC@^_GB~_GA?OC@?c@?OW_GAFA?_G{C@?RwC@?VwA?_N}?_GA?OC@?OH?OC@@a?_GAFA?_GAN@?OC@N_OC@?VwA?_GB~',
 'K05K09': 'l~~~~~~_A?cBCFAF_bwC~?V{?~{?_A?OC_CBC?_wOAF__C^?_C~?OA~_C?~{?_C?OA?OC_C?_W_C?_wOA?O{C?_C^?_C?fwA?OA~_C?_F~_C?_C?OA?OA?c?_C?_W_C?_CFA?OA?O{C?_C?bwC?_C?fwA?OA?V{?_C?_F~',
 'K05K10': 'q~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~{?O@?A?G?_C_A?GBC?O@?wO@?CF__A?G^?_A?G~?O@?C~_C?O@^w?_A?N~_A?G?_@?C?O@?H?C?O@?W_A?G?_[G?_A?GN@?C?O@BwC?O@?C^_G?_A?H~?G?_A?J~?C?O@?F~_',
 'K05K11': 'v~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{?G?G?O@G?OBC?GB`?A@wG?O^?_@B{@?ANw@?A^w?_@^{?G?^~_@?A?A?C?G?c?G?OBC?G?OFA?C?GF__@?ABwC?G?O~?O?_@F{?_@?A^w?_@?A~w?O?_@~}?C?G?O?O?_@?A?H?A?C?G@a?C?G?OFA?C?G?ON@?A?C?GN_O?_@?AFwA?C?G?P~?G?O?_@N{?O?_@?A~w?O?_@?B~w',
 'K05K12': '{~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_?_?O?O?c?C?W_?_FA?A?{C?CBwC?CFwA?AF{?_?b~?C?C~w?O?V~_?_?~~_?_?_?O?O?O?c?C?C?W_?_?_FA?A?A?{C?C?CBwC?C?CFwA?A?AF{?_?_?b~?C?C?C~w?O?O?V~_?_?_?~~_?_?_?_?O?O?O?O?c?C?C?C?W_?_?_?_FA?A?A?A?{C?C?C?CBwC?C?C?CFwA?A?A?AF{?_?_?_?b~?C?C?C?C~w?O?O?O?V~_?_?_?_?~~',
 'K05K13': '~?@@~~~~~~~~~~~~~_?G?H?BC?[G@wGBwCB{@@~?G^w?b~_@N~?@^~??~~o?G?A?@?@G?C?KO?G?wO?G@wG?C@{A?@?~?O?GNw@??`~_A?@F~?A?@N~?@??n~_?O?N~{?A?@??O?G?C?C_?O?G?W_?O?G?wO?G?C?{C?A?@?^?_?O?GFwA?@??_~_C?A?@B~?C?A?@F~?A?@??f~_?_?O?J~w?C?A?@~~_?O?G?C?@??_?O?G?H??_?O?G?W_?O?G?C?[G?C?A?@?N@??_?O?GBwC?A?@??_^_G?C?A?@@~?G?C?A?@B~?C?A?@??b~_@??_?O?H~w?G?C?A?@^~??_?O?G?F~{',
 'K05K14': '~?@E~~~~~~~~~~~~~~~o?A?@G?KO?wO@wG@{A?~?ONw@@~_AF~?AN~?@N~_?V~w?B~~_?G?@??O?H??O?W_?G?[G?A?N@??OBwC?@?^_G?A@~?G?AB~?C?@B~_@??P~w?G?A^~??_?J~{?@??^~{?@??O?A??_?G?C_?G?A?BC?@??O?wO?C?@?F__?G?A?^?_?G?A?~?O?C?@?~_C?@??O^w?_?G?AF~?A??_?G~{?C?@??R~w?C?@??V~w?A??_?N~}??_?G?A??O?C?@??O?H??O?C?@?@a??_?G?A?FA??_?G?A?N@??O?C?@?N_O?C?@??OFwA??_?G?A@~?G?A??_?GN{?O?C?@??O~w?O?C?@??P~w?G?A??_?H~{?A??_?G?A~~??O?C?@??^~w',
 'K05K15': '~?@J~~~~~~~~~~~~~~~~~{??O?C_?W_?wO?{C?^?_FwA?~_CB~?CF~?AF~_?b~w?C~~??V~{??~~{??_?A??O?C_?C?BC??_?wO?A?F__?C?^?_?C?~?O?A?~_C??_^w?_?CF~?A??O~{?C??b~w?C??f~w?A??V~{??_?F~~_?C??_?A??O?A??c??_?C?BC??_?C?FA??O?A?F__?C??_BwC??_?C?~?O?A??OF{?_?C??_^w?_?C??_~w?O?A??O~{?C??_?C^~??_?C??f~w?A??O?A~~_?C??_?F~~_?C??_?C??O?A??O?A??c??_?C??_?W_?C??_?C?FA??O?A??O?{C??_?C??_BwC??_?C??_FwA??O?A??OF{?_?C??_?CB~?C??_?C??_~w?O?A??O?AF~_?_?C??_?C^~??_?C??_?C~~??O?A??O?A~~_?C??_?C??~~w',
 'K05K16': '~?@O~~~~~~~~~~~~~~~~~~~~_?@??H??W_?[G?N@?BwC?^_G@~?GB~?CB~_@@~w?G^~??b~{?@N~w?@^~w??~~}??G??O?@??H??C?@a??G?FA??G?N@??C?N_O?@?FwA??G@~?G??_N{?O?@?~w?O?@@~w?G??`~{?A??G~~??O?@N~w?@??D~~_?A??N~~_?A??G??O?@??C??c??O?@??W_?A??G?FA??G??_?{C??O?@?BwC??O?@?FwA??G??_F{?_?A??GB~?C??O?@?~w?O?@??CF~_?_?A??G^~??_?A??G~~??O?@??C~~_?C??O?@^~w??_?A??N~~_?A??G??_?@??C??O?@??H??C??O?@??W_?A??G??_?[G??_?A??G?N@??C??O?@?BwC??O?@??C?^_G??_?A??G@~?G??_?A??GB~?C??O?@??CB~_@??C??O?@@~w?G??_?A??G^~??_?A??G??b~{?@??C??O?@N~w?@??C??O?@^~w??_?A??G??~~{',
 'K05K17': '~?@T~~~~~~~~~~~~~~~~~~~~~~}??A??H??KO?FA?@wG?N_O?~?O@~?G@~_A?~w?ON~?@@~{?AF~w?AN~w?@N~{??V~~??B~~{??G??G??O?@G??O?BC??G?B`??A?@wG??O?^?_?@?B{@??A?Nw@??A?^w?_?@?^{?G??ON~?@??AB~w?C??G^~_?G??P~~??G??R~~??C??J~~_?@??B~~{??G??O??O??_?@??C_?@??A??W_?@??A??wO??_?@??{C??G??O?^?_?@??A?FwA??C??G?~_C??G??OB~?C??G??OF~?A??C??GF~_?_?@??AB~w?C??G??O~~??O??_?@F~{??_?@??A^~w??_?@??A~~w??O??_?@~~}??C??G??O??O??_?@??A??H??A??C??G?@a??C??G??O?FA??C??G??O?N@??A??C??G?N_O??_?@??A?FwA??C??G??O@~?G??O??_?@?N{?O??_?@??A?~w?O??_?@??A@~w?G??O??_?@@~{?A??C??G??O~~??O??_?@??AN~w?@??A??C??H~~_?A??C??G??V~~??A??C??G??^~~',
 'K05K18': '~?@Y~~~~~~~~~~~~~~~~~~~~~~~~~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_F~?A?~{?CB~w?CF~w?AF~{??b~~??C~~w??V~~_??~~~_??_??O??O??c??C??W_??_?FA??A??{C??C?BwC??C?FwA??A?F{?_??_B~?C??C?~w?O??OF~_?_??_^~??_??_~~??O??O~~_?C??C^~w??_??f~~??A??A~~{??C??F~~{??C??C??A??A??A??C_??_??_?BC??C??C??wO??O??O?F__??_??_?^?_??_??_?~?O??O??O?~_C??C??C?^w?_??_??_F~?A??A??A?~{?C??C??CB~w?C??C??CF~w?A??A??AF~{??_??_??b~~??C??C??C~~w??O??O??V~~_??_??_??~~~_??_??_??_??O??O??O??O??c??C??C??C??W_??_??_??_?FA??A??A??A??{C??C??C??C?BwC??C??C??C?FwA??A??A??A?F{?_??_??_??_B~?C??C??C??C?~w?O??O??O??OF~_?_??_??_??_^~??_??_??_??_~~??O??O??O??O~~_?C??C??C??C^~w??_??_??_??f~~??A??A??A??A~~{??C??C??C??F~~w',
 'K05K19': '~?@^~~~~~~~~~~~~~~~~~~~~~~~~~~~~{??@??@G??W_?B`??N@??^?_?^_G?Nw@?B~?C?^{?G@~w?GB~w?CB~{?@@~~??G^~w??b~~_?@N~~??@^~~???~~~o??G??A??@??@G??C??KO??G??wO??G?@wG??C?@{A??@??~?O??G?Nw@???_@~_A??@?F~?A??@?N~?@???_N~_?O??GF~w?A??@@~~??G??CN~{??O??G~~w??O??H~~w??G??D~~{??A??@~~~_??O??G??A??@???_??c??A??@??BC??A??@??FA??@???_?F__??O??G?BwC??A??@??~?O??G??C?F{?_??O??G?^w?_??O??G?~w?O??G??C?~{?C??A??@?^~??_??O??GF~w?A??@???_~~_?C??A??@B~~??C??A??@F~~??A??@???f~~_??_??O??J~~w??C??A??@~~~_??O??G??C??@???_??O??G??H???_??O??G??W_??O??G??C??[G??C??A??@??N@???_??O??G?BwC??A??@???_?^_G??C??A??@?@~?G??C??A??@?B~?C??A??@???_B~_@???_??O??G@~w?G??C??A??@?^~??_??O??G??CB~{?@???_??O??GN~w?@???_??O??G^~w??_??O??G??C^~{??G??C??A??@N~~??@???_??O??J~~w??C??A??@???~~~_',
 'K05K20': '~?@c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O@~w?G@~{?A?~~??ON~w?@@~~_?AF~~??AN~~??@N~~_??V~~w??B~~~_??G??@???O??H???O??W_??G??[G??A??N@???O?BwC??@??^_G??A?@~?G??A?B~?C??@?B~_@???O@~w?G??A?^~??_??GB~{?@???ON~w?@???O^~w??_??G^~{??G??AN~~??@???R~~w??C??@^~~_??G??B~~~_??G??A???O??C??@???c??@???O??W_??G??A??FA???_??G??{C??@???O?BwC??@???O?FwA???_??G?F{?_??G??A?B~?C??@???O?~w?O??C??@?F~_?_??G??A?^~??_??G??A?~~??O??C??@?~~_?C??@???O^~w??_??G??AF~~??A???_??G~~{??C??@???R~~w??C??@???V~~w??A???_??N~~}???_??G??A???O??C??@???O??H???O??C??@??@a???_??G??A??FA???_??G??A??N@???O??C??@??N_O??C??@???O?FwA???_??G??A?@~?G??A???_??G?N{?O??C??@???O?~w?O??C??@???O@~w?G??A???_??G@~{?A???_??G??A?~~??O??C??@???ON~w?@???O??C??@@~~_?A???_??G??AF~~??A???_??G??AN~~??@???O??C??@N~~_??O??C??@???V~~w??A???_??G??B~~~',
 'K06': 'E~~w',
 'K06K06': 'c~~{ACbCwV_~__OOcCW_fAA{CF{CCAAAC__bCCCwOOV___~____OOOOcCCCW___fAAAA{CCCF{CCCCAAAAAC____bCCCCCwOOOOV_____~',
 'K06K07': 'i~~~{@@GWb`N@^?~oGA@@GCKOGwOHwGD{A@~_OGA@?_cA@BCA@FA@?f__OJwCA@~_OGC@?_OGH?_OGW_OGC[GCA@N@?_OJwCA@?~oGCA@?OGCA@@GCA@?`a@?_OGwOGCA@N@?_OGD{A@?_ONw',
 'K06K08': 'o~~~~}?OH@aFAN@N_VwB~_G@?OH?OW_G[GAN@?RwC@^_GB~_GA?OC@?c@?OW_GAFA?_G{C@?RwC@?VwA?_N}?_GA?OC@?OH?OC@@a?_GAFA?_GAN@?OC@N_OC@?VwA?_GB~_GA?_G@?OC@?OH?OC@?OW_GA?_G[GA?_GAN@?OC@?RwC@?OC@^_GA?_GB~',
 'K06K09': 'u~~~~~~_A?cBCFAF_bwC~?V{?~{?_A?OC_CBC?_wOAF__C^?_C~?OA~_C?~{?_C?OA?OC_C?_W_C?_wOA?O{C?_C^?_C?fwA?OA~_C?_F~_C?_C?OA?OA?c?_C?_W_C?_CFA?OA?O{C?_C?bwC?_C?fwA?OA?V{?_C?_F~_C?_C?_A?OA?OA?c?_C?_CBC?_C?_CFA?OA?OAF__C?_C?bwC?_C?_C~?OA?OA?V{?_C?_C?~w',
 'K06K10': '{~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~{?O@?A?G?_C_A?GBC?O@?wO@?CF__A?G^?_A?G~?O@?C~_C?O@^w?_A?N~_A?G?_@?C?O@?H?C?O@?W_A?G?_[G?_A?GN@?C?O@BwC?O@?C^_G?_A?H~?G?_A?J~?C?O@?F~o@?C?O@?A?G?_A?G@G?_A?G?_KO@?C?O@?wO@?C?O@@wG?_A?G?`{A?G?_A?G~?O@?C?O@Nw@?C?O@?D~_A?G?_A?N~',
 'K06K11': '~?@A~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{?G?G?O@G?OBC?GB`?A@wG?O^?_@B{@?ANw@?A^w?_@^{?G?^~_@?A?A?C?G?c?G?OBC?G?OFA?C?GF__@?ABwC?G?O~?O?_@F{?_@?A^w?_@?A~w?O?_@~}?C?G?O?O?_@?A?H?A?C?G@a?C?G?OFA?C?G?ON@?A?C?GN_O?_@?AFwA?C?G?P~?G?O?_@N{?O?_@?A~w?O?_@?B~{?G?O?_@?@?A?C?G?O@G?O?_@?A?W_@?A?C?GB`?A?C?G?ON@?A?C?G?O^?_@?A?C?G^_G?O?_@?ANw@?A?C?G?R~?C?G?O?_@^{?G?O?_@?B~w',
 'K06K12': '~?@G~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_?_?O?O?c?C?W_?_FA?A?{C?CBwC?CFwA?AF{?_?b~?C?C~w?O?V~_?_?~~_?_?_?O?O?O?c?C?C?W_?_?_FA?A?A?{C?C?CBwC?C?CFwA?A?AF{?_?_?b~?C?C?C~w?O?O?V~_?_?_?~~_?_?_?_?O?O?O?O?c?C?C?C?W_?_?_?_FA?A?A?A?{C?C?C?CBwC?C?C?CFwA?A?A?AF{?_?_?_?b~?C?C?C?C~w?O?O?O?V~_?_?_?_?~~_?_?_?_?_?O?O?O?O?O?c?C?C?C?C?W_?_?_?_?_FA?A?A?A?A?{C?C?C?C?CBwC?C?C?C?CFwA?A?A?A?AF{?_?_?_?_?b~?C?C?C?C?C~w?O?O?O?O?V~_?_?_?_?_?~~',
 'K06K13': '~?@M~~~~~~~~~~~~~_?G?H?BC?[G@wGBwCB{@@~?G^w?b~_@N~?@^~??~~o?G?A?@?@G?C?KO?G?wO?G@wG?C@{A?@?~?O?GNw@??`~_A?@F~?A?@N~?@??n~_?O?N~{?A?@??O?G?C?C_?O?G?W_?O?G?wO?G?C?{C?A?@?^?_?O?GFwA?@??_~_C?A?@B~?C?A?@F~?A?@??f~_?_?O?J~w?C?A?@~~_?O?G?C?@??_?O?G?H??_?O?G?W_?O?G?C?[G?C?A?@?N@??_?O?GBwC?A?@??_^_G?C?A?@@~?G?C?A?@B~?C?A?@??b~_@??_?O?H~w?G?C?A?@^~??_?O?G?F~}?@??_?O?G?A?@??_?O?G?H??_?O?G?C?KO?G?C?A?@?FA?@??_?O?G@wG?C?A?@??_N_O?G?C?A?@?~?O?G?C?A?@@~?G?C?A?@??`~_A?@??_?O?G~w?O?G?C?A?@N~?@??_?O?G?D~{?A?@??_?O?N~w',
 'K06K14': '~?@S~~~~~~~~~~~~~~~o?A?@G?KO?wO@wG@{A?~?ONw@@~_AF~?AN~?@N~_?V~w?B~~_?G?@??O?H??O?W_?G?[G?A?N@??OBwC?@?^_G?A@~?G?AB~?C?@B~_@??P~w?G?A^~??_?J~{?@??^~{?@??O?A??_?G?C_?G?A?BC?@??O?wO?C?@?F__?G?A?^?_?G?A?~?O?C?@?~_C?@??O^w?_?G?AF~?A??_?G~{?C?@??R~w?C?@??V~w?A??_?N~}??_?G?A??O?C?@??O?H??O?C?@?@a??_?G?A?FA??_?G?A?N@??O?C?@?N_O?C?@??OFwA??_?G?A@~?G?A??_?GN{?O?C?@??O~w?O?C?@??P~w?G?A??_?H~{?A??_?G?A~~??O?C?@??^~{?@??O?C?@??G?A??_?G?A?@G?A??_?G?A?BC?@??O?C?@?B`??O?C?@??O@wG?A??_?G?A?^?_?G?A??_?GB{@??O?C?@??ONw@??O?C?@??O^w?_?G?A??_?G^{?G?A??_?G?AN~?@??O?C?@??R~w?C?@??O?C?@^~_?G?A??_?G?B~~',
 'K06K15': '~?@Y~~~~~~~~~~~~~~~~~{??O?C_?W_?wO?{C?^?_FwA?~_CB~?CF~?AF~_?b~w?C~~??V~{??~~{??_?A??O?C_?C?BC??_?wO?A?F__?C?^?_?C?~?O?A?~_C??_^w?_?CF~?A??O~{?C??b~w?C??f~w?A??V~{??_?F~~_?C??_?A??O?A??c??_?C?BC??_?C?FA??O?A?F__?C??_BwC??_?C?~?O?A??OF{?_?C??_^w?_?C??_~w?O?A??O~{?C??_?C^~??_?C??f~w?A??O?A~~_?C??_?F~~_?C??_?C??O?A??O?A??c??_?C??_?W_?C??_?C?FA??O?A??O?{C??_?C??_BwC??_?C??_FwA??O?A??OF{?_?C??_?CB~?C??_?C??_~w?O?A??O?AF~_?_?C??_?C^~??_?C??_?C~~??O?A??O?A~~_?C??_?C??~~{??_?C??_?C??O?A??O?A??O?C_?C??_?C??_?W_?C??_?C??_?wO?A??O?A??O?{C??_?C??_?C?^?_?C??_?C??_FwA??O?A??O?A?~_C??_?C??_?CB~?C??_?C??_?CF~?A??O?A??O?AF~_?_?C??_?C??b~w?C??_?C??_?C~~??O?A??O?A??V~{??_?C??_?C??~~w',
 'K06K16': '~?@_~~~~~~~~~~~~~~~~~~~~_?@??H??W_?[G?N@?BwC?^_G@~?GB~?CB~_@@~w?G^~??b~{?@N~w?@^~w??~~}??G??O?@??H??C?@a??G?FA??G?N@??C?N_O?@?FwA??G@~?G??_N{?O?@?~w?O?@@~w?G??`~{?A??G~~??O?@N~w?@??D~~_?A??N~~_?A??G??O?@??C??c??O?@??W_?A??G?FA??G??_?{C??O?@?BwC??O?@?FwA??G??_F{?_?A??GB~?C??O?@?~w?O?@??CF~_?_?A??G^~??_?A??G~~??O?@??C~~_?C??O?@^~w??_?A??N~~_?A??G??_?@??C??O?@??H??C??O?@??W_?A??G??_?[G??_?A??G?N@??C??O?@?BwC??O?@??C?^_G??_?A??G@~?G??_?A??GB~?C??O?@??CB~_@??C??O?@@~w?G??_?A??G^~??_?A??G??b~{?@??C??O?@N~w?@??C??O?@^~w??_?A??G??~~}??G??_?A??G??O?@??C??O?@??H??C??O?@??C?@a??G??_?A??G?FA??G??_?A??G?N@??C??O?@??C?N_O?@??C??O?@?FwA??G??_?A??G@~?G??_?A??G??_N{?O?@??C??O?@?~w?O?@??C??O?@@~w?G??_?A??G??`~{?A??G??_?A??G~~??O?@??C??O?@N~w?@??C??O?@??D~~_?A??G??_?A??N~~',
 'K07': 'F~~~w',
 'K07K07': 'p~~~{@@GWb`N@^?~oGA@@GCKOGwOHwGD{A@~_OGA@?_cA@BCA@FA@?f__OJwCA@~_OGC@?_OGH?_OGW_OGC[GCA@N@?_OJwCA@?~oGCA@?OGCA@@GCA@?`a@?_OGwOGCA@N@?_OGD{A@?_ON{A@?_OGA@?_OGCC_OGCA@BCA@?_OGwOGCA@?f__OGCA@^?_OGCA@~',
 'K07K08': 'w~~~~}?OH@aFAN@N_VwB~_G@?OH?OW_G[GAN@?RwC@^_GB~_GA?OC@?c@?OW_GAFA?_G{C@?RwC@?VwA?_N}?_GA?OC@?OH?OC@@a?_GAFA?_GAN@?OC@N_OC@?VwA?_GB~_GA?_G@?OC@?OH?OC@?OW_GA?_G[GA?_GAN@?OC@?RwC@?OC@^_GA?_GB~_GA?_GA?OC@?OC@?c@?OC@?OW_GA?_GAFA?_GA?_G{C@?OC@?RwC@?OC@?VwA?_GA?_N{',
 'K07K09': '~??~~~~~~~_A?cBCFAF_bwC~?V{?~{?_A?OC_CBC?_wOAF__C^?_C~?OA~_C?~{?_C?OA?OC_C?_W_C?_wOA?O{C?_C^?_C?fwA?OA~_C?_F~_C?_C?OA?OA?c?_C?_W_C?_CFA?OA?O{C?_C?bwC?_C?fwA?OA?V{?_C?_F~_C?_C?_A?OA?OA?c?_C?_CBC?_C?_CFA?OA?OAF__C?_C?bwC?_C?_C~?OA?OA?V{?_C?_C?~{?_C?_C?_A?OA?OA?OC_C?_C?_CBC?_C?_C?_wOA?OA?OAF__C?_C?_C^?_C?_C?_C~?OA?OA?OA~_C?_C?_C?~w',
 'K07K10': '~?@E~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~{?O@?A?G?_C_A?GBC?O@?wO@?CF__A?G^?_A?G~?O@?C~_C?O@^w?_A?N~_A?G?_@?C?O@?H?C?O@?W_A?G?_[G?_A?GN@?C?O@BwC?O@?C^_G?_A?H~?G?_A?J~?C?O@?F~o@?C?O@?A?G?_A?G@G?_A?G?_KO@?C?O@?wO@?C?O@@wG?_A?G?`{A?G?_A?G~?O@?C?O@Nw@?C?O@?D~_A?G?_A?N~_A?G?_A?G?O@?C?O@?C?c?O@?C?O@?W_A?G?_A?GFA?G?_A?G?_{C?O@?C?O@BwC?O@?C?O@FwA?G?_A?G?f{?_A?G?_A?J~?C?O@?C?O@~w',
 'K07K11': '~?@L~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{?G?G?O@G?OBC?GB`?A@wG?O^?_@B{@?ANw@?A^w?_@^{?G?^~_@?A?A?C?G?c?G?OBC?G?OFA?C?GF__@?ABwC?G?O~?O?_@F{?_@?A^w?_@?A~w?O?_@~}?C?G?O?O?_@?A?H?A?C?G@a?C?G?OFA?C?G?ON@?A?C?GN_O?_@?AFwA?C?G?P~?G?O?_@N{?O?_@?A~w?O?_@?B~{?G?O?_@?@?A?C?G?O@G?O?_@?A?W_@?A?C?GB`?A?C?G?ON@?A?C?G?O^?_@?A?C?G^_G?O?_@?ANw@?A?C?G?R~?C?G?O?_@^{?G?O?_@?B~{?G?O?_@?A?A?C?G?O?_@?C_@?A?C?G?OBC?G?O?_@?A?wO?_@?A?C?GF__@?A?C?G?O^?_@?A?C?G?O~?O?_@?A?C?G~_C?G?O?_@?A^w?_@?A?C?G?V~?A?C?G?O?_@~{',
 'K07K12': '~?@S~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_?_?O?O?c?C?W_?_FA?A?{C?CBwC?CFwA?AF{?_?b~?C?C~w?O?V~_?_?~~_?_?_?O?O?O?c?C?C?W_?_?_FA?A?A?{C?C?CBwC?C?CFwA?A?AF{?_?_?b~?C?C?C~w?O?O?V~_?_?_?~~_?_?_?_?O?O?O?O?c?C?C?C?W_?_?_?_FA?A?A?A?{C?C?C?CBwC?C?C?CFwA?A?A?AF{?_?_?_?b~?C?C?C?C~w?O?O?O?V~_?_?_?_?~~_?_?_?_?_?O?O?O?O?O?c?C?C?C?C?W_?_?_?_?_FA?A?A?A?A?{C?C?C?C?CBwC?C?C?C?CFwA?A?A?A?AF{?_?_?_?_?b~?C?C?C?C?C~w?O?O?O?O?V~_?_?_?_?_?~~_?_?_?_?_?_?O?O?O?O?O?O?c?C?C?C?C?C?W_?_?_?_?_?_FA?A?A?A?A?A?{C?C?C?C?C?CBwC?C?C?C?C?CFwA?A?A?A?A?AF{?_?_?_?_?_?b~?C?C?C?C?C?C~w?O?O?O?O?O?V~_?_?_?_?_?_?~~',
 'K07K13': '~?@Z~~~~~~~~~~~~~_?G?H?BC?[G@wGBwCB{@@~?G^w?b~_@N~?@^~??~~o?G?A?@?@G?C?KO?G?wO?G@wG?C@{A?@?~?O?GNw@??`~_A?@F~?A?@N~?@??n~_?O?N~{?A?@??O?G?C?C_?O?G?W_?O?G?wO?G?C?{C?A?@?^?_?O?GFwA?@??_~_C?A?@B~?C?A?@F~?A?@??f~_?_?O?J~w?C?A?@~~_?O?G?C?@??_?O?G?H??_?O?G?W_?O?G?C?[G?C?A?@?N@??_?O?GBwC?A?@??_^_G?C?A?@@~?G?C?A?@B~?C?A?@??b~_@??_?O?H~w?G?C?A?@^~??_?O?G?F~}?@??_?O?G?A?@??_?O?G?H??_?O?G?C?KO?G?C?A?@?FA?@??_?O?G@wG?C?A?@??_N_O?G?C?A?@?~?O?G?C?A?@@~?G?C?A?@??`~_A?@??_?O?G~w?O?G?C?A?@N~?@??_?O?G?D~{?A?@??_?O?N~{?A?@??_?O?G?A?@??_?O?G?C?C_?O?G?C?A?@?BC?A?@??_?O?G?wO?G?C?A?@??_F__?O?G?C?A?@?^?_?O?G?C?A?@?~?O?G?C?A?@??_~_C?A?@??_?O?G^w?_?O?G?C?A?@F~?A?@??_?O?G?C~{?C?A?@??_?O?J~w?C?A?@??_?O?N~w',
 'K07K14': '~?@a~~~~~~~~~~~~~~~o?A?@G?KO?wO@wG@{A?~?ONw@@~_AF~?AN~?@N~_?V~w?B~~_?G?@??O?H??O?W_?G?[G?A?N@??OBwC?@?^_G?A@~?G?AB~?C?@B~_@??P~w?G?A^~??_?J~{?@??^~{?@??O?A??_?G?C_?G?A?BC?@??O?wO?C?@?F__?G?A?^?_?G?A?~?O?C?@?~_C?@??O^w?_?G?AF~?A??_?G~{?C?@??R~w?C?@??V~w?A??_?N~}??_?G?A??O?C?@??O?H??O?C?@?@a??_?G?A?FA??_?G?A?N@??O?C?@?N_O?C?@??OFwA??_?G?A@~?G?A??_?GN{?O?C?@??O~w?O?C?@??P~w?G?A??_?H~{?A??_?G?A~~??O?C?@??^~{?@??O?C?@??G?A??_?G?A?@G?A??_?G?A?BC?@??O?C?@?B`??O?C?@??O@wG?A??_?G?A?^?_?G?A??_?GB{@??O?C?@??ONw@??O?C?@??O^w?_?G?A??_?G^{?G?A??_?G?AN~?@??O?C?@??R~w?C?@??O?C?@^~_?G?A??_?G?B~~_?G?A??_?G?A??O?C?@??O?C?@??c?@??O?C?@??O?W_?G?A??_?G?A?FA??_?G?A??_?G?{C?@??O?C?@??OBwC?@??O?C?@??OFwA??_?G?A??_?GF{?_?G?A??_?G?AB~?C?@??O?C?@??O~w?O?C?@??O?C?@F~_?_?G?A??_?G?A^~??_?G?A??_?G?A~~??O?C?@??O?C?@~~_',
 'K08': 'G~~~~{',
 'K08K08': '~?@?~~~~}?OH@aFAN@N_VwB~_G@?OH?OW_G[GAN@?RwC@^_GB~_GA?OC@?c@?OW_GAFA?_G{C@?RwC@?VwA?_N}?_GA?OC@?OH?OC@@a?_GAFA?_GAN@?OC@N_OC@?VwA?_GB~_GA?_G@?OC@?OH?OC@?OW_GA?_G[GA?_GAN@?OC@?RwC@?OC@^_GA?_GB~_GA?_GA?OC@?OC@?c@?OC@?OW_GA?_GAFA?_GA?_G{C@?OC@?RwC@?OC@?VwA?_GA?_N}?_GA?_GA?OC@?OC@?OH?OC@?OC@@a?_GA?_GAFA?_GA?_GAN@?OC@?OC@N_OC@?OC@?VwA?_GA?_GB~',
 'K08K09': '~?@G~~~~~~_A?cBCFAF_bwC~?V{?~{?_A?OC_CBC?_wOAF__C^?_C~?OA~_C?~{?_C?OA?OC_C?_W_C?_wOA?O{C?_C^?_C?fwA?OA~_C?_F~_C?_C?OA?OA?c?_C?_W_C?_CFA?OA?O{C?_C?bwC?_C?fwA?OA?V{?_C?_F~_C?_C?_A?OA?OA?c?_C?_CBC?_C?_CFA?OA?OAF__C?_C?bwC?_C?_C~?OA?OA?V{?_C?_C?~{?_C?_C?_A?OA?OA?OC_C?_C?_CBC?_C?_C?_wOA?OA?OAF__C?_C?_C^?_C?_C?_C~?OA?OA?OA~_C?_C?_C?~{?_C?_C?_C?OA?OA?OA?OC_C?_C?_C?_W_C?_C?_C?_wOA?OA?OA?O{C?_C?_C?_C^?_C?_C?_C?fwA?OA?OA?OA~_C?_C?_C?_F~',
 'K08K10': '~?@O~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~{?O@?A?G?_C_A?GBC?O@?wO@?CF__A?G^?_A?G~?O@?C~_C?O@^w?_A?N~_A?G?_@?C?O@?H?C?O@?W_A?G?_[G?_A?GN@?C?O@BwC?O@?C^_G?_A?H~?G?_A?J~?C?O@?F~o@?C?O@?A?G?_A?G@G?_A?G?_KO@?C?O@?wO@?C?O@@wG?_A?G?`{A?G?_A?G~?O@?C?O@Nw@?C?O@?D~_A?G?_A?N~_A?G?_A?G?O@?C?O@?C?c?O@?C?O@?W_A?G?_A?GFA?G?_A?G?_{C?O@?C?O@BwC?O@?C?O@FwA?G?_A?G?f{?_A?G?_A?J~?C?O@?C?O@~{?O@?C?O@?C?G?_A?G?_A?G@G?_A?G?_A?GBC?O@?C?O@?CB`?C?O@?C?O@@wG?_A?G?_A?G^?_A?G?_A?G?b{@?C?O@?C?O@Nw@?C?O@?C?O@^w?_A?G?_A?G?~{',
 'K08K11': '~?@W~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{?G?G?O@G?OBC?GB`?A@wG?O^?_@B{@?ANw@?A^w?_@^{?G?^~_@?A?A?C?G?c?G?OBC?G?OFA?C?GF__@?ABwC?G?O~?O?_@F{?_@?A^w?_@?A~w?O?_@~}?C?G?O?O?_@?A?H?A?C?G@a?C?G?OFA?C?G?ON@?A?C?GN_O?_@?AFwA?C?G?P~?G?O?_@N{?O?_@?A~w?O?_@?B~{?G?O?_@?@?A?C?G?O@G?O?_@?A?W_@?A?C?GB`?A?C?G?ON@?A?C?G?O^?_@?A?C?G^_G?O?_@?ANw@?A?C?G?R~?C?G?O?_@^{?G?O?_@?B~{?G?O?_@?A?A?C?G?O?_@?C_@?A?C?G?OBC?G?O?_@?A?wO?_@?A?C?GF__@?A?C?G?O^?_@?A?C?G?O~?O?_@?A?C?G~_C?G?O?_@?A^w?_@?A?C?G?V~?A?C?G?O?_@~}?C?G?O?_@?A?A?C?G?O?_@?A?H?A?C?G?O?_@?KO?_@?A?C?G?OFA?C?G?O?_@?A@wG?O?_@?A?C?GN_O?_@?A?C?G?O~?O?_@?A?C?G?P~?G?O?_@?A?C?H~_A?C?G?O?_@?A~w?O?_@?A?C?G?^~',
 'K08K12': '~?@_~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_?_?O?O?c?C?W_?_FA?A?{C?CBwC?CFwA?AF{?_?b~?C?C~w?O?V~_?_?~~_?_?_?O?O?O?c?C?C?W_?_?_FA?A?A?{C?C?CBwC?C?CFwA?A?AF{?_?_?b~?C?C?C~w?O?O?V~_?_?_?~~_?_?_?_?O?O?O?O?c?C?C?C?W_?_?_?_FA?A?A?A?{C?C?C?CBwC?C?C?CFwA?A?A?AF{?_?_?_?b~?C?C?C?C~w?O?O?O?V~_?_?_?_?~~_?_?_?_?_?O?O?O?O?O?c?C?C?C?C?W_?_?_?_?_FA?A?A?A?A?{C?C?C?C?CBwC?C?C?C?CFwA?A?A?A?AF{?_?_?_?_?b~?C?C?C?C?C~w?O?O?O?O?V~_?_?_?_?_?~~_?_?_?_?_?_?O?O?O?O?O?O?c?C?C?C?C?C?W_?_?_?_?_?_FA?A?A?A?A?A?{C?C?C?C?C?CBwC?C?C?C?C?CFwA?A?A?A?A?AF{?_?_?_?_?_?b~?C?C?C?C?C?C~w?O?O?O?O?O?V~_?_?_?_?_?_?~~_?_?_?_?_?_?_?O?O?O?O?O?O?O?c?C?C?C?C?C?C?W_?_?_?_?_?_?_FA?A?A?A?A?A?A?{C?C?C?C?C?C?CBwC?C?C?C?C?C?CFwA?A?A?A?A?A?AF{?_?_?_?_?_?_?b~?C?C?C?C?C?C?C~w?O?O?O?O?O?O?V~_?_?_?_?_?_?_?~~',
 'K09': 'H~~~~~~',
 'K09K09': '~?@P~~~~~~_A?cBCFAF_bwC~?V{?~{?_A?OC_CBC?_wOAF__C^?_C~?OA~_C?~{?_C?OA?OC_C?_W_C?_wOA?O{C?_C^?_C?fwA?OA~_C?_F~_C?_C?OA?OA?c?_C?_W_C?_CFA?OA?O{C?_C?bwC?_C?fwA?OA?V{?_C?_F~_C?_C?_A?OA?OA?c?_C?_CBC?_C?_CFA?OA?OAF__C?_C?bwC?_C?_C~?OA?OA?V{?_C?_C?~{?_C?_C?_A?OA?OA?OC_C?_C?_CBC?_C?_C?_wOA?OA?OAF__C?_C?_C^?_C?_C?_C~?OA?OA?OA~_C?_C?_C?~{?_C?_C?_C?OA?OA?OA?OC_C?_C?_C?_W_C?_C?_C?_wOA?OA?OA?O{C?_C?_C?_C^?_C?_C?_C?fwA?OA?OA?OA~_C?_C?_C?_F~_C?_C?_C?_C?OA?OA?OA?OA?c?_C?_C?_C?_W_C?_C?_C?_CFA?OA?OA?OA?O{C?_C?_C?_C?bwC?_C?_C?_C?fwA?OA?OA?OA?V{?_C?_C?_C?_F~',
 'K09K10': '~?@Y~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~{?O@?A?G?_C_A?GBC?O@?wO@?CF__A?G^?_A?G~?O@?C~_C?O@^w?_A?N~_A?G?_@?C?O@?H?C?O@?W_A?G?_[G?_A?GN@?C?O@BwC?O@?C^_G?_A?H~?G?_A?J~?C?O@?F~o@?C?O@?A?G?_A?G@G?_A?G?_KO@?C?O@?wO@?C?O@@wG?_A?G?`{A?G?_A?G~?O@?C?O@Nw@?C?O@?D~_A?G?_A?N~_A?G?_A?G?O@?C?O@?C?c?O@?C?O@?W_A?G?_A?GFA?G?_A?G?_{C?O@?C?O@BwC?O@?C?O@FwA?G?_A?G?f{?_A?G?_A?J~?C?O@?C?O@~{?O@?C?O@?C?G?_A?G?_A?G@G?_A?G?_A?GBC?O@?C?O@?CB`?C?O@?C?O@@wG?_A?G?_A?G^?_A?G?_A?G?b{@?C?O@?C?O@Nw@?C?O@?C?O@^w?_A?G?_A?G?~}?G?_A?G?_A?G?O@?C?O@?C?O@?H?C?O@?C?O@?C@a?G?_A?G?_A?GFA?G?_A?G?_A?GN@?C?O@?C?O@?CN_O@?C?O@?C?O@FwA?G?_A?G?_A?H~?G?_A?G?_A?G?n{?O@?C?O@?C?O@~w',
 'K09K11': '~?@b~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{?G?G?O@G?OBC?GB`?A@wG?O^?_@B{@?ANw@?A^w?_@^{?G?^~_@?A?A?C?G?c?G?OBC?G?OFA?C?GF__@?ABwC?G?O~?O?_@F{?_@?A^w?_@?A~w?O?_@~}?C?G?O?O?_@?A?H?A?C?G@a?C?G?OFA?C?G?ON@?A?C?GN_O?_@?AFwA?C?G?P~?G?O?_@N{?O?_@?A~w?O?_@?B~{?G?O?_@?@?A?C?G?O@G?O?_@?A?W_@?A?C?GB`?A?C?G?ON@?A?C?G?O^?_@?A?C?G^_G?O?_@?ANw@?A?C?G?R~?C?G?O?_@^{?G?O?_@?B~{?G?O?_@?A?A?C?G?O?_@?C_@?A?C?G?OBC?G?O?_@?A?wO?_@?A?C?GF__@?A?C?G?O^?_@?A?C?G?O~?O?_@?A?C?G~_C?G?O?_@?A^w?_@?A?C?G?V~?A?C?G?O?_@~}?C?G?O?_@?A?A?C?G?O?_@?A?H?A?C?G?O?_@?KO?_@?A?C?G?OFA?C?G?O?_@?A@wG?O?_@?A?C?GN_O?_@?A?C?G?O~?O?_@?A?C?G?P~?G?O?_@?A?C?H~_A?C?G?O?_@?A~w?O?_@?A?C?G?^~_@?A?C?G?O?_@?@?A?C?G?O?_@?A?H?A?C?G?O?_@?A?W_@?A?C?G?O?_@?[G?O?_@?A?C?G?ON@?A?C?G?O?_@?ABwC?G?O?_@?A?C?G^_G?O?_@?A?C?G?P~?G?O?_@?A?C?G?R~?C?G?O?_@?A?C?J~_@?A?C?G?O?_@?B~w',
 'K10': 'I~~~~~~~w',
 'K10K10': '~?@c~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}?G?O@?H?C@a?GFA?GN@?CN_O@FwA?H~?G?n{?O@~{?O@?A?G?_C_A?GBC?O@?wO@?CF__A?G^?_A?G~?O@?C~_C?O@^w?_A?N~_A?G?_@?C?O@?H?C?O@?W_A?G?_[G?_A?GN@?C?O@BwC?O@?C^_G?_A?H~?G?_A?J~?C?O@?F~o@?C?O@?A?G?_A?G@G?_A?G?_KO@?C?O@?wO@?C?O@@wG?_A?G?`{A?G?_A?G~?O@?C?O@Nw@?C?O@?D~_A?G?_A?N~_A?G?_A?G?O@?C?O@?C?c?O@?C?O@?W_A?G?_A?GFA?G?_A?G?_{C?O@?C?O@BwC?O@?C?O@FwA?G?_A?G?f{?_A?G?_A?J~?C?O@?C?O@~{?O@?C?O@?C?G?_A?G?_A?G@G?_A?G?_A?GBC?O@?C?O@?CB`?C?O@?C?O@@wG?_A?G?_A?G^?_A?G?_A?G?b{@?C?O@?C?O@Nw@?C?O@?C?O@^w?_A?G?_A?G?~}?G?_A?G?_A?G?O@?C?O@?C?O@?H?C?O@?C?O@?C@a?G?_A?G?_A?GFA?G?_A?G?_A?GN@?C?O@?C?O@?CN_O@?C?O@?C?O@FwA?G?_A?G?_A?H~?G?_A?G?_A?G?n{?O@?C?O@?C?O@~{?O@?C?O@?C?O@?A?G?_A?G?_A?G?_C_A?G?_A?G?_A?GBC?O@?C?O@?C?O@?wO@?C?O@?C?O@?CF__A?G?_A?G?_A?G^?_A?G?_A?G?_A?G~?O@?C?O@?C?O@?C~_C?O@?C?O@?C?O@^w?_A?G?_A?G?_A?N~',
 'K11': 'J~~~~~~~~~_',
 'K12': 'K~~~~~~~~~~~',
 'K13': 'L~~~~~~~~~~~~~',
 'K14': 'M~~~~~~~~~~~~~~~_',
 'K15': 'N~~~~~~~~~~~~~~~~~w',
 'K16': 'O~~~~~~~~~~~~~~~~~~~~',
 'K17': 'P~~~~~~~~~~~~~~~~~~~~~~{',
 'K18': 'Q~~~~~~~~~~~~~~~~~~~~~~~~~w',
 'K19': 'R~~~~~~~~~~~~~~~~~~~~~~~~~~~~w',
 'K20': 'S~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{',
 'Lem': 'GqKp_{',
 'LemK02': 'Or`H?cI@WS?hA_@O_TOAj',
 'LemK03': 'W{S{ACbC?O_b?c?Q_CwC_?QC?cWC_?AOC?cB?Cc_?QQ_?cf',
 'LemK04': '_~`HW}?OH@aFA?@?_OWAF?G_?PG?PW?G{?a??COG?P@_?aF?G_??CO?_@C?W?G_F??aG_?@CPG?@CPW??aG{',
 'LemK05': 'g~}AHKVB{?G@GBCB`@wG??_C@?W@?w?_{?GO?@AG?CH_?GV??G^?AC???`?G?CGB??O_[??`@w?O_???GO?C?AC?B??O_?w?@A?F_?ACGO??ACGP??@ACH_??O`Aw??ACG^',
 'LemK06': 'o~~{ACbCwV_~_?O?c?W_FA?{CBwC??A?C?_B?C?w?OF_?_^??__??OO_?CCW??_f??AA{??CFw?CC???AA?C??__B??CC?w??OOF_??__^??__????OO??_?CC??W??__?F??AA??{??CC?Bw??CCCC???AAAAC???___b???CCCCw???OOOV_???___~',
 'LemK07': 'w~~~{@@GWb`N@^?~o?A?@G?KO?wO@wG@{A?~?O??@??_A?B?A?F?@?F_?OBw?A?~??GC???OGG??OGW??GC[??A@N???OJw??@?~_?CA????CA?@??A@?@_??_O?w??CA?N???OG@{???_OFw?@?_?????_O??C??GC??B??@?_??w??CA??F_??GC??^???GC??~???CA@?_???@?_OGG???GCA@B????_OGC[???@?_OHw???@?_OJw????_OGF{',
 'LemK08': '~?@?~~~~}?OH@aFAN@N_VwB~_?@??H??W_?[G?N@?BwC?^_G@~?G???C??_@??W?G?F??_?{?@?Bw?@?Fw??_F{??GA???@?OG??C@@_??GAF???GAN???C@N_??@?Vw???GB~??A?_????C@??G??C@??W??A?_?[???_G?N???C@?Bw???OC?^_???_G@~??A?_?????@?O???_??OC???W??A?_??F???GA???{???OC??Bw???OC??Fw???GA??F{???A?_GA?????OC@?OG???@?OC@@_???A?_GAF????A?_GAN????@?OC@N_????OC@?Vw????A?_GB~',
 'LemK09': '~?@G~~~~~~_A?cBCFAF_bwC~?V{?~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_???A??C?C??W?C??w?A??{??_?^??C?Fw??O?~_??_B~???_C????OA?_??C?_W???_CF???A?O{???C?bw???C?fw???A?V{????_F~???_C?????A?O??_??C?_?B???C?_?F???A?O?F_???_C?Bw???C?_?~????OA?F{????_C?^w??C?_??????A?O???C???_C???B???C?_???w???OA???F_???_C???^????_C???~????OA???~_???C?_??^w????_C?_C?????A?OA?OC????C?_C?_W????C?_C?_w????A?OA?O{?????_C?_C^?????C?_C?fw?????OA?OA~_?????_C?_F~',
 'LemK10': '~?@O~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O????G??C?A??B??O??w?@??F_?A??^??A??~??@??~_??O?^w??A?F~???G?_????O@?G???O@?W???G?_[???A?GN????O@Bw???@?C^_???A?H~????A?J~????@?F~_??C?O??????_A??@???A?G??K???C?O??w???C?O?@w???A?G?@{????_A??~????C?O?Nw????O@?@~_????_A?F~???G?_???????C?O????_??@?C????W???G?_???F????_A????{???@?C???Bw???@?C???Fw????_A???F{????G?_??B~????@?C???~w????C?O@?C??????G?_A?G@?????G?_A?GB?????C?O@?CB_????@?C?O@@w?????G?_A?G^??????_A?G?b{?????@?C?O@Nw?????@?C?O@^w??????_A?G?~{',
 'LemK11': '~?@W~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{???G??@G??BC??B`??@wG??^?_?B{@??Nw@??^w?_?^{?G?N~?@?????C???_?G??B??G??F??C??F_?@??Bw??G??~???_?F{??@??^w??@??~w???_?~{???G?O????@?A?G???C?G@_???G?OF????G?ON????C?GN_???@?AFw????G?P~?????_@N{????@?A~w????@?B~w???O?_??????C?G??@????_@???W???A?C??B_???C?G??N????C?G??^????A?C??^_????_@??Nw????C?G?B~?????O?_?^{?????_@?@~w???O?_????????G?O????C???A?C????B????O?_????w???@?A????F_???A?C????^????A?C????~????@?A????~_????O?_???^w????A?C???F~?????G?O???~{?????O?_@?A???????O?_@?A?G?????G?O?_@?K?????A?C?G?OF??????O?_@?A@w?????@?A?C?GN_?????A?C?G?O~??????A?C?G?P~??????@?A?C?H~_??????O?_@?A~w??????A?C?G?^~',
 'LemK12': '~?@_~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_???O???c???W_??FA???{C??BwC??FwA??F{?_?B~?C??~w?O?F~_?_?^~??_?????O???_?C???W??_??F??A???{??C??Bw??C??Fw??A??F{???_?B~???C??~w???O?F~_???_?^~????_?_?????O?O?_???C?C?W????_?_F????A?A?{????C?CBw????C?CFw????A?AF{?????_?b~?????C?C~w?????O?V~_?????_?~~????_?_???????O?O???_???C?C???W????_?_??F????A?A???{????C?C??Bw????C?C??Fw????A?A??F{?????_?_?B~?????C?C??~w?????O?O?F~_?????_?_?^~????_?_?????????O?O?????_???C?C?????W????_?_????F????A?A?????{????C?C????Bw????C?C????Fw????A?A????F{?????_?_???B~?????C?C????~w?????O?O???F~_?????_?_???^~??????_?_?_?_???????O?O?O?O?_?????C?C?C?C?W??????_?_?_?_F??????A?A?A?A?{??????C?C?C?CBw??????C?C?C?CFw??????A?A?A?AF{???????_?_?_?b~???????C?C?C?C~w???????O?O?O?V~_???????_?_?_?~~',
 'LemQ2': '_r`HOm?OH@ABA?@?_OOAB?G_?PG?PO?Gk?a??COG?P@??aB?G_??CO?_@C?O?G_B??aG_?@CPG?@CPO??aGk',
 'LemQ3': '~?@?r`HOm?OH@ABAG@C_POAJ_?@??H??O_?KG?G@?@GC?D?G?J?G???C??_@??O?G?B??_?_?@?@G?@?@O??_?k??GA???@?OG??C@@???GAB???GAG???C@C_??@?PO???GAJ??A?_????C@??G??C@??O??A?_?K???_G?G???C@?@G???OC?D????_G?J??A?_?????@?O???_??OC???O??A?_??B???GA???_???OC??@G???OC??@O???GA???k???A?_GA?????OC@?OG???@?OC@@????A?_GAB????A?_GAG????@?OC@C_????OC@?PO????A?_GAJ',
 'LemQ4': '~?A?r`HOm?OH@ABAG@C_POAJ_?@??H??O_?KG?G@?@GC?D?G?J?GA??C@?_@?OO?GAB??_G_?@?PG?@?PO??_Gm?????O????H????@A????BA????G@????C_O???@OA????J?G???G??O???OG?O???OO?G???GK?A???AG??O???PG?@???@D??A???AJ??A???????@?????_??O????O??A????B???G????_???O???@G???O???@O???G????k???A???A?????O???OG???@???@@????A???AB????A???AG????@???@C_????O???PO????A???AJ?????G??_???????O?@??G?????O?@??O?????G??_?K?????A??G?G??????O?@?@G?????@??C?D??????A??G?J??????A??GA???????@??C@?_??????O?@?OO??????A??GAB???????G??_G_???????O?@?PG???????O?@?PO???????G??_Gk?????_?A??????????C??O????G?????O?@????@??????_?A????B??????_?A????G??????O?@????C_?????C??O???@O??????_?A????J??????A??G???G???????C??O???OG??????C??O???OO??????A??G???GK???????_?A???AG???????C??O???PG???????O?@???@D????????_?A???AJ?????G??_????????????C??O???????_????@??C???????O?????G??_??????B??????_?A???????_?????@??C??????@G?????@??C??????@O??????_?A???????k??????G??_?????A???????@??C??????OG??????C??O?????@@???????G??_?????AB???????G??_?????AG???????C??O?????@C_??????@??C??????PO???????G??_?????AJ????????_?A??G??_?????????@??C??O?@??G???????@??C??O?@??O????????_?A??G??_?K????????G??_?A??G?G????????@??C??O?@?@G????????C??O?@??C?D?????????G??_?A??G?J?????????G??_?A??GA??????????C??O?@??C@?_????????@??C??O?@?OO?????????G??_?A??GAB??????????_?A??G??_G_?????????@??C??O?@?PG?????????@??C??O?@?PO??????????_?A??G??_Gk',
 'Pet': 'IheA@GUAo',
 'PetK02': 'SrGWOMAO[?G@G?C?`@?GH?a_@DG@D??ac',
 'PetK03': ']{Sw_SF?_A_F_COAc?{??O?C_?W_??O?CC?B?_C?A?O_C?b?CC_?AAO_?_cW?CC_??OQC??_cW',
 'PetK04': 'g~`HW{G@GD_N?G?C_@W?N_?`?@H?@W_?}???O??H??@a??FA???@???_O??WA??F?G?G??O?OG?O?OW?G?G[?A?a???OCOG?@?P@_?A?aF??A?a???@?P?_??OCOW??A?aF',
 'PetK05': 'q~}AHKVBwG?P?R?J_Bw?O?@C?AW?Aw?@}??OO?AH??Ha??VA??^_???G???H???BC???[G??@wG????C???C@???B?G???w?_??F_@??G??@??G@??_?C@_?G?@?w?@??GN??C?O_???G?`?G??G?`?W??C?O_[??@?CGN???G?`?????_AC?_??@?CGB???@?CGF????_ACF_',
 'PetK06': '{~~{ACbCwV_~?_?O_CW?f?A{?Fw?C??AC??b??Cw??V_??~_??_O??Oc??CW_??fA??A{C??F{????A????C_???BC????wO???F__???^?_?????O????_C????W?_???F?A????{?C???Bw?C??C???A??A?C??_??_B??C??C?w??O??OF_??_??_^???_?__????O?OO?_??C?CC?W???_?__F???A?AA?{???C?CCBw???C?CC?????A?AA?C????_?__B????C?CC?w????O?OOF_????_?__^',
 'PetK07': '~?@E~~~{@@GWb`N@^?~_G?@@?CK?Gw?Hw?D{?@~??G???__?@B??@F???f_??Jw??@~_??C@???GH???GW_??C[G??@N@???JwC???~o?????O????@G????@a?????wO????N@????@{A????FwA??????@?????C?O????B?A?????w?G????F_?O????^??O????~??G??@????A???O?G??O??A?B??@???G?[??A???O@w??A???OBw??@???GB{???O?CA?????A??_O?G???G?A@?@_???O?CA?F????O?CA?N????G?A@?N_???A??_OFw????O?CA??????@??OG?C????A??_O?W????A??_O?w????@??OG?{?????O?CA?^?????A??_OFw',
 'PetK08': '~?@O~~~~}?OH@aFAN@N_VwB~?G??OG?OW?G[?AN??Rw?@^_?B~??A???@?_??OW??AF???G{???Rw???Vw???N}???A?O???OH???@@a???AFA???AN@???@N_O???VwA???B~_?????@??????H??????W_?????[G?????N@?????BwC?????^_G????@~?G???????C??????_@??????W?G?????F??_?????{?@?????Bw?@?????Fw??_????F{??G???G????@???@??G??C???C?@_??G???G?F???G???G?N???C???C?N_??@???@?Fw???G???G@~????_?A?_?????@??C@??G???@??C@??W????_?A?_?[????G??_G?N????@??C@?Bw????C??OC?^_????G??_G@~?????G??_G???????C??OC??_????@??C@??W?????G??_G?F??????_?A?_?{?????@??C@?Bw?????@??C@?Fw??????_?A?_F{',
 'PetK09': '~?@Y~~~~~~_A?cBCFAF_bwC~?V{?~w?_??OC?CB??_w?AF_?C^??C~??A~_??~w??C????OC???_W???_w???O{???C^????fw???A~_???F~_???C?O???A?c????_W_???CFA????O{C????bwC????fwA????V{?_???F~_??????A???????c??????BC??????FA??????F__?????BwC??????~?O?????F{?_?????^w?_????????O??????C?C??????B??_??????w?A??????F_?C??????^??C??????~??A??????~_??_?????^w??C????_?????O???A??C???_???C??W???_???C??w???O???A??{???C????_?^????_???C?Fw???A????O?~_???C????_B~????C??C?_??????A??A?O??_????_??_C??W????C??C?_?F?????O??OA??{?????_??_C?Bw?????_??_C?Fw?????O??OA?F{?????C??C?_B~??????_??_C????????A??A?O??_?????C??C?_?B??????C??C?_?F??????A??A?O?F_??????_??_C?Bw??????C??C?_?~???????O??OA?F{???????_??_C?^w',
 'PetK10': '~?@c~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~{?G??@?G?C@_?GF??GN??CN_?@Fw??H~???n{??@~w??@?????_C???GB???@?w???CF_???G^????G~????C~_???@^w????N~_????_@????@?H????@?W_????_[G????GN@????@BwC????C^_G????H~?G????J~?C????F~o???????A???????@G???????KO???????wO??????@wG??????@{A???????~?O??????Nw@??????@~_A??????F~?A?????????@????????_?O???????W?A???????F??G???????{??O??????Bw??O??????Fw??G??????F{??A??????B~???O??????~w??@????@??????A????A??@???A????A??B???@????@??B_???O????O?@w???A????A??^????G????G?B{????O????O?Nw????O????O?^w????G????G?^{????A???_A????????O??C?O??G????@???O@??@_????A???_A??F?????A???_A??N?????@???O@??N_?????O??C?O?Fw?????A???_A?@~??????G??A?G?N{??????O??C?O?~w??????O??C?O?????????G??A?G??C??????A???_A??B???????O??C?O??w??????@???O@??F_??????A???_A??^???????A???_A??~???????@???O@??~_???????O??C?O?^w???????A???_A?F~',
 'PetQ2': 'gr`HOkG@GD?J?G?C_@O?J_?`?@H?@O_?m???O??H??@A??BA???@???_O??OA??B?G?G??O?OG?O?OO?G?GK?A?a???OCOG?@?P@??A?aB??A?a???@?P?_??OCOO??A?aB',
 'PetQ3': '~?@Or`HOm?OH@ABAG@C_POAJ?G??OG?OO?GK?AG??PG?@D??AJ??A???@?_??OO??AB???G_???PG???PO???Gm???A?O???OH???@@A???ABA???AG@???@C_O???POA???AJ_?????@??????H??????O_?????KG?????G@?????@GC?????D?G?????J?G???????C??????_@??????O?G?????B??_?????_?@?????@G?@?????@O??_?????k??G???G????@???@??G??C???C?@???G???G?B???G???G?G???C???C?C_??@???@?@O???G???G?J????_?A?_?????@??C@??G???@??C@??O????_?A?_?K????G??_G?G????@??C@?@G????C??OC?D?????G??_G?J?????G??_G???????C??OC??_????@??C@??O?????G??_G?B??????_?A?_?_?????@??C@?@G?????@??C@?@O??????_?A?_?k',
 'Q2': 'Cr',
 'Q2K03': 'K{S{ACbC_Q_f',
 'Q2K03K03': 'cr`HOmGPHDAJ_?O?c?O_BA?_C@GC@OA?k?aG?CPG?PD??aJ_?_?O?O?c?C?O_?_BA?A?_C?C@GC?C@OA?A?k?_?aG?C?CPG?O?PD??_?aJ',
 'Q2K03K04': 'or`HOmGPHDAJaGPCcPOaJ_?@??H??O_?KG?G@?@GC?D?G?J?GAG?C@C_@?PO?GAJ??aG_?@CPG?@CPO??aGm??G??O?@??H??C?@A??G?BA??G?G@??C?C_O?@?@OA??G?J?G??_G_?O?@?PG?O?@?PO?G??_Gk?A??GaG??O?@CPG?@??CPD??A??GaJ',
 'Q2K03K05': '{r`HOmGPHDAJaGPCcPOaJaG`CPHCPOaGm???O??H??@A??BA??G@??C_O?@OA??J?G?G_?O?PG?O?PO?G?Gk?A?aG??OCPG?@?PD??A?aJ??AGaG??@CPC_??PCPO??AGaJ_??G??@???O??H???O??O_??G??KG??A??G@???O?@GC??@??D?G??A??J?G??A?AG?C??@?@C_@???O?PO?G??A?AJ??_??GAG_?@???OCPG?@???OCPO??_??GAGk??G??AGaG??@???PCPG??C??@CPD???G??AGaJ',
 'Q2K03K06': '~?@Gr`HOmGPHDAJaGPCcPOaJaG`CPHCPOaGmGaGPCPHCPDAGaJ_???O???c???O_??BA???_C??@GC??@OA???k?_?AG?C??PG?O?@D??_?AJ??_?aG??O?PC_?C?CPO??_?aJ??A?aG_??C@CPG??C@CPO??A?aGk???aGaG???CPCPG???PCPD????aGaJ_???_???O???O???c???C???O_???_??BA???A???_C???C??@GC???C??@OA???A???k?_???_?AG?C???C??PG?O???O?@D??_???_?AJ??_???_?aG??O???O?PC_?C???C?CPO??_???_?aJ??A???A?aG_??C???C@CPG??C???C@CPO??A???A?aGk???_???aGaG???C???CPCPG???O???PCPD????_???aGaJ',
 'Q2K03K07': '~?@Sr`HOmGPHDAJaGPCcPOaJaG`CPHCPOaGmGaGPCPHCPDAGaJaGaGPCPCcPCPOaGaJ_???@????H????O_???KG???G@???@GC???D?G???J?G??AG?C??@C_@???PO?G??AJ??_?AG_?@??CPG?@??CPO??_?AGk??G?GaG??@?@CPG??C?CPD???G?GaJ???GAGaG???C@CPC_??@?PCPO???GAGaJ????aGaG_???@CPCPG???@CPCPO????aGaGm????G????O???@????H????C???@A????G???BA????G???G@????C???C_O???@???@OA????G???J?G????_??G_?O???@???PG?O???@???PO?G????_??Gk?A????G??aG??O???@??CPG?@????C??PD??A????G??aJ??A????G?GaG??@????C?CPC_??O???@?@CPO??A????G?GaJ???G????_GaG_???O???@?PCPG???O???@?PCPO???G????_GaGk???A????GaGaG????O???@CPCPG???@????CPCPD????A????GaGaJ',
 'Q2K03K08': '~?@_r`HOmGPHDAJaGPCcPOaJaG`CPHCPOaGmGaGPCPHCPDAGaJaGaGPCPCcPCPOaGaJaGaG`CPCPHCPCPOaGaGm?????O????H????@A????BA????G@????C_O???@OA????J?G???G_?O???PG?O???PO?G???Gk?A???aG??O??CPG?@???PD??A???aJ??A??GaG??@??CPC_??O?@CPO??A??GaJ???G?GaG_???O?PCPG???O?PCPO???G?GaGk???A?aGaG????OCPCPG???@?PCPD????A?aGaJ????AGaGaG????@CPCPC_????PCPCPO????AGaGaJ_????G????@?????O????H?????O????O_????G????KG????A????G@?????O???@GC????@????D?G????A????J?G????A???AG?C????@???@C_@?????O???PO?G????A???AJ??_????G??AG_?@?????O??CPG?@?????O??CPO??_????G??AGk??G????A??GaG??@?????O?@CPG??C????@??CPD???G????A??GaJ???G????A?AGaG???C????@?@CPC_??@?????O?PCPO???G????A?AGaJ????_????GAGaG_???@?????OCPCPG???@?????OCPCPO????_????GAGaGk????G????AGaGaG????@?????PCPCPG????C????@CPCPD?????G????AGaGaJ',
 'Q2K04': 'O~`HW}?OH@aFAG@C_PWAN',
 'Q2K04K04': '~?@?r`HOmGPHDAJaGPCcPOaJ_?@??H??O_?KG?G@?@GC?D?G?J?GAG?C@C_@?PO?GAJ??aG_?@CPG?@CPO??aGm??G??O?@??H??C?@A??G?BA??G?G@??C?C_O?@?@OA??G?J?G??_G_?O?@?PG?O?@?PO?G??_Gk?A??GaG??O?@CPG?@??CPD??A??GaJ_?A??G??O?@??C??c??O?@??O_?A??G?BA??G??_?_C??O?@?@GC??O?@?@OA??G??_?k?_?A??GAG?C??O?@?PG?O?@??C@D??_?A??GAJ??_?A??GaG??O?@??CPC_?C??O?@CPO??_?A??GaJ',
 'Q2K04K05': '~?@Or`HOmGPHDAJaGPCcPOaJaG`CPHCPOaGm???O??H??@A??BA??G@??C_O?@OA??J?G?G_?O?PG?O?PO?G?Gk?A?aG??OCPG?@?PD??A?aJ??AGaG??@CPC_??PCPO??AGaJ_??G??@???O??H???O??O_??G??KG??A??G@???O?@GC??@??D?G??A??J?G??A?AG?C??@?@C_@???O?PO?G??A?AJ??_??GAG_?@???OCPG?@???OCPO??_??GAGk??G??AGaG??@???PCPG??C??@CPD???G??AGaJ_??G??A???O??C??@???c??@???O??O_??G??A??BA???_??G??_C??@???O?@GC??@???O?@OA???_??G??k?_??G??A?AG?C??@???O?PG?O??C??@?@D??_??G??A?AJ??_??G??A?aG??O??C??@?PC_?C??@???OCPO??_??G??A?aJ??A???_??GaG_??C??@???PCPG??C??@???PCPO??A???_??GaGk',
 'Q2K04K06': '~?@_r`HOmGPHDAJaGPCcPOaJaG`CPHCPOaGmGaGPCPHCPDAGaJ_???O???c???O_??BA???_C??@GC??@OA???k?_?AG?C??PG?O?@D??_?AJ??_?aG??O?PC_?C?CPO??_?aJ??A?aG_??C@CPG??C@CPO??A?aGk???aGaG???CPCPG???PCPD????aGaJ_???_???O???O???c???C???O_???_??BA???A???_C???C??@GC???C??@OA???A???k?_???_?AG?C???C??PG?O???O?@D??_???_?AJ??_???_?aG??O???O?PC_?C???C?CPO??_???_?aJ??A???A?aG_??C???C@CPG??C???C@CPO??A???A?aGk???_???aGaG???C???CPCPG???O???PCPD????_???aGaJ_???_???_???O???O???O???c???C???C???O_???_???_??BA???A???A???_C???C???C??@GC???C???C??@OA???A???A???k?_???_???_?AG?C???C???C??PG?O???O???O?@D??_???_???_?AJ??_???_???_?aG??O???O???O?PC_?C???C???C?CPO??_???_???_?aJ??A???A???A?aG_??C???C???C@CPG??C???C???C@CPO??A???A???A?aGk???_???_???aGaG???C???C???CPCPG???O???O???PCPD????_???_???aGaJ',
 'Q2K05': 'S~}AHKVB{?G@GBCB`@wGO?`C@AW@Aw?`{',
 'Q2K05K05': '~?@cr`HOmGPHDAJaGPCcPOaJaG`CPHCPOaGm???O??H??@A??BA??G@??C_O?@OA??J?G?G_?O?PG?O?PO?G?Gk?A?aG??OCPG?@?PD??A?aJ??AGaG??@CPC_??PCPO??AGaJ_??G??@???O??H???O??O_??G??KG??A??G@???O?@GC??@??D?G??A??J?G??A?AG?C??@?@C_@???O?PO?G??A?AJ??_??GAG_?@???OCPG?@???OCPO??_??GAGk??G??AGaG??@???PCPG??C??@CPD???G??AGaJ_??G??A???O??C??@???c??@???O??O_??G??A??BA???_??G??_C??@???O?@GC??@???O?@OA???_??G??k?_??G??A?AG?C??@???O?PG?O??C??@?@D??_??G??A?AJ??_??G??A?aG??O??C??@?PC_?C??@???OCPO??_??G??A?aJ??A???_??GaG_??C??@???PCPG??C??@???PCPO??A???_??GaGm???_??G??A???O??C??@???O??H???O??C??@??@A???_??G??A??BA???_??G??A??G@???O??C??@??C_O??C??@???O?@OA???_??G??A??J?G??A???_??G?G_?O??C??@???O?PG?O??C??@???O?PO?G??A???_??G?Gk?A???_??G??A?aG??O??C??@???OCPG?@???O??C??@?PD??A???_??G??A?aJ??A???_??G??AGaG??@???O??C??@CPC_??O??C??@???PCPO??A???_??G??AGaJ',
 'Q2K06': 'W~~{ACbCwV_~_?O?c?W_FA?{CBwCC?AAC?_b?CCw?OV_?_~',
 'Q2K07': '[~~~{@@GWb`N@^?~o?A?@G?KO?wO@wG@{A?~?OG?@?__A@B?A@F?@?f_?OJw?A@~',
 'Q2K08': '_~~~~}?OH@aFAN@N_VwB~_?@??H??W_?[G?N@?BwC?^_G@~?GA??C@?_@?OW?GAF??_G{?@?Rw?@?Vw??_N{',
 'Q2K09': 'c~~~~~~_A?cBCFAF_bwC~?V{?~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_C??A?OC?C?_W?C?_w?A?O{??_C^??C?fw??OA~_??_F~',
 'Q2K10': 'g~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O@???G?_C?A?GB??O@?w?@?CF_?A?G^??A?G~??@?C~_??O@^w??A?N~',
 'Q2K11': 'k~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{???G??@G??BC??B`??@wG??^?_?B{@??Nw@??^w?_?^{?G?N~?@?A???C?G?_?G?OB??G?OF??C?GF_?@?ABw??G?O~???_@F{??@?A^w??@?A~w???_@~{',
 'Q2K12': 'o~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_???O???c???W_??FA???{C??BwC??FwA??F{?_?B~?C??~w?O?F~_?_?^~??_?_???O?O?_?C?C?W??_?_F??A?A?{??C?CBw??C?CFw??A?AF{???_?b~???C?C~w???O?V~_???_?~~',
 'Q2K13': 's~~~~~~~~~~~~~_?G?H?BC?[G@wGBwCB{@@~?G^w?b~_@N~?@^~??~~o???A???@G???KO???wO??@wG??@{A???~?O??Nw@??@~_A??F~?A??N~?@??N~_?O?F~w?A?@????G?C?C??O?G?W??O?G?w??G?C?{??A?@?^???O?GFw??@??_~_??A?@B~???A?@F~???@??f~_???O?J~w???A?@~~',
 'Q2K14': 'w~~~~~~~~~~~~~~~o?A?@G?KO?wO@wG@{A?~?ONw@@~_AF~?AN~?@N~_?V~w?B~~_???@????H????W_???[G???N@???BwC???^_G??@~?G??B~?C??B~_@??@~w?G??^~??_?B~{?@??N~w?@??O????_?G?C??G?A?B??@??O?w??C?@?F_??G?A?^???G?A?~???C?@?~_??@??O^w???G?AF~????_?G~{???@??R~w???@??V~w????_?N~{',
 'Q2K15': '{~~~~~~~~~~~~~~~~~{??O?C_?W_?wO?{C?^?_FwA?~_CB~?CF~?AF~_?b~w?C~~??V~{??~~{????A????C_???BC????wO???F__???^?_???~?O???~_C???^w?_??F~?A???~{?C??B~w?C??F~w?A??F~{??_?B~~??C??_????O?A??_??_?C?B???_?C?F???O?A?F_??C??_Bw???_?C?~???A??OF{???C??_^w???C??_~w???A??O~{????_?C^~????C??f~w????O?A~~_????_?F~~',
 'Q2K16': '~?@?~~~~~~~~~~~~~~~~~~~~_?@??H??W_?[G?N@?BwC?^_G@~?GB~?CB~_@@~w?G^~??b~{?@N~w?@^~w??~~}?????O????H????@a????FA????N@????N_O???FwA???@~?G???N{?O???~w?O??@~w?G??@~{?A???~~??O??N~w?@??@~~_?A??F~~??A??G????@??C??_??O?@??W??A??G?F???G??_?{???O?@?Bw???O?@?Fw???G??_F{???A??GB~????O?@?~w???@??CF~_???A??G^~????A??G~~????@??C~~_????O?@^~w????A??N~~',
 'Q2K17': '~?@C~~~~~~~~~~~~~~~~~~~~~~}??A??H??KO?FA?@wG?N_O?~?O@~?G@~_A?~w?ON~?@@~{?AF~w?AN~w?@N~{??V~~??B~~{?????G????@G????BC????B`????@wG????^?_???B{@????Nw@????^w?_???^{?G???N~?@???B~w?C???^~_?G??@~~??G??B~~??C??B~~_?@??@~~w??G??O?????_?@??C??@??A??W??@??A??w???_?@??{???G??O?^???@??A?Fw???C??G?~_???G??OB~????G??OF~????C??GF~_???@??AB~w????G??O~~?????_?@F~{????@??A^~w????@??A~~w?????_?@~~{',
 'Q2K18': '~?@G~~~~~~~~~~~~~~~~~~~~~~~~~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_F~?A?~{?CB~w?CF~w?AF~{??b~~??C~~w??V~~_??~~~_?????O?????c?????W_????FA?????{C????BwC????FwA????F{?_???B~?C????~w?O???F~_?_???^~??_???~~??O???~~_?C???^~w??_??F~~??A???~~{??C??B~~w??C??C?????A??A??C???_??_?B???C??C??w???O??O?F_???_??_?^????_??_?~????O??O?~_???C??C?^w????_??_F~????A??A?~{????C??CB~w????C??CF~w????A??AF~{?????_??b~~?????C??C~~w?????O??V~~_?????_??~~~',
 'Q2K19': '~?@K~~~~~~~~~~~~~~~~~~~~~~~~~~~~{??@??@G??W_?B`??N@??^?_?^_G?Nw@?B~?C?^{?G@~w?GB~w?CB~{?@@~~??G^~w??b~~_?@N~~??@^~~???~~~o?????A?????@G?????KO?????wO????@wG????@{A?????~?O????Nw@????@~_A????F~?A????N~?@????N~_?O???F~w?A???@~~??G???N~{??O???~~w??O??@~~w??G??@~~{??A???~~~???O??G?????@???_??_??A??@??B???A??@??F???@???_?F_???O??G?Bw???A??@??~????G??C?F{????O??G?^w????O??G?~w????G??C?~{????A??@?^~?????O??GF~w????@???_~~_????A??@B~~?????A??@F~~?????@???f~~_?????O??J~~w?????A??@~~~',
 'Q2K20': '~?@O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O@~w?G@~{?A?~~??ON~w?@@~~_?AF~~??AN~~??@N~~_??V~~w??B~~~_?????@??????H??????W_?????[G?????N@?????BwC?????^_G????@~?G????B~?C????B~_@????@~w?G????^~??_???B~{?@????N~w?@????^~w??_???^~{??G???N~~??@???B~~w??C???^~~_??G??@~~~???G??A??????C??@???_??@???O??W???G??A??F????_??G??{???@???O?Bw???@???O?Fw????_??G?F{????G??A?B~????@???O?~w????C??@?F~_????G??A?^~?????G??A?~~?????C??@?~~_????@???O^~w?????G??AF~~??????_??G~~{?????@???R~~w?????@???V~~w??????_??N~~{',
 'Q3': 'Gr`HOk',
 'Q3K03': 'W{S{ACbC_Q_f_?O?c?W_CA?SC?wCC?AAC?_b?CC_?OQ_?_f',
 'Q3K03K03': '~?@Gr`HOm?OH@ABAG@C_POAJ_G@?OH?OO_GKGAG@?PGC@D?GAJ_???O???c???O_??BA???_C??@GC??@OA???k?_?A??C??OG?O?@@??_?AB??_?AG??O?@C_?C??PO??_?AJ??A?_G???C@?OG??C@?OO??A?_GK???_GAG???C@?PG???OC@D????_GAJ_???_???O???O???c???C???O_???_??BA???A???_C???C??@GC???C??@OA???A???k?_???_?A??C???C??OG?O???O?@@??_???_?AB??_???_?AG??O???O?@C_?C???C??PO??_???_?AJ??A???A?_G???C???C@?OG??C???C@?OO??A???A?_GK???_???_GAG???C???C@?PG???O???OC@D????_???_GAJ',
 'Q3K03K04': '~?@_r`HOm?OH@ABAG@C_POAJ_G@?OH?OO_GKGAG@?PGC@D?GAJ_GA?OC@?c@?OO_GABA?_G_C@?PGC@?POA?_Gm?????O????H????@A????BA????G@????C_O???@OA????J?G???G??O???OG?O???OO?G???GK?A???AG??O???PG?@???@D??A???AJ??A??GA???@??C@?_??O?@?OO??A??GAB???G??_G_???O?@?PG???O?@?PO???G??_Gk???A?_GA?????OC@?OG???@?OC@@????A?_GAB????A?_GAG????@?OC@C_????OC@?PO????A?_GAJ_????G????@?????O????H?????O????O_????G????KG????A????G@?????O???@GC????@????D?G????A????J?G????A???A??C????@???@?_@?????O???OO?G????A???AB??_????G???G_?@?????O???PG?@?????O???PO??_????G???Gk??G????A??GA???@?????O?@?OG??C????@??C@@???G????A??GAB???G????A??GAG???C????@??C@C_??@?????O?@?PO???G????A??GAJ????_????GA?_G????@?????OC@?OG???@?????OC@?OO????_????GA?_GK????G????A?_GAG????@?????OC@?PG????C????@?OC@D?????G????A?_GAJ',
 'Q3K04': '_~`HW}?OH@aFAG@C_PWAN_?@??H??W_?[G?G@?@GC?D_G?N?GA??C@?_@?OW?GAF??_G_?@?PG?@?PW??_G{',
 'Q3K05': 'g~}AHKVB{?G@GBCB`@wGO?`C@AW@Aw?`}???O??H??@a??FA??N@??G?O?AGA??R?G?@[?O?Bw?O@???G?_C?A?GB??O@?w?@?CF_?A?GO??A?GP??@?CH_??O@Aw??A?G^',
 'Q3K06': 'o~~{ACbCwV_~_?O?c?W_FA?{CBwCC?AAC?_b?CCw?OV_?_~_???O???c???W_??FA???{C??BwC??C?A??AC?_??b?C??Cw?O??V_?_??~??_?_???O?O?_?C?C?W??_?_F??A?A?{??C?CBw??C?CC???A?AAC???_?_b???C?CCw???O?OV_???_?_~',
 'Q3K07': 'w~~~{@@GWb`N@^?~o?A?@G?KO?wO@wG@{A?~?OG?@?__A@B?A@F?@?f_?OJw?A@~_???@????H????W_???[G???N@???BwC???^_G??@??G??@@?C???`_@???Gw?G??@N??_??D{?@???Nw?@??O????_?G?C??G?A?B??@??O?w??C?@?F_??G?A?^???G?A?~???C?@?_???@??OGG???G?A@B????_?GC[???@??OHw???@??OJw????_?GF{',
 'Q3K08': '~?@?~~~~}?OH@aFAN@N_VwB~_?@??H??W_?[G?N@?BwC?^_G@~?GA??C@?_@?OW?GAF??_G{?@?Rw?@?Vw??_N}?????O????H????@a????FA????N@????N_O???FwA???@~?G???G??O???OG?O???OW?G???G[?A???AN??O???Rw?@???@^_?A???B~??A??G????@??C??_??O?@??W??A??G?F???G??_?{???O?@?Bw???O?@?Fw???G??_F{???A??GA?????O?@?OG???@??C@@_???A??GAF????A??GAN????@??C@N_????O?@?Vw????A??GB~',
 'Q3K09': '~?@G~~~~~~_A?cBCFAF_bwC~?V{?~{??A??C_?BC??wO?F__?^?_?~?O?~_C?^w?_C??A?OC?C?_W?C?_w?A?O{??_C^??C?fw??OA~_??_F~_?????O?????c?????W_????FA?????{C????BwC????FwA????F{?_???B~?C????_??O???A?_?_???CB??_???CF??O???AF_?C????bw??_???C~??A????V{??C????~w??C??C?????A??A??C???_??_?B???C??C??w???O??O?F_???_??_?^????_??_?~????O??O?~_???C??C?^w????_??_C?????A??A?OC????C??C?_W????C??C?_w????A??A?O{?????_??_C^?????C??C?fw?????O??OA~_?????_??_F~',
 'Q3K10': '~?@O~~~~~~~{?G@GBCB`@wG^?b{@Nw@^w?~}???O??H??@a??FA??N@??N_O?FwA?@~?G?N{?O?~w?O@???G?_C?A?GB??O@?w?@?CF_?A?G^??A?G~??@?C~_??O@^w??A?N~_?????@??????H??????W_?????[G?????N@?????BwC?????^_G????@~?G????B~?C????B~_@????@???G????G@??_????_K?@????@?w?@????@@w??_????`{??G????G~??@????@Nw??C????D~_??G????N~???G??A??????C??@???_??@???O??W???G??A??F????_??G??{???@???O?Bw???@???O?Fw????_??G?F{????G??A?B~????@???O?~w????C??@?C??????G??A?G@?????G??A?GB?????C??@?CB_????@???O@@w?????G??A?G^??????_??G?b{?????@???O@Nw?????@???O@^w??????_??G?~{',
 'Q3K11': '~?@W~~~~~~~~~o?O@G@a?wON@@{AFwANw@N{?V~?B~{???G??@G??BC??B`??@wG??^?_?B{@??Nw@??^w?_?^{?G?N~?@?A???C?G?_?G?OB??G?OF??C?GF_?@?ABw??G?O~???_@F{??@?A^w??@?A~w???_@~}???????O??????H??????@a??????FA??????N@??????N_O?????FwA?????@~?G?????N{?O?????~w?O????@~w?G????@???A?????O@??O????A?W?@?????GB_?A?????ON??A?????O^??@?????G^_??O????ANw??A?????R~???G????@^{???O????B~w???O??@???????G???_??C???A???G??B????O??@???w???@???C??F_???A???G??^????A???G??~????@???C??~_????O??@??^w????A???G?F~?????G???_?~{?????O??@?A???????O??@?A?G?????G???_@?K?????A???G?OF??????O??@?A@w?????@???C?GN_?????A???G?O~??????A???G?P~??????@???C?H~_??????O??@?A~w??????A???G?^~',
 'Q3K12': '~?@_~~~~~~~~~~~_?O?c?W_FA?{CBwCFwAF{?b~?C~w?V~_?~~_???O???c???W_??FA???{C??BwC??FwA??F{?_?B~?C??~w?O?F~_?_?^~??_?_???O?O?_?C?C?W??_?_F??A?A?{??C?CBw??C?CFw??A?AF{???_?b~???C?C~w???O?V~_???_?~~_???????O???????c???????W_??????FA???????{C??????BwC??????FwA??????F{?_?????B~?C??????~w?O?????F~_?_?????^~??_?????_???O?????O?_?C?????C?W??_?????_F??A?????A?{??C?????CBw??C?????CFw??A?????AF{???_?????b~???C?????C~w???O?????V~_???_?????~~????_???_???????O???O???_???C???C???W????_???_??F????A???A???{????C???C??Bw????C???C??Fw????A???A??F{?????_???_?B~?????C???C??~w?????O???O?F~_?????_???_?^~??????_???_?_???????O???O?O?_?????C???C?C?W??????_???_?_F??????A???A?A?{??????C???C?CBw??????C???C?CFw??????A???A?AF{???????_???_?b~???????C???C?C~w???????O???O?V~_???????_???_?~~',
 'Q4': 'Or`HOm?OH@ABAG@C_POAJ',
 'Q4K03': 'o{S{ACbC_Q_f_?O?c?W_CA?SC?wCC?AAC?_b?CC_?OQ_?_f_???O???c???W_??CA???SC???wC??C?A??AC?_??b?C??C_?O??Q_?_??f??_?_???O?O?_?C?C?W??_?_C??A?A?S??C?C?w??C?CC???A?AAC???_?_b???C?CC_???O?OQ_???_?_f',
 'Q4K04': '~?@?~`HW}?OH@aFAG@C_PWAN_?@??H??W_?[G?G@?@GC?D_G?N?GA??C@?_@?OW?GAF??_G_?@?PG?@?PW??_G}?????O????H????@a????FA????G@????C_O???@WA????N?G???G??O???OG?O???OW?G???G[?A???AG??O???PG?@???@D_?A???AN??A??G????@??C??_??O?@??W??A??G?F???G??_?_???O?@?@G???O?@?@W???G??_?{???A??GA?????O?@?OG???@??C@@_???A??GAF????A??GAG????@??C@C_????O?@?PW????A??GAN',
 'Q4K05': '~?@O~}AHKVB{?G@GBCB`@wGO?`C@AW@Aw?`}???O??H??@a??FA??N@??G?O?AGA??R?G?@[?O?Bw?O@???G?_C?A?GB??O@?w?@?CF_?A?GO??A?GP??@?CH_??O@Aw??A?G^_?????@??????H??????W_?????[G?????N@?????A?C?????G_G?????R?G?????V?C?????N_@????@???G????G@??_????_K?@????@?w?@????@@w??_????`???G????GP??@????@AW??C????CJ_??G????G^???G??A??????C??@???_??@???O??W???G??A??F????_??G??{???@???O?A????@???O?AG????_??G?@K????G??A??V????@???O?Bw????C??@?C??????G??A?G@?????G??A?GB?????C??@?CB_????@???O@@w?????G??A?GO??????_??G?`C?????@???O@AW?????@???O@Aw??????_??G?`{',
 'Q4K06': '~?@_~~{ACbCwV_~_?O?c?W_FA?{CBwCC?AAC?_b?CCw?OV_?_~_???O???c???W_??FA???{C??BwC??C?A??AC?_??b?C??Cw?O??V_?_??~??_?_???O?O?_?C?C?W??_?_F??A?A?{??C?CBw??C?CC???A?AAC???_?_b???C?CCw???O?OV_???_?_~_???????O???????c???????W_??????FA???????{C??????BwC??????C?A??????AC?_??????b?C??????Cw?O??????V_?_??????~??_?????_???O?????O?_?C?????C?W??_?????_F??A?????A?{??C?????CBw??C?????CC???A?????AAC???_?????_b???C?????CCw???O?????OV_???_?????_~????_???_???????O???O???_???C???C???W????_???_??F????A???A???{????C???C??Bw????C???C??C?????A???A??AC?????_???_??b?????C???C??Cw?????O???O??V_?????_???_??~??????_???_?_???????O???O?O?_?????C???C?C?W??????_???_?_F??????A???A?A?{??????C???C?CBw??????C???C?CC???????A???A?AAC???????_???_?_b???????C???C?CCw???????O???O?OV_???????_???_?_~',
 'Q5': '_r`HOm?OH@ABAG@C_POAJ_?@??H??O_?KG?G@?@GC?D?G?J?GA??C@?_@?OO?GAB??_G_?@?PG?@?PO??_Gk',
 'Q5K03': '~?@_{S{ACbC_Q_f_?O?c?W_CA?SC?wCC?AAC?_b?CC_?OQ_?_f_???O???c???W_??CA???SC???wC??C?A??AC?_??b?C??C_?O??Q_?_??f??_?_???O?O?_?C?C?W??_?_C??A?A?S??C?C?w??C?CC???A?AAC???_?_b???C?CC_???O?OQ_???_?_f_???????O???????c???????W_??????CA???????SC???????wC??????C?A??????AC?_??????b?C??????C_?O??????Q_?_??????f??_?????_???O?????O?_?C?????C?W??_?????_C??A?????A?S??C?????C?w??C?????CC???A?????AAC???_?????_b???C?????CC_???O?????OQ_???_?????_f????_???_???????O???O???_???C???C???W????_???_??C????A???A???S????C???C???w????C???C??C?????A???A??AC?????_???_??b?????C???C??C_?????O???O??Q_?????_???_??f??????_???_?_???????O???O?O?_?????C???C?C?W??????_???_?_C??????A???A?A?S??????C???C?C?w??????C???C?CC???????A???A?AAC???????_???_?_b???????C???C?CC_???????O???O?OQ_???????_???_?_f',
 'Q6': '~?@?r`HOm?OH@ABAG@C_POAJ_?@??H??O_?KG?G@?@GC?D?G?J?GA??C@?_@?OO?GAB??_G_?@?PG?@?PO??_Gm?????O????H????@A????BA????G@????C_O???@OA????J?G???G??O???OG?O???OO?G???GK?A???AG??O???PG?@???@D??A???AJ??A??G????@??C??_??O?@??O??A??G?B???G??_?_???O?@?@G???O?@?@O???G??_?k???A??GA?????O?@?OG???@??C@@????A??GAB????A??GAG????@??C@C_????O?@?PO????A??GAJ',
 'Q7': '~?A?r`HOm?OH@ABAG@C_POAJ_?@??H??O_?KG?G@?@GC?D?G?J?GA??C@?_@?OO?GAB??_G_?@?PG?@?PO??_Gm?????O????H????@A????BA????G@????C_O???@OA????J?G???G??O???OG?O???OO?G???GK?A???AG??O???PG?@???@D??A???AJ??A??G????@??C??_??O?@??O??A??G?B???G??_?_???O?@?@G???O?@?@O???G??_?k???A??GA?????O?@?OG???@??C@@????A??GAB????A??GAG????@??C@C_????O?@?PO????A??GAJ_?????????@??????????H??????????O_?????????KG?????????G@?????????@GC?????????D?G?????????J?G????????A??C????????@?_@?????????OO?G????????AB??_????????G_?@?????????PG?@?????????PO??_????????Gk??G???????G????@???????@??G??C???????C?@???G???????G?B???G???????G?G???C???????C?C_??@???????@?@O???G???????G?J????_???????_G????@???????@?OG???@???????@?OO????_???????_GK????G???????GAG????@???????@?PG????C???????C@D?????G???????GAJ?????G????A??????????C????@?????_????@?????O????O?????G????A????B??????_????G????_?????@?????O???@G?????@?????O???@O??????_????G????k??????G????A???A???????@?????O???OG??????C????@???@@???????G????A???AB???????G????A???AG???????C????@???@C_??????@?????O???PO???????G????A???AJ????????_????G??_?????????@?????O?@??G???????@?????O?@??O????????_????G??_?K????????G????A??G?G????????@?????O?@?@G????????C????@??C?D?????????G????A??G?J?????????G????A??GA??????????C????@??C@?_????????@?????O?@?OO?????????G????A??GAB??????????_????G??_G_?????????@?????O?@?PG?????????@?????O?@?PO??????????_????G??_Gk',
 'W05': 'Dl{',
 'W06': 'Ehfw',
 'W07': 'FhENw',
 'W08': 'GhCKN{',
 'W09': 'HhCGKF~',
 'W10': 'IhCGGE@~w',
 'W11': 'JhCGGC@_N~_',
 'W12': 'KhCGGC@?K?~~',
 'W13': 'LhCGGC@?G?o@~~',
 'W14': 'MhCGGC@?G?_@_@~~_',
 'W15': 'NhCGGC@?G?_@?@_?~~w',
 'W16': 'OhCGGC@?G?_@?@??o?N~~',
 'W17': 'PhCGGC@?G?_@?@??_?K?@~~{',
 'W18': 'QhCGGC@?G?_@?@??_?G?@_?F~~w',
 'W19': 'RhCGGC@?G?_@?@??_?G?@??E??N~~w',
 'W20': 'ShCGGC@?G?_@?@??_?G?@??C??K??N~~{'}

for d in class0graphs_dict:
    g = Graph(class0graphs_dict[d])
    g.name(new = d)
    add_to_lists(g, class0graphs, all_graphs)

class0small = [g for g in class0graphs if g.order() < 30]
for g in class0small:
    add_to_lists(g, problem_graphs)


print("loaded graphs")

#############################################################################
# End of graphs section                                                     #
#############################################################################

print("\nRemember to load DIMACS and Sloane graphs if you want them")

#############################################################################
# End of gt.sage file                                                       #
#############################################################################
